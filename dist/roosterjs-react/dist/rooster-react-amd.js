define(["OfficeFabric/Button","OfficeFabric/Callout","OfficeFabric/CommandBar","OfficeFabric/ContextualMenu","OfficeFabric/Dialog","OfficeFabric/FocusZone","OfficeFabric/Icon","OfficeFabric/TextField","OfficeFabric/Tooltip","OfficeFabric/Utilities","react","react-dom"], function(__WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Button__, __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Callout__, __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_CommandBar__, __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_ContextualMenu__, __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Dialog__, __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_FocusZone__, __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Icon__, __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_TextField__, __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Tooltip__, __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Utilities__, __WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_react_dom__) { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./packages/roosterjs-react/lib/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@microsoft/load-themed-styles/lib-es6/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@microsoft/load-themed-styles/lib-es6/index.js ***!
  \*********************************************************************/
/*! exports provided: loadStyles, configureLoadStyles, configureRunMode, flush, loadTheme, clearStyles, detokenize, splitStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadStyles", function() { return loadStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configureLoadStyles", function() { return configureLoadStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configureRunMode", function() { return configureRunMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flush", function() { return flush; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadTheme", function() { return loadTheme; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearStyles", function() { return clearStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detokenize", function() { return detokenize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitStyles", function() { return splitStyles; });
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
// Store the theming state in __themeState__ global scope for reuse in the case of duplicate
// load-themed-styles hosted on the page.
var _root = typeof window === 'undefined' ? global : window; // eslint-disable-line @typescript-eslint/no-explicit-any
// Nonce string to inject into script tag if one provided. This is used in CSP (Content Security Policy).
var _styleNonce = _root && _root.CSPSettings && _root.CSPSettings.nonce;
var _themeState = initializeThemeState();
/**
 * Matches theming tokens. For example, "[theme: themeSlotName, default: #FFF]" (including the quotes).
 */
var _themeTokenRegex = /[\'\"]\[theme:\s*(\w+)\s*(?:\,\s*default:\s*([\\"\']?[\.\,\(\)\#\-\s\w]*[\.\,\(\)\#\-\w][\"\']?))?\s*\][\'\"]/g;
var now = function () {
    return typeof performance !== 'undefined' && !!performance.now ? performance.now() : Date.now();
};
function measure(func) {
    var start = now();
    func();
    var end = now();
    _themeState.perf.duration += end - start;
}
/**
 * initialize global state object
 */
function initializeThemeState() {
    var state = _root.__themeState__ || {
        theme: undefined,
        lastStyleElement: undefined,
        registeredStyles: []
    };
    if (!state.runState) {
        state = __assign(__assign({}, state), { perf: {
                count: 0,
                duration: 0
            }, runState: {
                flushTimer: 0,
                mode: 0 /* sync */,
                buffer: []
            } });
    }
    if (!state.registeredThemableStyles) {
        state = __assign(__assign({}, state), { registeredThemableStyles: [] });
    }
    _root.__themeState__ = state;
    return state;
}
/**
 * Loads a set of style text. If it is registered too early, we will register it when the window.load
 * event is fired.
 * @param {string | ThemableArray} styles Themable style text to register.
 * @param {boolean} loadAsync When true, always load styles in async mode, irrespective of current sync mode.
 */
function loadStyles(styles, loadAsync) {
    if (loadAsync === void 0) { loadAsync = false; }
    measure(function () {
        var styleParts = Array.isArray(styles) ? styles : splitStyles(styles);
        var _a = _themeState.runState, mode = _a.mode, buffer = _a.buffer, flushTimer = _a.flushTimer;
        if (loadAsync || mode === 1 /* async */) {
            buffer.push(styleParts);
            if (!flushTimer) {
                _themeState.runState.flushTimer = asyncLoadStyles();
            }
        }
        else {
            applyThemableStyles(styleParts);
        }
    });
}
/**
 * Allows for customizable loadStyles logic. e.g. for server side rendering application
 * @param {(processedStyles: string, rawStyles?: string | ThemableArray) => void}
 * a loadStyles callback that gets called when styles are loaded or reloaded
 */
function configureLoadStyles(loadStylesFn) {
    _themeState.loadStyles = loadStylesFn;
}
/**
 * Configure run mode of load-themable-styles
 * @param mode load-themable-styles run mode, async or sync
 */
function configureRunMode(mode) {
    _themeState.runState.mode = mode;
}
/**
 * external code can call flush to synchronously force processing of currently buffered styles
 */
function flush() {
    measure(function () {
        var styleArrays = _themeState.runState.buffer.slice();
        _themeState.runState.buffer = [];
        var mergedStyleArray = [].concat.apply([], styleArrays);
        if (mergedStyleArray.length > 0) {
            applyThemableStyles(mergedStyleArray);
        }
    });
}
/**
 * register async loadStyles
 */
function asyncLoadStyles() {
    return setTimeout(function () {
        _themeState.runState.flushTimer = 0;
        flush();
    }, 0);
}
/**
 * Loads a set of style text. If it is registered too early, we will register it when the window.load event
 * is fired.
 * @param {string} styleText Style to register.
 * @param {IStyleRecord} styleRecord Existing style record to re-apply.
 */
function applyThemableStyles(stylesArray, styleRecord) {
    if (_themeState.loadStyles) {
        _themeState.loadStyles(resolveThemableArray(stylesArray).styleString, stylesArray);
    }
    else {
        registerStyles(stylesArray);
    }
}
/**
 * Registers a set theme tokens to find and replace. If styles were already registered, they will be
 * replaced.
 * @param {theme} theme JSON object of theme tokens to values.
 */
function loadTheme(theme) {
    _themeState.theme = theme;
    // reload styles.
    reloadStyles();
}
/**
 * Clear already registered style elements and style records in theme_State object
 * @param option - specify which group of registered styles should be cleared.
 * Default to be both themable and non-themable styles will be cleared
 */
function clearStyles(option) {
    if (option === void 0) { option = 3 /* all */; }
    if (option === 3 /* all */ || option === 2 /* onlyNonThemable */) {
        clearStylesInternal(_themeState.registeredStyles);
        _themeState.registeredStyles = [];
    }
    if (option === 3 /* all */ || option === 1 /* onlyThemable */) {
        clearStylesInternal(_themeState.registeredThemableStyles);
        _themeState.registeredThemableStyles = [];
    }
}
function clearStylesInternal(records) {
    records.forEach(function (styleRecord) {
        var styleElement = styleRecord && styleRecord.styleElement;
        if (styleElement && styleElement.parentElement) {
            styleElement.parentElement.removeChild(styleElement);
        }
    });
}
/**
 * Reloads styles.
 */
function reloadStyles() {
    if (_themeState.theme) {
        var themableStyles = [];
        for (var _i = 0, _a = _themeState.registeredThemableStyles; _i < _a.length; _i++) {
            var styleRecord = _a[_i];
            themableStyles.push(styleRecord.themableStyle);
        }
        if (themableStyles.length > 0) {
            clearStyles(1 /* onlyThemable */);
            applyThemableStyles([].concat.apply([], themableStyles));
        }
    }
}
/**
 * Find theme tokens and replaces them with provided theme values.
 * @param {string} styles Tokenized styles to fix.
 */
function detokenize(styles) {
    if (styles) {
        styles = resolveThemableArray(splitStyles(styles)).styleString;
    }
    return styles;
}
/**
 * Resolves ThemingInstruction objects in an array and joins the result into a string.
 * @param {ThemableArray} splitStyleArray ThemableArray to resolve and join.
 */
function resolveThemableArray(splitStyleArray) {
    var theme = _themeState.theme;
    var themable = false;
    // Resolve the array of theming instructions to an array of strings.
    // Then join the array to produce the final CSS string.
    var resolvedArray = (splitStyleArray || []).map(function (currentValue) {
        var themeSlot = currentValue.theme;
        if (themeSlot) {
            themable = true;
            // A theming annotation. Resolve it.
            var themedValue = theme ? theme[themeSlot] : undefined;
            var defaultValue = currentValue.defaultValue || 'inherit';
            // Warn to console if we hit an unthemed value even when themes are provided, but only if "DEBUG" is true.
            // Allow the themedValue to be undefined to explicitly request the default value.
            if (theme &&
                !themedValue &&
                console &&
                !(themeSlot in theme) &&
                typeof DEBUG !== 'undefined' &&
                DEBUG) {
                console.warn("Theming value not provided for \"" + themeSlot + "\". Falling back to \"" + defaultValue + "\".");
            }
            return themedValue || defaultValue;
        }
        else {
            // A non-themable string. Preserve it.
            return currentValue.rawString;
        }
    });
    return {
        styleString: resolvedArray.join(''),
        themable: themable
    };
}
/**
 * Split tokenized CSS into an array of strings and theme specification objects
 * @param {string} styles Tokenized styles to split.
 */
function splitStyles(styles) {
    var result = [];
    if (styles) {
        var pos = 0; // Current position in styles.
        var tokenMatch = void 0;
        while ((tokenMatch = _themeTokenRegex.exec(styles))) {
            var matchIndex = tokenMatch.index;
            if (matchIndex > pos) {
                result.push({
                    rawString: styles.substring(pos, matchIndex)
                });
            }
            result.push({
                theme: tokenMatch[1],
                defaultValue: tokenMatch[2] // May be undefined
            });
            // index of the first character after the current match
            pos = _themeTokenRegex.lastIndex;
        }
        // Push the rest of the string after the last match.
        result.push({
            rawString: styles.substring(pos)
        });
    }
    return result;
}
/**
 * Registers a set of style text. If it is registered too early, we will register it when the
 * window.load event is fired.
 * @param {ThemableArray} styleArray Array of IThemingInstruction objects to register.
 * @param {IStyleRecord} styleRecord May specify a style Element to update.
 */
function registerStyles(styleArray) {
    if (typeof document === 'undefined') {
        return;
    }
    var head = document.getElementsByTagName('head')[0];
    var styleElement = document.createElement('style');
    var _a = resolveThemableArray(styleArray), styleString = _a.styleString, themable = _a.themable;
    styleElement.setAttribute('data-load-themed-styles', 'true');
    if (_styleNonce) {
        styleElement.setAttribute('nonce', _styleNonce);
    }
    styleElement.appendChild(document.createTextNode(styleString));
    _themeState.perf.count++;
    head.appendChild(styleElement);
    var ev = document.createEvent('HTMLEvents');
    ev.initEvent('styleinsert', true /* bubbleEvent */, false /* cancelable */);
    ev.args = {
        newStyle: styleElement
    };
    document.dispatchEvent(ev);
    var record = {
        styleElement: styleElement,
        themableStyle: styleArray
    };
    if (themable) {
        _themeState.registeredThemableStyles.push(record);
    }
    else {
        _themeState.registeredStyles.push(record);
    }
}
//# sourceMappingURL=index.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/experiment/experimentSetIndentation.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/experiment/experimentSetIndentation.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var blockFormat_1 = __webpack_require__(/*! ../utils/blockFormat */ "./node_modules/roosterjs-editor-api/lib/utils/blockFormat.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_editor_dom_2 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var BlockWrapper = '<blockquote style="margin-top:0;margin-bottom:0"></blockquote>';
/**
 * @internal
 */
function experimentSetIndentation(editor, indentation) {
    var handler = indentation == 0 /* Increase */ ? indent : outdent;
    blockFormat_1.default(editor, function (region, start, end) {
        var blocks = roosterjs_editor_dom_1.getSelectedBlockElementsInRegion(region);
        var blockGroups = [[]];
        for (var i = 0; i < blocks.length; i++) {
            var startNode = blocks[i].getStartNode();
            var vList = roosterjs_editor_dom_2.createVListFromRegion(region, true /*includeSiblingLists*/, startNode);
            if (vList) {
                blockGroups.push([]);
                while (blocks[i + 1] && vList.contains(blocks[i + 1].getStartNode())) {
                    i++;
                }
                vList.setIndentation(start, end, indentation);
                vList.writeBack();
            }
            else {
                blockGroups[blockGroups.length - 1].push(blocks[i]);
            }
        }
        blockGroups.forEach(function (group) { return handler(region, group); });
    });
}
exports.default = experimentSetIndentation;
function indent(region, blocks) {
    if (blocks.length > 0) {
        var startNode = blocks[0].getStartNode();
        var endNode = blocks[blocks.length - 1].getEndNode();
        var nodes = roosterjs_editor_dom_2.collapseNodesInRegion(region, [startNode, endNode]);
        roosterjs_editor_dom_2.wrap(nodes, BlockWrapper);
    }
}
function outdent(region, blocks) {
    blocks.forEach(function (blockElement) {
        var node = blockElement.collapseToSingleElement();
        var quote = roosterjs_editor_dom_2.findClosestElementAncestor(node, region.rootNode, 'blockquote');
        if (quote) {
            if (node == quote) {
                node = roosterjs_editor_dom_2.wrap(roosterjs_editor_dom_2.toArray(node.childNodes));
            }
            while (roosterjs_editor_dom_2.isNodeInRegion(region, node) && roosterjs_editor_dom_2.getTagOfNode(node) != 'BLOCKQUOTE') {
                node = roosterjs_editor_dom_2.splitBalancedNodeRange(node);
            }
            if (roosterjs_editor_dom_2.isNodeInRegion(region, node)) {
                roosterjs_editor_dom_2.unwrap(node);
            }
        }
    });
}
//# sourceMappingURL=experimentSetIndentation.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/experiment/experimentToggleListType.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/experiment/experimentToggleListType.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var blockFormat_1 = __webpack_require__(/*! ../utils/blockFormat */ "./node_modules/roosterjs-editor-api/lib/utils/blockFormat.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * @internal
 */
function experimentToggleListType(editor, listType) {
    blockFormat_1.default(editor, function (region, start, end) {
        var vList = roosterjs_editor_dom_1.createVListFromRegion(region, true /*includeSiblingLists*/);
        if (vList) {
            vList.changeListType(start, end, listType);
            vList.writeBack();
        }
    });
}
exports.default = experimentToggleListType;
//# sourceMappingURL=experimentToggleListType.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/changeFontSize.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/changeFontSize.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var applyInlineStyle_1 = __webpack_require__(/*! ../utils/applyInlineStyle */ "./node_modules/roosterjs-editor-api/lib/utils/applyInlineStyle.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,
 * So that when increase/decrease font size, the font size can match the sequence of your font size picker
 */
exports.FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];
var MIN_FONT_SIZE = 1;
var MAX_FONT_SIZE = 1000;
/**
 * Increase or decrease font size in selection
 * @param editor The editor instance
 * @param change Whether increase or decrease font size
 * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES
 */
function changeFontSize(editor, change, fontSizes) {
    if (fontSizes === void 0) { fontSizes = exports.FONT_SIZES; }
    var changeBase = change == 0 /* Increase */ ? 1 : -1;
    applyInlineStyle_1.default(editor, function (element) {
        var pt = parseFloat(roosterjs_editor_dom_1.getComputedStyle(element, 'font-size'));
        element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';
        var lineHeight = roosterjs_editor_dom_1.getComputedStyle(element, 'line-height');
        if (lineHeight != 'normal') {
            element.style.lineHeight = 'normal';
        }
    });
}
exports.default = changeFontSize;
function getNewFontSize(pt, changeBase, fontSizes) {
    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);
    var last = fontSizes[fontSizes.length - 1];
    if (pt <= fontSizes[0]) {
        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);
    }
    else if (pt > last || (pt == last && changeBase == 1)) {
        pt = pt / 10;
        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);
        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);
    }
    else if (changeBase == 1) {
        for (var i = 0; i < fontSizes.length; i++) {
            if (pt < fontSizes[i]) {
                pt = fontSizes[i];
                break;
            }
        }
    }
    else {
        for (var i = fontSizes.length - 1; i >= 0; i--) {
            if (pt > fontSizes[i]) {
                pt = fontSizes[i];
                break;
            }
        }
    }
    return pt;
}
exports.getNewFontSize = getNewFontSize;
//# sourceMappingURL=changeFontSize.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/clearBlockFormat.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/clearBlockFormat.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var collapseSelectedBlocks_1 = __webpack_require__(/*! ../utils/collapseSelectedBlocks */ "./node_modules/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
exports.TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(',');
exports.TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];
exports.ATTRIBUTES_TO_PRESERVE = ['href'];
/**
 * Clear all formats of selected blocks.
 * When selection is collapsed, only clear format of current block.
 * @param editor The editor instance
 * @param tagsToUnwrap Optional. A string array contains HTML tags in upper case which we will unwrap when clear format
 * @param tagsToStopUnwrap Optional. A string array contains HTML tags in upper case which we will stop unwrap if these tags are hit
 */
function clearBlockFormat(editor, tagsToUnwrap, tagsToStopUnwrap, attributesToPreserve) {
    if (tagsToUnwrap === void 0) { tagsToUnwrap = exports.TAGS_TO_UNWRAP; }
    if (tagsToStopUnwrap === void 0) { tagsToStopUnwrap = exports.TAGS_TO_STOP_UNWRAP; }
    if (attributesToPreserve === void 0) { attributesToPreserve = exports.ATTRIBUTES_TO_PRESERVE; }
    editor.focus();
    editor.addUndoSnapshot(function (start, end) {
        var groups = [{}];
        var stopUnwrapSelector = tagsToStopUnwrap.join(',');
        // 1. Collapse the selected blocks and get first and last element
        collapseSelectedBlocks_1.default(editor, function (element) {
            var group = groups[groups.length - 1];
            var td = editor.getElementAtCursor(stopUnwrapSelector, element);
            if (td != group.td && group.first) {
                groups.push((group = {}));
            }
            group.td = td;
            group.first = group.first || element;
            group.last = element;
        });
        groups
            .filter(function (group) { return group.first; })
            .forEach(function (group) {
            // 2. Collapse with first and last element to make them under same parent
            var nodes = editor.collapseNodes(group.first, group.last, true /*canSplitParent*/);
            // 3. Continue collapse until we can't collapse any more (hit root node, or a table)
            if (canCollapse(tagsToStopUnwrap, nodes[0])) {
                while (editor.contains(nodes[0].parentNode) &&
                    canCollapse(tagsToStopUnwrap, nodes[0].parentNode)) {
                    nodes = [roosterjs_editor_dom_1.splitBalancedNodeRange(nodes)];
                }
            }
            // 4. Clear formats of the nodes
            nodes.forEach(function (node) {
                return clearNodeFormat(node, tagsToUnwrap, tagsToStopUnwrap, attributesToPreserve);
            });
            // 5. Clear CSS of container TD if exist
            if (group.td) {
                var styles = group.td.getAttribute('style') || '';
                var styleArray = styles.split(';');
                styleArray = styleArray.filter(function (style) { return style.trim().toLowerCase().indexOf('border') == 0; });
                styles = styleArray.join(';');
                if (styles) {
                    group.td.setAttribute('style', styles);
                }
                else {
                    group.td.removeAttribute('style');
                }
            }
        });
        editor.select(start, end);
    }, "Format" /* Format */);
}
exports.default = clearBlockFormat;
function clearNodeFormat(node, tagsToUnwrap, tagsToStopUnwrap, attributesToPreserve) {
    if (node.nodeType != 1 /* Element */ || roosterjs_editor_dom_1.getTagOfNode(node) == 'BR') {
        return false;
    }
    // 1. Recursively clear format of all its child nodes
    var allChildrenAreBlock = roosterjs_editor_dom_1.toArray(node.childNodes)
        .map(function (n) { return clearNodeFormat(n, tagsToUnwrap, tagsToStopUnwrap, attributesToPreserve); })
        .reduce(function (previousValue, value) { return previousValue && value; }, true);
    if (!canCollapse(tagsToStopUnwrap, node)) {
        return false;
    }
    var returnBlockElement = roosterjs_editor_dom_1.isBlockElement(node);
    // 2. If we should unwrap this tag, put it into an array and unwrap it later
    if (tagsToUnwrap.indexOf(roosterjs_editor_dom_1.getTagOfNode(node)) >= 0 || allChildrenAreBlock) {
        if (returnBlockElement && !allChildrenAreBlock) {
            roosterjs_editor_dom_1.wrap(node);
        }
        roosterjs_editor_dom_1.unwrap(node);
    }
    else {
        // 3. Otherwise, remove all attributes
        clearAttribute(node, attributesToPreserve);
    }
    return returnBlockElement;
}
function clearAttribute(element, attributesToPreserve) {
    for (var _i = 0, _a = roosterjs_editor_dom_1.toArray(element.attributes); _i < _a.length; _i++) {
        var attr = _a[_i];
        if (attributesToPreserve.indexOf(attr.name.toLowerCase()) < 0 &&
            attr.name.indexOf('data-') != 0) {
            element.removeAttribute(attr.name);
        }
    }
}
function canCollapse(tagsToStopUnwrap, node) {
    return tagsToStopUnwrap.indexOf(roosterjs_editor_dom_1.getTagOfNode(node)) < 0;
}
//# sourceMappingURL=clearBlockFormat.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/clearFormat.js":
/*!*********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/clearFormat.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var execCommand_1 = __webpack_require__(/*! ../utils/execCommand */ "./node_modules/roosterjs-editor-api/lib/utils/execCommand.js");
var setBackgroundColor_1 = __webpack_require__(/*! ./setBackgroundColor */ "./node_modules/roosterjs-editor-api/lib/format/setBackgroundColor.js");
var setFontName_1 = __webpack_require__(/*! ./setFontName */ "./node_modules/roosterjs-editor-api/lib/format/setFontName.js");
var setFontSize_1 = __webpack_require__(/*! ./setFontSize */ "./node_modules/roosterjs-editor-api/lib/format/setFontSize.js");
var setTextColor_1 = __webpack_require__(/*! ./setTextColor */ "./node_modules/roosterjs-editor-api/lib/format/setTextColor.js");
var toggleBold_1 = __webpack_require__(/*! ./toggleBold */ "./node_modules/roosterjs-editor-api/lib/format/toggleBold.js");
var toggleItalic_1 = __webpack_require__(/*! ./toggleItalic */ "./node_modules/roosterjs-editor-api/lib/format/toggleItalic.js");
var toggleUnderline_1 = __webpack_require__(/*! ./toggleUnderline */ "./node_modules/roosterjs-editor-api/lib/format/toggleUnderline.js");
var STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];
/**
 * Clear the format in current selection, after cleaning, the format will be
 * changed to default format. The format that get cleaned include B/I/U/font name/
 * font size/text color/background color/align left/align right/align center/superscript/subscript
 * @param editor The editor instance
 */
function clearFormat(editor) {
    editor.focus();
    editor.addUndoSnapshot(function () {
        execCommand_1.default(editor, "removeFormat" /* RemoveFormat */);
        editor.queryElements('[class]', 1 /* OnSelection */, function (node) {
            return node.removeAttribute('class');
        });
        var defaultFormat = editor.getDefaultFormat();
        var isDefaultFormatEmpty = Object.keys(defaultFormat).length === 0;
        editor.queryElements('[style]', 2 /* InSelection */, function (node) {
            STYLES_TO_REMOVE.forEach(function (style) { return node.style.removeProperty(style); });
            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style
            // (note: because default format is empty, we're not adding style back in)
            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {
                node.removeAttribute('style');
            }
        });
        if (!isDefaultFormatEmpty) {
            if (defaultFormat.fontFamily) {
                setFontName_1.default(editor, defaultFormat.fontFamily);
            }
            if (defaultFormat.fontSize) {
                setFontSize_1.default(editor, defaultFormat.fontSize);
            }
            if (defaultFormat.textColor) {
                if (defaultFormat.textColors) {
                    setTextColor_1.default(editor, defaultFormat.textColors);
                }
                else {
                    setTextColor_1.default(editor, defaultFormat.textColor);
                }
            }
            if (defaultFormat.backgroundColor) {
                if (defaultFormat.backgroundColors) {
                    setBackgroundColor_1.default(editor, defaultFormat.backgroundColors);
                }
                else {
                    setBackgroundColor_1.default(editor, defaultFormat.backgroundColor);
                }
            }
            if (defaultFormat.bold) {
                toggleBold_1.default(editor);
            }
            if (defaultFormat.italic) {
                toggleItalic_1.default(editor);
            }
            if (defaultFormat.underline) {
                toggleUnderline_1.default(editor);
            }
        }
    }, "Format" /* Format */);
}
exports.default = clearFormat;
//# sourceMappingURL=clearFormat.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/createLink.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/createLink.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
// Regex matching Uri scheme
var URI_REGEX = /^[a-zA-Z]+:/i;
// Regex matching begin of email address
var MAILTO_REGEX = /^[\w.%+-]+@/i;
// Regex matching begin of ftp, i.e. ftp.microsoft.com
var FTP_REGEX = /^ftp\./i;
var TEMP_TITLE = 'istemptitle';
function applyLinkPrefix(url) {
    if (!url) {
        return url;
    }
    // Add link prefix per rule:
    // (a) if the url always starts with a URI scheme, leave it as it is
    // (b) if the url is an email address, xxx@... add mailto: prefix
    // (c) if the url starts with ftp., add ftp:// prefix
    // (d) rest, add http:// prefix
    var prefix = '';
    if (url.search(URI_REGEX) < 0) {
        if (url.search(MAILTO_REGEX) == 0) {
            prefix = 'mailto:';
        }
        else if (url.search(FTP_REGEX) == 0) {
            prefix = 'ftp://';
        }
        else {
            // fallback to http://
            prefix = 'http://';
        }
    }
    return prefix + url;
}
/**
 * Insert a hyperlink at cursor.
 * When there is a selection, hyperlink will be applied to the selection,
 * otherwise a hyperlink will be inserted to the cursor position.
 * @param editor Editor object
 * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.
 * When protocol is not specified, a best matched protocol will be predicted.
 * @param altText Optional alt text of the link, will be shown when hover on the link
 * @param displayText Optional display text for the link.
 * If specified, the display text of link will be replaced with this text.
 * If not specified and there wasn't a link, the link url will be used as display text.
 */
function createLink(editor, link, altText, displayText) {
    editor.focus();
    var url = (checkXss(link) || '').trim();
    if (url) {
        var linkData = roosterjs_editor_dom_1.matchLink(url);
        // matchLink can match most links, but not all, i.e. if you pass link a link as "abc", it won't match
        // we know in that case, users will want to insert a link like http://abc
        // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link
        // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix
        // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix
        var normalizedUrl_1 = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);
        var originalUrl_1 = linkData ? linkData.originalUrl : url;
        editor.addUndoSnapshot(function () {
            var range = editor.getSelectionRange();
            var anchor = null;
            if (range && range.collapsed) {
                anchor = getAnchorNodeAtCursor(editor);
                // If there is already a link, just change its href
                if (anchor) {
                    anchor.href = normalizedUrl_1;
                    // Change text content if it is specified
                    updateAnchorDisplayText(anchor, displayText);
                }
                else {
                    anchor = editor.getDocument().createElement('A');
                    anchor.textContent = displayText || originalUrl_1;
                    anchor.href = normalizedUrl_1;
                    editor.insertNode(anchor);
                }
            }
            else {
                // the selection is not collapsed, use browser execCommand
                editor.getDocument().execCommand("createLink" /* CreateLink */, false, normalizedUrl_1);
                anchor = getAnchorNodeAtCursor(editor);
                updateAnchorDisplayText(anchor, displayText);
            }
            if (altText && anchor) {
                // Hack: Ideally this should be done by HyperLink plugin.
                // We make a hack here since we don't have an event to notify HyperLink plugin
                // before we apply the link.
                anchor.removeAttribute(TEMP_TITLE);
                anchor.title = altText;
            }
            return anchor;
        }, "CreateLink" /* CreateLink */);
    }
}
exports.default = createLink;
function getAnchorNodeAtCursor(editor) {
    return editor.queryElements('a[href]', 1 /* OnSelection */)[0];
}
function updateAnchorDisplayText(anchor, displayText) {
    if (displayText && anchor.textContent != displayText) {
        anchor.textContent = displayText;
    }
}
function checkXss(link) {
    var santizer = new roosterjs_editor_dom_1.HtmlSanitizer();
    var doc = new DOMParser().parseFromString('<a></a>', 'text/html');
    var a = doc.body.firstChild;
    a.href = link || '';
    santizer.sanitize(doc.body);
    // We use getAttribute because some browsers will try to make the href property a valid link.
    // This has unintended side effects when the link lacks a protocol.
    return a.getAttribute('href');
}
//# sourceMappingURL=createLink.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/getFormatState.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/getFormatState.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_editor_dom_2 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Get element based Format State at cursor
 * @param editor The editor instance
 * @param event (Optional) The plugin event, it stores the event cached data for looking up.
 * In this function the event cache is used to get list state and header level. If not passed,
 * it will query the node within selection to get the info
 * @returns An ElementBasedFormatState object
 */
function getElementBasedFormatState(editor, event) {
    var listTag = roosterjs_editor_dom_2.getTagOfNode(roosterjs_editor_core_1.cacheGetElementAtCursor(editor, event, 'OL,UL'));
    var headerTag = roosterjs_editor_dom_2.getTagOfNode(roosterjs_editor_core_1.cacheGetElementAtCursor(editor, event, 'H1,H2,H3,H4,H5,H6'));
    return {
        isBullet: listTag == 'UL',
        isNumbering: listTag == 'OL',
        headerLevel: (headerTag && parseInt(headerTag[1])) || 0,
        canUnlink: !!editor.queryElements('a[href]', 1 /* OnSelection */)[0],
        canAddImageAltText: !!editor.queryElements('img', 1 /* OnSelection */)[0],
        isBlockQuote: !!editor.queryElements('blockquote', 1 /* OnSelection */)[0],
    };
}
exports.getElementBasedFormatState = getElementBasedFormatState;
/**
 * @deprecated Use Editor.getStyleBasedFormatState() instead
 * Get style based Format State at cursor
 * @param editor The editor instance
 * @returns A StyleBasedFormatState object
 */
function getStyleBasedFormatState(editor) {
    return editor.getStyleBasedFormatState();
}
exports.getStyleBasedFormatState = getStyleBasedFormatState;
/**
 * Get format state at cursor
 * A format state is a collection of all format related states, e.g.,
 * bold, italic, underline, font name, font size, etc.
 * @param editor The editor instance
 * @param event (Optional) The plugin event, it stores the event cached data for looking up.
 * In this function the event cache is used to get list state and header level. If not passed,
 * it will query the node within selection to get the info
 * @returns The format state at cursor
 */
function getFormatState(editor, event) {
    return __assign(__assign(__assign(__assign({}, roosterjs_editor_dom_1.getPendableFormatState(editor.getDocument())), getElementBasedFormatState(editor, event)), editor.getStyleBasedFormatState()), { canUndo: editor.canUndo(), canRedo: editor.canRedo() });
}
exports.default = getFormatState;
//# sourceMappingURL=getFormatState.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/insertImage.js":
/*!*********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/insertImage.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function insertImage(editor, imageFile) {
    if (typeof imageFile == 'string') {
        insertImageWithSrc(editor, imageFile);
    }
    else {
        var reader = new FileReader();
        reader.onload = function (event) {
            if (!editor.isDisposed()) {
                insertImageWithSrc(editor, event.target.result);
            }
        };
        reader.readAsDataURL(imageFile);
    }
}
exports.default = insertImage;
function insertImageWithSrc(editor, src) {
    editor.addUndoSnapshot(function () {
        var image = editor.getDocument().createElement('img');
        image.src = src;
        image.style.maxWidth = '100%';
        editor.insertNode(image);
    }, "Format" /* Format */);
}
//# sourceMappingURL=insertImage.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/removeLink.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/removeLink.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Remove link at selection. If no links at selection, do nothing.
 * If selection contains multiple links, all of the link styles will be removed.
 * If only part of a link is selected, the whole link style will be removed.
 * @param editor The editor instance
 */
function removeLink(editor) {
    editor.focus();
    editor.addUndoSnapshot(function (start, end) {
        editor.queryElements('a[href]', 1 /* OnSelection */, roosterjs_editor_dom_1.unwrap);
        editor.select(start, end);
    }, "Format" /* Format */);
}
exports.default = removeLink;
//# sourceMappingURL=removeLink.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/replaceWithNode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/replaceWithNode.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function replaceWithNode(editor, textOrRange, node, exactMatch, searcher) {
    // Make sure the text and node is valid
    if (!textOrRange || !node) {
        return false;
    }
    var range;
    if (typeof textOrRange == 'string') {
        searcher = searcher || editor.getContentSearcherOfCursor();
        range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);
    }
    else {
        range = textOrRange;
    }
    if (range) {
        var backupRange = editor.getSelectionRange();
        // If the range to replace is right before current cursor, it is actually an exact match
        if (backupRange.collapsed &&
            range.endContainer == backupRange.startContainer &&
            range.endOffset == backupRange.startOffset) {
            exactMatch = true;
        }
        editor.insertNode(node, {
            position: 5 /* Range */,
            updateCursor: exactMatch,
            replaceSelection: true,
            insertOnNewLine: false,
            range: range,
        });
        return true;
    }
    return false;
}
exports.default = replaceWithNode;
//# sourceMappingURL=replaceWithNode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/rotateElement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/rotateElement.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Rotate an element visually
 * @param editor The editor instance
 * @param element The element that should be rotated
 * @param angle The degree at which to rotate the element from it's center
 */
function rotateElement(editor, element, angle) {
    if (element) {
        editor.addUndoSnapshot(function () {
            element.style.transform = "rotate(" + angle + "deg)";
        }, "Format" /* Format */);
    }
}
exports.default = rotateElement;
//# sourceMappingURL=rotateElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/setAlignment.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/setAlignment.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var execCommand_1 = __webpack_require__(/*! ../utils/execCommand */ "./node_modules/roosterjs-editor-api/lib/utils/execCommand.js");
/**
 * Set content alignment
 * @param editor The editor instance
 * @param alignment The alignment option:
 * Alignment.Center, Alignment.Left, Alignment.Right
 */
function setAlignment(editor, alignment) {
    var command = "justifyLeft" /* JustifyLeft */;
    var align = 'left';
    if (alignment == 1 /* Center */) {
        command = "justifyCenter" /* JustifyCenter */;
        align = 'center';
    }
    else if (alignment == 2 /* Right */) {
        command = "justifyRight" /* JustifyRight */;
        align = 'right';
    }
    editor.addUndoSnapshot(function () {
        execCommand_1.default(editor, command);
        editor.queryElements('[align]', 1 /* OnSelection */, function (node) { return (node.style.textAlign = align); });
    }, "Format" /* Format */);
}
exports.default = setAlignment;
//# sourceMappingURL=setAlignment.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/setBackgroundColor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/setBackgroundColor.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var applyInlineStyle_1 = __webpack_require__(/*! ../utils/applyInlineStyle */ "./node_modules/roosterjs-editor-api/lib/utils/applyInlineStyle.js");
/**
 * Set background color at current selection
 * @param editor The editor instance
 * @param color One of two options:
 * The color string, can be any of the predefined color names (e.g, 'red')
 * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
 * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
 * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.
 * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.
 **/
function setBackgroundColor(editor, color) {
    if (typeof color === 'string') {
        var trimmedColor_1 = color.trim();
        applyInlineStyle_1.default(editor, function (element, isInnerNode) {
            element.style.backgroundColor = isInnerNode ? '' : trimmedColor_1;
        });
    }
    else {
        var darkMode_1 = editor.isDarkMode();
        var appliedColor_1 = darkMode_1 ? color.darkModeColor : color.lightModeColor;
        applyInlineStyle_1.default(editor, function (element, isInnerNode) {
            element.style.backgroundColor = isInnerNode ? '' : appliedColor_1;
            if (darkMode_1) {
                element.dataset.ogsb = color.lightModeColor;
            }
        });
    }
}
exports.default = setBackgroundColor;
//# sourceMappingURL=setBackgroundColor.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/setDirection.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/setDirection.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var collapseSelectedBlocks_1 = __webpack_require__(/*! ../utils/collapseSelectedBlocks */ "./node_modules/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.js");
/**
 * Change direction for the blocks/paragraph at selection
 * @param editor The editor instance
 * @param direction The direction option:
 * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'
 */
function setDirection(editor, direction) {
    editor.focus();
    editor.addUndoSnapshot(function (start, end) {
        collapseSelectedBlocks_1.default(editor, function (element) {
            element.setAttribute('dir', direction == 0 /* LeftToRight */ ? 'ltr' : 'rtl');
            element.style.textAlign = direction == 0 /* LeftToRight */ ? 'left' : 'right';
        });
        editor.select(start, end);
    }, "Format" /* Format */);
}
exports.default = setDirection;
//# sourceMappingURL=setDirection.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/setFontName.js":
/*!*********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/setFontName.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var applyInlineStyle_1 = __webpack_require__(/*! ../utils/applyInlineStyle */ "./node_modules/roosterjs-editor-api/lib/utils/applyInlineStyle.js");
/**
 * Set font name at selection
 * @param editor The editor instance
 * @param fontName The fontName string, should be a valid CSS font-family style.
 * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
 */
function setFontName(editor, fontName) {
    fontName = fontName.trim();
    // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard
    // (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style
    // for here, we use CSS font-family style
    applyInlineStyle_1.default(editor, function (element, isInnerNode) {
        element.style.fontFamily = isInnerNode ? '' : fontName;
    });
}
exports.default = setFontName;
//# sourceMappingURL=setFontName.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/setFontSize.js":
/*!*********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/setFontSize.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var applyInlineStyle_1 = __webpack_require__(/*! ../utils/applyInlineStyle */ "./node_modules/roosterjs-editor-api/lib/utils/applyInlineStyle.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Set font size at selection
 * @param editor The editor instance
 * @param fontSize The fontSize string, should be a valid CSS font-size style.
 * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
 */
function setFontSize(editor, fontSize) {
    fontSize = fontSize.trim();
    // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.
    // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style
    // for here, we use CSS font-size style
    applyInlineStyle_1.default(editor, function (element, isInnerNode) {
        element.style.fontSize = isInnerNode ? '' : fontSize;
        var lineHeight = roosterjs_editor_dom_1.getComputedStyle(element, 'line-height');
        if (lineHeight != 'normal') {
            element.style.lineHeight = 'normal';
        }
    });
}
exports.default = setFontSize;
//# sourceMappingURL=setFontSize.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/setImageAltText.js":
/*!*************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/setImageAltText.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Set image alt text for all selected images at selection. If no images is contained
 * in selection, do nothing.
 * The alt attribute provides alternative information for an image if a user for some reason
 * cannot view it (because of slow connection, an error in the src attribute, or if the user
 * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp
 * @param editor The editor instance
 * @param altText The image alt text
 */
function setImageAltText(editor, altText) {
    editor.focus();
    editor.addUndoSnapshot(function () {
        editor.queryElements('img', 1 /* OnSelection */, function (node) {
            return node.setAttribute('alt', altText);
        });
    }, "Format" /* Format */);
}
exports.default = setImageAltText;
//# sourceMappingURL=setImageAltText.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/setIndentation.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/setIndentation.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var experimentSetIndentation_1 = __webpack_require__(/*! ../experiment/experimentSetIndentation */ "./node_modules/roosterjs-editor-api/lib/experiment/experimentSetIndentation.js");
var processList_1 = __webpack_require__(/*! ../utils/processList */ "./node_modules/roosterjs-editor-api/lib/utils/processList.js");
/**
 * Set indentation at selection
 * If selection contains bullet/numbering list, increase/decrease indentation will
 * increase/decrease the list level by one.
 * @param editor The editor instance
 * @param indentation The indentation option:
 * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation
 */
function setIndentation(editor, indentation) {
    if (editor.useExperimentFeatures()) {
        experimentSetIndentation_1.default(editor, indentation);
    }
    else {
        var command_1 = indentation == 0 /* Increase */ ? "indent" /* Indent */ : "outdent" /* Outdent */;
        editor.addUndoSnapshot(function () {
            editor.focus();
            var listNode = editor.getElementAtCursor('OL,UL');
            var newNode;
            if (listNode) {
                // There is already list node, setIndentation() will increase/decrease the list level,
                // so we need to process the list when change indentation
                newNode = processList_1.default(editor, command_1);
            }
            else {
                // No existing list node, browser will create <Blockquote> node for indentation.
                // We need to set top and bottom margin to 0 to avoid unnecessary spaces
                editor.getDocument().execCommand(command_1, false, null);
                editor.queryElements('BLOCKQUOTE', 1 /* OnSelection */, function (node) {
                    newNode = newNode || node;
                    node.style.marginTop = '0px';
                    node.style.marginBottom = '0px';
                });
            }
            return newNode;
        }, "Format" /* Format */);
    }
}
exports.default = setIndentation;
//# sourceMappingURL=setIndentation.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/setTextColor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/setTextColor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var applyInlineStyle_1 = __webpack_require__(/*! ../utils/applyInlineStyle */ "./node_modules/roosterjs-editor-api/lib/utils/applyInlineStyle.js");
/**
 * Set text color at selection
 * @param editor The editor instance
 * @param color One of two options:
 * The color string, can be any of the predefined color names (e.g, 'red')
 * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
 * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
 * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.
 * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.
 */
function setTextColor(editor, color) {
    if (typeof color === 'string') {
        var trimmedColor_1 = color.trim();
        applyInlineStyle_1.default(editor, function (element, isInnerNode) {
            element.style.color = isInnerNode ? '' : trimmedColor_1;
        });
    }
    else {
        var darkMode_1 = editor.isDarkMode();
        var appliedColor_1 = darkMode_1 ? color.darkModeColor : color.lightModeColor;
        applyInlineStyle_1.default(editor, function (element, isInnerNode) {
            element.style.color = isInnerNode ? '' : appliedColor_1;
            if (darkMode_1) {
                element.dataset.ogsc = color.lightModeColor;
            }
        });
    }
}
exports.default = setTextColor;
//# sourceMappingURL=setTextColor.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/toggleBlockQuote.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/toggleBlockQuote.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var toggleTagCore_1 = __webpack_require__(/*! ../utils/toggleTagCore */ "./node_modules/roosterjs-editor-api/lib/utils/toggleTagCore.js");
var BLOCKQUOTE_TAG = 'blockquote';
var DEFAULT_STYLER = function (element) {
    element.style.borderLeft = '3px solid';
    element.style.borderColor = '#C8C8C8';
    element.style.paddingLeft = '10px';
    element.style.color = '#666666';
};
/**
 * Toggle blockquote at selection, if selection already contains any blockquoted elements,
 * the blockquoted elements will be unblockquoted and other elements will take no affect
 * @param editor The editor instance
 * @param styler (Optional) The custom styler for setting the style for the blockquote element
 */
function toggleBlockQuote(editor, styler) {
    toggleTagCore_1.default(editor, BLOCKQUOTE_TAG, styler || DEFAULT_STYLER);
}
exports.default = toggleBlockQuote;
//# sourceMappingURL=toggleBlockQuote.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/toggleBold.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/toggleBold.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var execCommand_1 = __webpack_require__(/*! ../utils/execCommand */ "./node_modules/roosterjs-editor-api/lib/utils/execCommand.js");
/**
 * Toggle bold at selection
 * If selection is collapsed, it will only affect the following input after caret
 * If selection contains only bold text, the bold style will be removed
 * If selection contains only normal text, bold style will be added to the whole selected text
 * If selection contains both bold and normal text, bold stle will be added to the whole selected text
 * @param editor The editor instance
 */
function toggleBold(editor) {
    execCommand_1.default(editor, "bold" /* Bold */);
}
exports.default = toggleBold;
//# sourceMappingURL=toggleBold.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/toggleBullet.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/toggleBullet.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var experimentToggleListType_1 = __webpack_require__(/*! ../experiment/experimentToggleListType */ "./node_modules/roosterjs-editor-api/lib/experiment/experimentToggleListType.js");
var processList_1 = __webpack_require__(/*! ../utils/processList */ "./node_modules/roosterjs-editor-api/lib/utils/processList.js");
/**
 * Toggle bullet at selection
 * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one
 * If selection contains number list, toggle bullet will convert the number list into bullet list
 * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
 * browser execCommand API
 * @param editor The editor instance
 */
function toggleBullet(editor) {
    if (editor.useExperimentFeatures()) {
        experimentToggleListType_1.default(editor, 2 /* Unordered */);
    }
    else {
        editor.focus();
        editor.addUndoSnapshot(function () { return processList_1.default(editor, "insertUnorderedList" /* InsertUnorderedList */); }, "Format" /* Format */);
    }
}
exports.default = toggleBullet;
//# sourceMappingURL=toggleBullet.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/toggleCodeBlock.js":
/*!*************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/toggleCodeBlock.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var toggleTagCore_1 = __webpack_require__(/*! ../utils/toggleTagCore */ "./node_modules/roosterjs-editor-api/lib/utils/toggleTagCore.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var PRE_TAG = 'pre';
var CODE_TAG = 'code';
var CODE_NODE_TAG = 'CODE';
/**
 * Toggle code block at selection, if selection already contains any code blocked elements,
 * the code block elements will be no longer be code blocked and other elements will take no affect
 * @param editor The editor instance
 * @param styler (Optional) The custom styler for setting the style for the code block element
 */
function toggleCodeBlock(editor, styler) {
    toggleTagCore_1.default(editor, PRE_TAG, styler, wrapFunction, unwrapFunction);
}
exports.default = toggleCodeBlock;
function wrapFunction(nodes) {
    var codeBlock = roosterjs_editor_dom_1.wrap(nodes, CODE_TAG);
    return roosterjs_editor_dom_1.wrap(codeBlock, PRE_TAG);
}
function unwrapFunction(node) {
    if (!node) {
        return null;
    }
    var firstChild = node.childNodes[0];
    if (node.childNodes.length == 1 && roosterjs_editor_dom_1.getTagOfNode(firstChild) == CODE_NODE_TAG) {
        roosterjs_editor_dom_1.unwrap(firstChild);
    }
    return roosterjs_editor_dom_1.unwrap(node);
}
//# sourceMappingURL=toggleCodeBlock.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/toggleHeader.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/toggleHeader.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Toggle header at selection
 * @param editor The editor instance
 * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to
 * the HTML header element &lt;H1&gt; to &lt;H6&gt;, 0 means no header
 * if passed in param is outside the range, will be rounded to nearest number in the range
 */
function toggleHeader(editor, level) {
    level = Math.min(Math.max(Math.round(level), 0), 6);
    editor.addUndoSnapshot(function () {
        editor.focus();
        var wrapped = false;
        editor.queryElements('H1,H2,H3,H4,H5,H6', 1 /* OnSelection */, function (header) {
            if (!wrapped) {
                editor.getDocument().execCommand("formatBlock" /* FormatBlock */, false, '<DIV>');
                wrapped = true;
            }
            var div = editor.getDocument().createElement('div');
            while (header.firstChild) {
                div.appendChild(header.firstChild);
            }
            editor.replaceNode(header, div);
        });
        if (level > 0) {
            var traverser = editor.getSelectionTraverser();
            var blockElement = traverser ? traverser.currentBlockElement : null;
            var sanitizer = new roosterjs_editor_dom_1.HtmlSanitizer({
                styleCallbacks: {
                    'font-size': function () { return false; },
                },
            });
            while (blockElement) {
                var element = blockElement.collapseToSingleElement();
                sanitizer.sanitize(element);
                blockElement = traverser.getNextBlockElement();
            }
            editor.getDocument().execCommand("formatBlock" /* FormatBlock */, false, "<H" + level + ">");
        }
    }, "Format" /* Format */);
}
exports.default = toggleHeader;
//# sourceMappingURL=toggleHeader.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/toggleItalic.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/toggleItalic.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var execCommand_1 = __webpack_require__(/*! ../utils/execCommand */ "./node_modules/roosterjs-editor-api/lib/utils/execCommand.js");
/**
 * Toggle italic at selection
 * If selection is collapsed, it will only affect the input after caret
 * If selection contains only italic text, the italic style will be removed
 * If selection contains only normal text, italic style will be added to the whole selected text
 * If selection contains both italic and normal text, italic stlye will be added to the whole selected text
 * @param editor The editor instance
 */
function toggleItalic(editor) {
    execCommand_1.default(editor, "italic" /* Italic */);
}
exports.default = toggleItalic;
//# sourceMappingURL=toggleItalic.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/toggleNumbering.js":
/*!*************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/toggleNumbering.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var experimentToggleListType_1 = __webpack_require__(/*! ../experiment/experimentToggleListType */ "./node_modules/roosterjs-editor-api/lib/experiment/experimentToggleListType.js");
var processList_1 = __webpack_require__(/*! ../utils/processList */ "./node_modules/roosterjs-editor-api/lib/utils/processList.js");
/**
 * Toggle numbering at selection
 * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one
 * If selection contains bullet list, toggle numbering will convert the bullet list into number list
 * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
 * realization of browser execCommand API
 * @param editor The editor instance
 */
function toggleNumbering(editor) {
    if (editor.useExperimentFeatures()) {
        experimentToggleListType_1.default(editor, 1 /* Ordered */);
    }
    else {
        editor.focus();
        editor.addUndoSnapshot(function () { return processList_1.default(editor, "insertOrderedList" /* InsertOrderedList */); }, "Format" /* Format */);
    }
}
exports.default = toggleNumbering;
//# sourceMappingURL=toggleNumbering.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/toggleStrikethrough.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/toggleStrikethrough.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var execCommand_1 = __webpack_require__(/*! ../utils/execCommand */ "./node_modules/roosterjs-editor-api/lib/utils/execCommand.js");
/**
 * Toggle strikethrough at selection
 * If selection is collapsed, it will only affect the input after caret
 * If selection contains only strikethrough text, the strikethrough style will be removed
 * If selection contains only normal text, strikethrough style will be added to the whole selected text
 * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text
 * @param editor The editor instance
 */
function toggleStrikethrough(editor) {
    execCommand_1.default(editor, "strikeThrough" /* StrikeThrough */);
}
exports.default = toggleStrikethrough;
//# sourceMappingURL=toggleStrikethrough.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/toggleSubscript.js":
/*!*************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/toggleSubscript.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var execCommand_1 = __webpack_require__(/*! ../utils/execCommand */ "./node_modules/roosterjs-editor-api/lib/utils/execCommand.js");
/**
 * Toggle subscript at selection
 * If selection is collapsed, it will only affect the input after caret
 * If selection contains only subscript text, the subscript style will be removed
 * If selection contains only normal text, subscript style will be added to the whole selected text
 * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text
 * If selection contains any superscript text, the behavior is determined by corresponding realization of browser
 * execCommand API
 * @param editor The editor instance
 */
function toggleSubscript(editor) {
    execCommand_1.default(editor, "subscript" /* Subscript */);
}
exports.default = toggleSubscript;
//# sourceMappingURL=toggleSubscript.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/toggleSuperscript.js":
/*!***************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/toggleSuperscript.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var execCommand_1 = __webpack_require__(/*! ../utils/execCommand */ "./node_modules/roosterjs-editor-api/lib/utils/execCommand.js");
/**
 * Toggle superscript at selection
 * If selection is collapsed, it will only affect the input after caret
 * If selection contains only superscript text, the superscript style will be removed
 * If selection contains only normal text, superscript style will be added to the whole selected text
 * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text
 * If selection contains any subscript text, the behavior is determined by corresponding realization of browser
 * execCommand API
 * @param editor The editor instance
 */
function toggleSuperscript(editor) {
    execCommand_1.default(editor, "superscript" /* Superscript */);
}
exports.default = toggleSuperscript;
//# sourceMappingURL=toggleSuperscript.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/format/toggleUnderline.js":
/*!*************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/format/toggleUnderline.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var execCommand_1 = __webpack_require__(/*! ../utils/execCommand */ "./node_modules/roosterjs-editor-api/lib/utils/execCommand.js");
/**
 * Toggle underline at selection
 * If selection is collapsed, it will only affect the input after caret
 * If selection contains only underlined text, the underline style will be removed
 * If selection contains only normal text, underline style will be added to the whole selected text
 * If selection contains both underlined and normal text, the underline style will be added to the whole selected text
 * @param editor The editor instance
 */
function toggleUnderline(editor) {
    execCommand_1.default(editor, "underline" /* Underline */);
}
exports.default = toggleUnderline;
//# sourceMappingURL=toggleUnderline.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var changeFontSize_1 = __webpack_require__(/*! ./format/changeFontSize */ "./node_modules/roosterjs-editor-api/lib/format/changeFontSize.js");
exports.changeFontSize = changeFontSize_1.default;
exports.FONT_SIZES = changeFontSize_1.FONT_SIZES;
var clearBlockFormat_1 = __webpack_require__(/*! ./format/clearBlockFormat */ "./node_modules/roosterjs-editor-api/lib/format/clearBlockFormat.js");
exports.clearBlockFormat = clearBlockFormat_1.default;
exports.TAGS_TO_UNWRAP = clearBlockFormat_1.TAGS_TO_UNWRAP;
exports.TAGS_TO_STOP_UNWRAP = clearBlockFormat_1.TAGS_TO_STOP_UNWRAP;
exports.ATTRIBUTES_TO_PRESERVE = clearBlockFormat_1.ATTRIBUTES_TO_PRESERVE;
var clearFormat_1 = __webpack_require__(/*! ./format/clearFormat */ "./node_modules/roosterjs-editor-api/lib/format/clearFormat.js");
exports.clearFormat = clearFormat_1.default;
var createLink_1 = __webpack_require__(/*! ./format/createLink */ "./node_modules/roosterjs-editor-api/lib/format/createLink.js");
exports.createLink = createLink_1.default;
var getFormatState_1 = __webpack_require__(/*! ./format/getFormatState */ "./node_modules/roosterjs-editor-api/lib/format/getFormatState.js");
exports.getFormatState = getFormatState_1.default;
exports.getElementBasedFormatState = getFormatState_1.getElementBasedFormatState;
exports.getStyleBasedFormatState = getFormatState_1.getStyleBasedFormatState;
var insertImage_1 = __webpack_require__(/*! ./format/insertImage */ "./node_modules/roosterjs-editor-api/lib/format/insertImage.js");
exports.insertImage = insertImage_1.default;
var insertTable_1 = __webpack_require__(/*! ./table/insertTable */ "./node_modules/roosterjs-editor-api/lib/table/insertTable.js");
exports.insertTable = insertTable_1.default;
var editTable_1 = __webpack_require__(/*! ./table/editTable */ "./node_modules/roosterjs-editor-api/lib/table/editTable.js");
exports.editTable = editTable_1.default;
var formatTable_1 = __webpack_require__(/*! ./table/formatTable */ "./node_modules/roosterjs-editor-api/lib/table/formatTable.js");
exports.formatTable = formatTable_1.default;
var removeLink_1 = __webpack_require__(/*! ./format/removeLink */ "./node_modules/roosterjs-editor-api/lib/format/removeLink.js");
exports.removeLink = removeLink_1.default;
var replaceWithNode_1 = __webpack_require__(/*! ./format/replaceWithNode */ "./node_modules/roosterjs-editor-api/lib/format/replaceWithNode.js");
exports.replaceWithNode = replaceWithNode_1.default;
var rotateElement_1 = __webpack_require__(/*! ./format/rotateElement */ "./node_modules/roosterjs-editor-api/lib/format/rotateElement.js");
exports.rotateElement = rotateElement_1.default;
var setAlignment_1 = __webpack_require__(/*! ./format/setAlignment */ "./node_modules/roosterjs-editor-api/lib/format/setAlignment.js");
exports.setAlignment = setAlignment_1.default;
var setBackgroundColor_1 = __webpack_require__(/*! ./format/setBackgroundColor */ "./node_modules/roosterjs-editor-api/lib/format/setBackgroundColor.js");
exports.setBackgroundColor = setBackgroundColor_1.default;
var setTextColor_1 = __webpack_require__(/*! ./format/setTextColor */ "./node_modules/roosterjs-editor-api/lib/format/setTextColor.js");
exports.setTextColor = setTextColor_1.default;
var setDirection_1 = __webpack_require__(/*! ./format/setDirection */ "./node_modules/roosterjs-editor-api/lib/format/setDirection.js");
exports.setDirection = setDirection_1.default;
var setFontName_1 = __webpack_require__(/*! ./format/setFontName */ "./node_modules/roosterjs-editor-api/lib/format/setFontName.js");
exports.setFontName = setFontName_1.default;
var setFontSize_1 = __webpack_require__(/*! ./format/setFontSize */ "./node_modules/roosterjs-editor-api/lib/format/setFontSize.js");
exports.setFontSize = setFontSize_1.default;
var setImageAltText_1 = __webpack_require__(/*! ./format/setImageAltText */ "./node_modules/roosterjs-editor-api/lib/format/setImageAltText.js");
exports.setImageAltText = setImageAltText_1.default;
var setIndentation_1 = __webpack_require__(/*! ./format/setIndentation */ "./node_modules/roosterjs-editor-api/lib/format/setIndentation.js");
exports.setIndentation = setIndentation_1.default;
var toggleBold_1 = __webpack_require__(/*! ./format/toggleBold */ "./node_modules/roosterjs-editor-api/lib/format/toggleBold.js");
exports.toggleBold = toggleBold_1.default;
var toggleBullet_1 = __webpack_require__(/*! ./format/toggleBullet */ "./node_modules/roosterjs-editor-api/lib/format/toggleBullet.js");
exports.toggleBullet = toggleBullet_1.default;
var toggleItalic_1 = __webpack_require__(/*! ./format/toggleItalic */ "./node_modules/roosterjs-editor-api/lib/format/toggleItalic.js");
exports.toggleItalic = toggleItalic_1.default;
var toggleNumbering_1 = __webpack_require__(/*! ./format/toggleNumbering */ "./node_modules/roosterjs-editor-api/lib/format/toggleNumbering.js");
exports.toggleNumbering = toggleNumbering_1.default;
var toggleBlockQuote_1 = __webpack_require__(/*! ./format/toggleBlockQuote */ "./node_modules/roosterjs-editor-api/lib/format/toggleBlockQuote.js");
exports.toggleBlockQuote = toggleBlockQuote_1.default;
var toggleCodeBlock_1 = __webpack_require__(/*! ./format/toggleCodeBlock */ "./node_modules/roosterjs-editor-api/lib/format/toggleCodeBlock.js");
exports.toggleCodeBlock = toggleCodeBlock_1.default;
var toggleStrikethrough_1 = __webpack_require__(/*! ./format/toggleStrikethrough */ "./node_modules/roosterjs-editor-api/lib/format/toggleStrikethrough.js");
exports.toggleStrikethrough = toggleStrikethrough_1.default;
var toggleSubscript_1 = __webpack_require__(/*! ./format/toggleSubscript */ "./node_modules/roosterjs-editor-api/lib/format/toggleSubscript.js");
exports.toggleSubscript = toggleSubscript_1.default;
var toggleSuperscript_1 = __webpack_require__(/*! ./format/toggleSuperscript */ "./node_modules/roosterjs-editor-api/lib/format/toggleSuperscript.js");
exports.toggleSuperscript = toggleSuperscript_1.default;
var toggleUnderline_1 = __webpack_require__(/*! ./format/toggleUnderline */ "./node_modules/roosterjs-editor-api/lib/format/toggleUnderline.js");
exports.toggleUnderline = toggleUnderline_1.default;
var toggleHeader_1 = __webpack_require__(/*! ./format/toggleHeader */ "./node_modules/roosterjs-editor-api/lib/format/toggleHeader.js");
exports.toggleHeader = toggleHeader_1.default;
// @deprecated the function getPendableFormatState will still be available from
// roosterjs-editor-dom package, keep export it here just for compatibility
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
exports.getPendableFormatState = roosterjs_editor_dom_1.getPendableFormatState;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/table/editTable.js":
/*!******************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/table/editTable.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Edit table with given operation. If there is no table at cursor then no op.
 * @param editor The editor instance
 * @param operation Table operation
 */
function editTable(editor, operation) {
    var td = editor.getElementAtCursor('TD,TH');
    if (td) {
        editor.addUndoSnapshot(function (start, end) {
            var vtable = new roosterjs_editor_dom_1.VTable(td);
            vtable.edit(operation);
            vtable.writeBack();
            editor.focus();
            var cellToSelect = calculateCellToSelect(operation, vtable.row, vtable.col);
            editor.select(vtable.getCell(cellToSelect.newRow, cellToSelect.newCol).td, 0 /* Begin */);
        }, "Format" /* Format */);
    }
}
exports.default = editTable;
function calculateCellToSelect(operation, currentRow, currentCol) {
    var newRow = currentRow;
    var newCol = currentCol;
    switch (operation) {
        case 0 /* InsertAbove */:
            newCol = 0;
            break;
        case 1 /* InsertBelow */:
            newRow += 1;
            newCol = 0;
            break;
        case 2 /* InsertLeft */:
            newRow = 0;
            break;
        case 3 /* InsertRight */:
            newRow = 0;
            newCol += 1;
            break;
    }
    return {
        newRow: newRow,
        newCol: newCol,
    };
}
//# sourceMappingURL=editTable.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/table/formatTable.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/table/formatTable.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Format table
 * @param editor The editor which contains the table to format
 * @param format A TableFormat object contains format information we want to apply to the table
 * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted
 */
function formatTable(editor, format, table) {
    table = table || editor.getElementAtCursor('TABLE');
    if (table) {
        editor.addUndoSnapshot(function (start, end) {
            var vtable = new roosterjs_editor_dom_1.VTable(table);
            vtable.applyFormat(format);
            vtable.writeBack();
            editor.focus();
            editor.select(start, end);
        }, "Format" /* Format */);
    }
}
exports.default = formatTable;
//# sourceMappingURL=formatTable.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/table/insertTable.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/table/insertTable.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Insert table into editor at current selection
 * @param editor The editor instance
 * @param columns Number of columns in table, it also controls the default table cell width:
 * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px
 * @param rows Number of rows in table
 * @param format (Optional) The table format. If not passed, the default format will be applied:
 * background color: #FFF; border color: #ABABAB
 */
function insertTable(editor, columns, rows, format) {
    var document = editor.getDocument();
    var fragment = document.createDocumentFragment();
    var table = document.createElement('table');
    fragment.appendChild(table);
    table.cellSpacing = '0';
    table.cellPadding = '1';
    for (var i = 0; i < rows; i++) {
        var tr = document.createElement('tr');
        table.appendChild(tr);
        for (var j = 0; j < columns; j++) {
            var td = document.createElement('td');
            tr.appendChild(td);
            td.appendChild(document.createElement('br'));
            td.style.width = getTableCellWidth(columns);
        }
    }
    editor.focus();
    editor.addUndoSnapshot(function () {
        var vtable = new roosterjs_editor_dom_1.VTable(table);
        vtable.applyFormat(format || {
            bgColorEven: '#FFF',
            bgColorOdd: '#FFF',
            topBorderColor: '#ABABAB',
            bottomBorderColor: '#ABABAB',
            verticalBorderColor: '#ABABAB',
        });
        vtable.writeBack();
        editor.insertNode(fragment);
        editor.runAsync(function () { return editor.select(new roosterjs_editor_dom_1.Position(table, 0 /* Begin */).normalize()); });
    }, "Format" /* Format */);
}
exports.default = insertTable;
function getTableCellWidth(columns) {
    if (columns <= 4) {
        return '120px';
    }
    else if (columns <= 6) {
        return '100px';
    }
    else {
        return '70px';
    }
}
//# sourceMappingURL=insertTable.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/utils/applyInlineStyle.js":
/*!*************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/utils/applyInlineStyle.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var ZERO_WIDTH_SPACE = '\u200B';
/**
 * Apply inline style to current selection
 * @param editor The editor instance
 * @param callback The callback function to apply style
 */
function applyInlineStyle(editor, callback) {
    editor.focus();
    var range = editor.getSelectionRange();
    if (range && range.collapsed) {
        var node = range.startContainer;
        var isEmptySpan = roosterjs_editor_dom_1.getTagOfNode(node) == 'SPAN' &&
            (!node.firstChild ||
                (roosterjs_editor_dom_1.getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));
        if (isEmptySpan) {
            editor.addUndoSnapshot();
            callback(node);
        }
        else {
            var isZWSNode = node &&
                node.nodeType == 3 /* Text */ &&
                node.nodeValue == ZERO_WIDTH_SPACE &&
                roosterjs_editor_dom_1.getTagOfNode(node.parentNode) == 'SPAN';
            if (!isZWSNode) {
                editor.addUndoSnapshot();
                // Create a new text node to hold the selection.
                // Some content is needed to position selection into the span
                // for here, we inject ZWS - zero width space
                node = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);
                range.insertNode(node);
            }
            roosterjs_editor_dom_1.applyTextStyle(node, callback);
            editor.select(node, -1 /* End */);
        }
    }
    else {
        // This is start and end node that get the style. The start and end needs to be recorded so that selection
        // can be re-applied post-applying style
        editor.addUndoSnapshot(function () {
            var firstNode;
            var lastNode;
            var contentTraverser = editor.getSelectionTraverser();
            var inlineElement = contentTraverser && contentTraverser.currentInlineElement;
            while (inlineElement) {
                var nextInlineElement = contentTraverser.getNextInlineElement();
                inlineElement.applyStyle(function (element, isInnerNode) {
                    callback(element, isInnerNode);
                    firstNode = firstNode || element;
                    lastNode = element;
                });
                inlineElement = nextInlineElement;
            }
            if (firstNode && lastNode) {
                editor.select(firstNode, -2 /* Before */, lastNode, -3 /* After */);
            }
        }, "Format" /* Format */);
    }
}
exports.default = applyInlineStyle;
//# sourceMappingURL=applyInlineStyle.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/utils/blockFormat.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/utils/blockFormat.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internal
 * Split selection into regions, and perform a block-wise formatting action for each region.
 */
function blockFormat(editor, callback) {
    editor.focus();
    editor.addUndoSnapshot(function (start, end) {
        var regions = editor.getSelectedRegions();
        regions.forEach(function (region) { return callback(region, start, end); });
        editor.select(start, end);
    }, "Format" /* Format */);
}
exports.default = blockFormat;
//# sourceMappingURL=blockFormat.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Collapse all selected blocks, return single HTML elements for each block
 * @param editor The editor instance
 * @param forEachCallback A callback function to invoke for each of the collapsed element
 */
function collapseSelectedBlocked(editor, forEachCallback) {
    var traverser = editor.getSelectionTraverser();
    var block = traverser && traverser.currentBlockElement;
    var blocks = [];
    while (block) {
        if (!isEmptyBlockUnderTR(block)) {
            blocks.push(block);
        }
        block = traverser.getNextBlockElement();
    }
    blocks.forEach(function (block) {
        var element = block.collapseToSingleElement();
        forEachCallback(element);
    });
}
exports.default = collapseSelectedBlocked;
function isEmptyBlockUnderTR(block) {
    var startNode = block.getStartNode();
    return (block instanceof roosterjs_editor_dom_1.StartEndBlockElement &&
        startNode == block.getEndNode() &&
        startNode.nodeType == 3 /* Text */ &&
        ['TR', 'TABLE'].indexOf(roosterjs_editor_dom_1.getTagOfNode(startNode.parentNode)) >= 0);
}
//# sourceMappingURL=collapseSelectedBlocks.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/utils/execCommand.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/utils/execCommand.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var pendableFormatCommands = null;
/**
 * Execute a document command
 * @param editor The editor instance
 * @param command The command to execute
 * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.
 * Default value is false.
 * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.
 * Default value is false.
 */
function execCommand(editor, command) {
    editor.focus();
    var formatter = function () { return editor.getDocument().execCommand(command, false, null); };
    var range = editor.getSelectionRange();
    if (range && range.collapsed) {
        editor.addUndoSnapshot();
        formatter();
        if (isPendableFormatCommand(command)) {
            // Trigger PendingFormatStateChanged event since we changed pending format state
            editor.triggerPluginEvent(13 /* PendingFormatStateChanged */, {
                formatState: roosterjs_editor_dom_1.getPendableFormatState(editor.getDocument()),
            });
        }
    }
    else {
        editor.addUndoSnapshot(formatter, "Format" /* Format */);
    }
}
exports.default = execCommand;
function isPendableFormatCommand(command) {
    if (!pendableFormatCommands) {
        pendableFormatCommands = Object.keys(roosterjs_editor_dom_1.PendableFormatCommandMap).map(function (key) { return roosterjs_editor_dom_1.PendableFormatCommandMap[key]; });
    }
    return pendableFormatCommands.indexOf(command) >= 0;
}
//# sourceMappingURL=execCommand.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/utils/processList.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/utils/processList.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Browsers don't handle bullet/numbering list well, especially the formats when switching list statue
 * So we workaround it by always adding format to list element
 */
function processList(editor, command) {
    var existingList = editor.getElementAtCursor('OL,UL');
    if (roosterjs_editor_dom_1.Browser.isChrome && command !== "indent" /* Indent */) {
        // Chrome has a bug where certain information about elements are deleted when outdent or enter on empty line occurs.
        // We need to clone our current LI node so we can replace the new LI node with it post outdent / enter.
        var parentLINode = editor.getElementAtCursor('LI');
        // We must first be in an LI node to do something to fix this.
        if (parentLINode) {
            // We also don't want to try to handle the multi select outdent case at this time.
            // These are already pretty stable in Chromium.
            var currentRange = editor.getSelectionRange();
            var currentSelectionPath = roosterjs_editor_dom_1.getSelectionPath(parentLINode, currentRange);
            if (currentRange &&
                (currentRange.collapsed ||
                    (editor.getElementAtCursor('LI', currentRange.startContainer) == parentLINode &&
                        editor.getElementAtCursor('LI', currentRange.endContainer) == parentLINode))) {
                // Handle the case for toggling between the two list types as a special case.
                // We'll let the browser handle this for now.
                if ((existingList.tagName === 'OL' &&
                    command === "insertUnorderedList" /* InsertUnorderedList */) ||
                    (existingList.tagName === 'UL' && command === "insertOrderedList" /* InsertOrderedList */)) {
                    editor.getDocument().execCommand(command, false, null);
                }
                else {
                    // Get the next highest list element.
                    // In well formed HTML, this should just be the existing list's parent container.
                    var listParent = existingList.parentElement;
                    if (listParent.tagName == 'OL' || listParent.tagName == 'UL') {
                        if (parentLINode.nextElementSibling) {
                            roosterjs_editor_dom_1.splitBalancedNodeRange(parentLINode);
                        }
                        existingList.insertAdjacentElement('afterend', parentLINode);
                        editor.select(roosterjs_editor_dom_1.createRange(parentLINode, currentSelectionPath.start, currentSelectionPath.end));
                    }
                    else {
                        // In this case, we're going out to the parent root.
                        if (parentLINode.nextElementSibling) {
                            roosterjs_editor_dom_1.splitBalancedNodeRange(parentLINode);
                        }
                        var wrappedContents = roosterjs_editor_dom_1.wrap(roosterjs_editor_dom_1.toArray(parentLINode.childNodes));
                        var wrappedRange = roosterjs_editor_dom_1.createRange(wrappedContents, currentSelectionPath.start, currentSelectionPath.end);
                        var wrappedSelectionPath = roosterjs_editor_dom_1.getSelectionPath(wrappedContents, wrappedRange);
                        existingList.insertAdjacentElement('afterend', wrappedContents);
                        editor.deleteNode(parentLINode);
                        var newRange = roosterjs_editor_dom_1.createRange(wrappedContents, wrappedSelectionPath.start, wrappedSelectionPath.end);
                        editor.select(newRange);
                    }
                    if (existingList.childElementCount == 0) {
                        editor.deleteNode(existingList);
                    }
                }
            }
            else {
                editor.getDocument().execCommand(command, false, null);
            }
        }
        else {
            editor.getDocument().execCommand(command, false, null);
        }
    }
    else {
        editor.getDocument().execCommand(command, false, null);
    }
    var newList = editor.getElementAtCursor('OL,UL');
    if (newList == existingList) {
        newList = null;
    }
    return newList;
}
exports.default = processList;
//# sourceMappingURL=processList.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-api/lib/utils/toggleTagCore.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-api/lib/utils/toggleTagCore.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var ZERO_WIDTH_SPACE = '&#8203;';
var UNWRAPPABLE_NODES = 'LI,THEAD,TBODY,TR,TD,TH'.split(',');
var DEFAULT_STYLER = function (_) { };
/**
 * Toggle a tag at selection, if selection already contains elements of such tag,
 * the elements will be untagge and other elements will take no affect
 * @param editor The editor instance
 * @param tag The tag name
 * @param styler (Optional) The styler for setting the style for the blockquote element
 * @param wrapFunction (Optional) The wrap function
 * @param unwrapFunction (Optional) The unwrap function
 */
function toggleTagCore(editor, tag, styler, wrapFunction, unwrapFunction) {
    if (wrapFunction === void 0) { wrapFunction = function (nodes) { return roosterjs_editor_dom_1.wrap(nodes, tag); }; }
    if (unwrapFunction === void 0) { unwrapFunction = roosterjs_editor_dom_1.unwrap; }
    editor.focus();
    editor.addUndoSnapshot(function (start, end) {
        var result;
        var range = editor.getSelectionRange();
        if (range &&
            editor.queryElements(tag, 1 /* OnSelection */, unwrapFunction).length == 0) {
            var startNode = roosterjs_editor_dom_1.Position.getStart(range).normalize().node;
            var startBlock = editor.getBlockElementAtNode(startNode);
            var endNode = roosterjs_editor_dom_1.Position.getEnd(range).normalize().node;
            var endBlock = editor.getBlockElementAtNode(endNode);
            var nodes = startBlock && endBlock
                ? editor.collapseNodes(startBlock.getStartNode(), endBlock.getEndNode(), true /*canSplitParent*/)
                : [];
            if (nodes.length == 0) {
                // Selection is collapsed and blockElement is null, we need to create an empty div.
                // In case of IE and Edge, we insert ZWS to put cursor in the div, otherwise insert BR node.
                nodes = roosterjs_editor_dom_1.fromHtml("<DIV>" + (roosterjs_editor_dom_1.Browser.isIEOrEdge ? ZERO_WIDTH_SPACE : '<BR>') + "</DIV>", editor.getDocument());
                editor.insertNode(nodes[0]);
                editor.select(nodes[0], 0 /* Begin */);
            }
            else if (nodes.length == 1) {
                var tag_1 = roosterjs_editor_dom_1.getTagOfNode(nodes[0]);
                if (tag_1 == 'BR') {
                    nodes = [roosterjs_editor_dom_1.wrap(nodes[0])];
                }
                else if (tag_1 == 'LI' || tag_1 == 'TD') {
                    nodes = roosterjs_editor_dom_1.toArray(nodes[0].childNodes);
                }
            }
            else {
                while (nodes[0] &&
                    editor.contains(nodes[0].parentNode) &&
                    nodes.some(function (node) { return UNWRAPPABLE_NODES.indexOf(roosterjs_editor_dom_1.getTagOfNode(node)) >= 0; })) {
                    nodes = [roosterjs_editor_dom_1.splitBalancedNodeRange(nodes)];
                }
            }
            result = wrapFunction(nodes);
            (styler || DEFAULT_STYLER)(result);
        }
        if (!editor.select(start, end) && result) {
            editor.select(result);
        }
        return result;
    }, "Format" /* Format */);
}
exports.default = toggleTagCore;
//# sourceMappingURL=toggleTagCore.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/attachDomEvent.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/attachDomEvent.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isCharacterValue_1 = __webpack_require__(/*! ../eventApi/isCharacterValue */ "./node_modules/roosterjs-editor-core/lib/eventApi/isCharacterValue.js");
/**
 * Attach a DOM event to the editor content DIV
 * @param core The EditorCore object
 * @param eventName The DOM event name
 * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered
 * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event
 */
exports.attachDomEvent = function (core, eventName, pluginEventType, beforeDispatch) {
    var onEvent = function (event) {
        // Stop propagation of a printable keyboard event (a keyboard event which is caused by printable char input).
        // This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),
        // event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.
        // So if we missed some case here it is still acceptable.
        if ((isKeyboardEvent(event) && isCharacterValue_1.default(event)) ||
            pluginEventType == 12 /* Input */) {
            event.stopPropagation();
        }
        if (beforeDispatch) {
            beforeDispatch(event);
        }
        if (pluginEventType != null) {
            core.api.triggerEvent(core, {
                eventType: pluginEventType,
                rawEvent: event,
            }, false /*broadcast*/);
        }
    };
    core.contentDiv.addEventListener(eventName, onEvent);
    return function () {
        core.contentDiv.removeEventListener(eventName, onEvent);
    };
};
function isKeyboardEvent(e) {
    return e.type == 'keydown' || e.type == 'keypress' || e.type == 'keyup';
}
//# sourceMappingURL=attachDomEvent.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/calculateDefaultFormat.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/calculateDefaultFormat.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var DARK_MODE_DEFAULT_FORMAT = {
    backgroundColors: {
        darkModeColor: 'rgb(51,51,51)',
        lightModeColor: 'rgb(255,255,255)',
    },
    textColors: {
        darkModeColor: 'rgb(255,255,255)',
        lightModeColor: 'rgb(0,0,0)',
    },
};
function calculateDefaultFormat(node, baseFormat, inDarkMode) {
    if (inDarkMode) {
        if (!baseFormat.backgroundColors) {
            baseFormat.backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;
        }
        if (!baseFormat.textColors) {
            baseFormat.textColors = DARK_MODE_DEFAULT_FORMAT.textColors;
        }
    }
    if (baseFormat && Object.keys(baseFormat).length === 0) {
        return {};
    }
    baseFormat = baseFormat || {};
    var fontFamily = baseFormat.fontFamily, fontSize = baseFormat.fontSize, textColor = baseFormat.textColor, textColors = baseFormat.textColors, backgroundColor = baseFormat.backgroundColor, backgroundColors = baseFormat.backgroundColors, bold = baseFormat.bold, italic = baseFormat.italic, underline = baseFormat.underline;
    var currentStyles = fontFamily && fontSize && (textColor || textColors) ? null : roosterjs_editor_dom_1.getComputedStyles(node);
    return {
        fontFamily: fontFamily || currentStyles[0],
        fontSize: fontSize || currentStyles[1],
        get textColor() {
            return textColors
                ? inDarkMode
                    ? textColors.darkModeColor
                    : textColors.lightModeColor
                : textColor || currentStyles[2];
        },
        textColors: textColors,
        get backgroundColor() {
            return backgroundColors
                ? inDarkMode
                    ? backgroundColors.darkModeColor
                    : backgroundColors.lightModeColor
                : backgroundColor || '';
        },
        backgroundColors: backgroundColors,
        bold: bold,
        italic: italic,
        underline: underline,
    };
}
exports.calculateDefaultFormat = calculateDefaultFormat;
//# sourceMappingURL=calculateDefaultFormat.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/createPasteFragment.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/createPasteFragment.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var START_FRAGMENT = '<!--StartFragment-->';
var END_FRAGMENT = '<!--EndFragment-->';
var NBSP_HTML = '\u00A0';
exports.createPasteFragment = function (core, clipboardData, position, pasteAsText, applyCurrentStyle) {
    var _a, _b;
    // Step 1: Prepare BeforePasteEvent object
    var event = createBeforePasteEvent(core, clipboardData, pasteAsText);
    var fragment = event.fragment, pasteOption = event.pasteOption, sanitizingOption = event.sanitizingOption;
    var rawHtml = clipboardData.rawHtml, text = clipboardData.text, imageDataUri = clipboardData.imageDataUri;
    var doc;
    // Step 2: Fill the BeforePasteEvent object, especially the fragment for paste
    if (pasteOption == 2 /* PasteImage */ && imageDataUri) {
        var img = core.document.createElement('img');
        img.style.maxWidth = '100%';
        img.src = imageDataUri;
        fragment.appendChild(img);
    }
    else if (pasteOption == 0 /* PasteHtml */ &&
        rawHtml && ((_a = (doc = new DOMParser().parseFromString(rawHtml, 'text/html'))) === null || _a === void 0 ? void 0 : _a.body)) {
        // Save HTML node attributes and META attributes so that plugin can query
        var attributes = (_b = doc.querySelector('html')) === null || _b === void 0 ? void 0 : _b.attributes;
        (attributes ? roosterjs_editor_dom_1.toArray(attributes) : []).reduce(function (attrs, attr) {
            attrs[attr.name] = attr.value;
            return attrs;
        }, event.htmlAttributes);
        roosterjs_editor_dom_1.toArray(doc.querySelectorAll('meta')).reduce(function (attrs, meta) {
            attrs[meta.name] = meta.content;
            return attrs;
        }, event.htmlAttributes);
        // Move all STYLE nodes into header, and save them into sanitizing options.
        // Because if we directly move them into a fragment, all sheets under STYLE will be lost.
        processStyles(doc, function (style) {
            doc.head.appendChild(style);
            sanitizingOption.additionalGlobalStyleNodes.push(style);
        });
        var startIndex = rawHtml.indexOf(START_FRAGMENT);
        var endIndex = rawHtml.lastIndexOf(END_FRAGMENT);
        if (startIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {
            event.htmlBefore = rawHtml.substr(0, startIndex);
            event.htmlAfter = rawHtml.substr(endIndex + END_FRAGMENT.length);
            doc.body.innerHTML = clipboardData.html = rawHtml.substring(startIndex + START_FRAGMENT.length, endIndex);
            // Remove style nodes just added by setting innerHTML of body since we already have all
            // style nodes in header.
            // Here we use doc.body instead of doc because we only want to remove STYLE nodes under BODY
            // and the nodes under HEAD are still used when convert global CSS to inline
            processStyles(doc.body, function (style) { var _a; return (_a = style.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(style); });
        }
        while (doc.body.firstChild) {
            fragment.appendChild(doc.body.firstChild);
        }
        if (applyCurrentStyle && position) {
            var format_1 = getCurrentFormat(core, position.node);
            roosterjs_editor_dom_1.applyTextStyle(fragment, function (node) { return roosterjs_editor_dom_1.applyFormat(node, format_1); });
        }
    }
    else if (text) {
        text.split('\n').forEach(function (line, index, lines) {
            line = line
                .replace(/^ /g, NBSP_HTML)
                .replace(/\r/g, '')
                .replace(/ {2}/g, ' ' + NBSP_HTML);
            var node = line == '' ? document.createElement('br') : document.createTextNode(line);
            fragment.appendChild(index == 0 || index == lines.length - 1 ? node : roosterjs_editor_dom_1.wrap(node));
        });
    }
    // Step 3: Trigger BeforePasteEvent so that plugins can do proper change before paste
    core.api.triggerEvent(core, event, true /*broadcast*/);
    // Step 4. Sanitize the fragment before paste to make sure the content is safe
    var sanitizer = new roosterjs_editor_dom_1.HtmlSanitizer(event.sanitizingOption);
    sanitizer.convertGlobalCssToInlineCss(fragment);
    sanitizer.sanitize(fragment, position && roosterjs_editor_dom_1.getInheritableStyles(position.element));
    return fragment;
};
function getCurrentFormat(core, node) {
    var pendableFormat = roosterjs_editor_dom_1.getPendableFormatState(core.document);
    var styleBasedForamt = core.api.getStyleBasedFormatState(core, node);
    return {
        fontFamily: styleBasedForamt.fontName,
        fontSize: styleBasedForamt.fontSize,
        textColor: styleBasedForamt.textColor,
        backgroundColor: styleBasedForamt.backgroundColor,
        textColors: styleBasedForamt.textColors,
        backgroundColors: styleBasedForamt.backgroundColors,
        bold: pendableFormat.isBold,
        italic: pendableFormat.isItalic,
        underline: pendableFormat.isUnderline,
    };
}
function createBeforePasteEvent(core, clipboardData, pasteAsText) {
    var pasteOption = pasteAsText
        ? 1 /* PasteText */
        : clipboardData.text || !clipboardData.image
            ? 0 /* PasteHtml */
            : 2 /* PasteImage */;
    var fragment = core.document.createDocumentFragment();
    return {
        eventType: 9 /* BeforePaste */,
        clipboardData: clipboardData,
        pasteOption: pasteOption,
        fragment: fragment,
        sanitizingOption: roosterjs_editor_dom_1.createDefaultHtmlSanitizerOptions(),
        htmlBefore: '',
        htmlAfter: '',
        htmlAttributes: {},
    };
}
function processStyles(node, callback) {
    var styles = node.querySelectorAll('style');
    for (var i = 0; i < styles.length; i++) {
        callback(styles[i]);
    }
}
//# sourceMappingURL=createPasteFragment.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/editWithUndo.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/editWithUndo.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.
 * Undo snapshot will not be added if this call is nested inside another editWithUndo() call.
 * @param core The EditorCore object
 * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.
 * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent
 */
exports.editWithUndo = function (core, callback, changeSource) {
    var isNested = core.currentUndoSnapshot !== null;
    var data;
    if (!isNested) {
        core.currentUndoSnapshot = core.corePlugins.undo.addUndoSnapshot();
    }
    try {
        if (callback) {
            var range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);
            data = callback(range && roosterjs_editor_dom_1.Position.getStart(range).normalize(), range && roosterjs_editor_dom_1.Position.getEnd(range).normalize(), core.currentUndoSnapshot);
            if (!isNested) {
                core.corePlugins.undo.addUndoSnapshot();
            }
        }
    }
    finally {
        if (!isNested) {
            core.currentUndoSnapshot = null;
        }
    }
    if (callback && changeSource) {
        var event_1 = {
            eventType: 6 /* ContentChanged */,
            source: changeSource,
            data: data,
        };
        core.api.triggerEvent(core, event_1, true /*broadcast*/);
    }
};
//# sourceMappingURL=editWithUndo.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/focus.js":
/*!*****************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/focus.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Focus to editor. If there is a cached selection range, use it as current selection
 * @param core The EditorCore object
 */
exports.focus = function (core) {
    if (!core.api.hasFocus(core) || !core.api.getSelectionRange(core, false /*tryGetFromCache*/)) {
        // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.
        // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).
        // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body
        // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).
        // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset
        // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).
        // It should be better than the case you cannot type
        if (!core.cachedSelectionRange ||
            !core.api.selectRange(core, core.cachedSelectionRange, true /*skipSameRange*/)) {
            var node = roosterjs_editor_dom_1.getFirstLeafNode(core.contentDiv) || core.contentDiv;
            core.api.selectRange(core, roosterjs_editor_dom_1.createRange(node, 0 /* Begin */), true /*skipSameRange*/);
        }
    }
    // remember to clear cachedSelectionRange
    core.cachedSelectionRange = null;
    // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor
    if (!core.api.hasFocus(core)) {
        core.contentDiv.focus();
    }
};
//# sourceMappingURL=focus.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/getCustomData.js":
/*!*************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/getCustomData.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Get custom data related with this editor
 * @param core The EditorCore object
 * @param key Key of the custom data
 * @param getter Getter function. If custom data for the given key doesn't exist,
 * call this function to get one and store it if it is specified. Otherwise return undefined
 * @param disposer An optional disposer function to dispose this custom data when
 * dispose editor.
 */
exports.getCustomData = function (core, key, getter, disposer) {
    return (core.customData[key] = core.customData[key] || {
        value: getter ? getter() : undefined,
        disposer: disposer,
    }).value;
};
//# sourceMappingURL=getCustomData.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/getSelectionRange.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/getSelectionRange.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Get current or cached selection range
 * @param core The EditorCore object
 * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now
 * @returns A Range object of the selection range
 */
exports.getSelectionRange = function (core, tryGetFromCache) {
    var result = null;
    if (!tryGetFromCache || core.api.hasFocus(core)) {
        var selection = core.document.defaultView.getSelection();
        if (selection && selection.rangeCount > 0) {
            var range = selection.getRangeAt(0);
            if (roosterjs_editor_dom_1.contains(core.contentDiv, range)) {
                result = range;
            }
        }
    }
    if (!result && tryGetFromCache) {
        result = core.cachedSelectionRange;
    }
    return result;
};
//# sourceMappingURL=getSelectionRange.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/getStyleBasedFormatState.js":
/*!************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/getStyleBasedFormatState.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var ORIGINAL_STYLE_COLOR_SELECTOR = '[data-ogsc],[data-ogac]';
var ORIGINAL_STYLE_BACK_COLOR_SELECTOR = '[data-ogsb],[data-ogab]';
/**
 * Get style based format state from current selection, including font name/size and colors
 * @param core The EditorCore objects
 * @param node The node to get style from
 */
exports.getStyleBasedFormatState = function (core, node) {
    if (!node) {
        return {};
    }
    var styles = node ? roosterjs_editor_dom_1.getComputedStyles(node) : [];
    var isDarkMode = core.inDarkMode;
    var root = core.contentDiv;
    var ogTextColorNode = isDarkMode && roosterjs_editor_dom_1.findClosestElementAncestor(node, root, ORIGINAL_STYLE_COLOR_SELECTOR);
    var ogBackgroundColorNode = isDarkMode && roosterjs_editor_dom_1.findClosestElementAncestor(node, root, ORIGINAL_STYLE_BACK_COLOR_SELECTOR);
    return {
        fontName: styles[0],
        fontSize: styles[1],
        textColor: styles[2],
        backgroundColor: styles[3],
        textColors: ogTextColorNode
            ? {
                darkModeColor: styles[2],
                lightModeColor: ogTextColorNode.dataset.ogsc || ogTextColorNode.dataset.ogac,
            }
            : undefined,
        backgroundColors: ogBackgroundColorNode
            ? {
                darkModeColor: styles[3],
                lightModeColor: ogBackgroundColorNode.dataset.ogsb || ogBackgroundColorNode.dataset.ogab,
            }
            : undefined,
    };
};
//# sourceMappingURL=getStyleBasedFormatState.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/hasFocus.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/hasFocus.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Check if the editor has focus now
 * @param core The EditorCore object
 * @returns True if the editor has focus, otherwise false
 */
exports.hasFocus = function (core) {
    var activeElement = core.document.activeElement;
    return (activeElement && roosterjs_editor_dom_1.contains(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/));
};
//# sourceMappingURL=hasFocus.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/insertNode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/insertNode.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
function getInitialRange(core, option) {
    // Selection start replaces based on the current selection.
    // Range inserts based on a provided range.
    // Both have the potential to use the current selection to restore cursor position
    // So in both cases we need to store the selection state.
    var range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);
    var rangeToRestore = null;
    if (option.position == 5 /* Range */) {
        rangeToRestore = range;
        range = option.range;
    }
    else if (range) {
        rangeToRestore = range.cloneRange();
    }
    return { range: range, rangeToRestore: rangeToRestore };
}
/**
 * Insert a DOM node into editor content
 * @param core The EditorCore object. No op if null.
 * @param option An insert option object to specify how to insert the node
 */
exports.insertNode = function (core, node, option) {
    option = option || {
        position: 3 /* SelectionStart */,
        insertOnNewLine: false,
        updateCursor: true,
        replaceSelection: true,
    };
    var contentDiv = core.contentDiv;
    if (option.updateCursor) {
        core.api.focus(core);
    }
    switch (option.position) {
        case 0 /* Begin */:
        case 1 /* End */: {
            var isBegin = option.position == 0 /* Begin */;
            var block = roosterjs_editor_dom_1.getFirstLastBlockElement(contentDiv, isBegin);
            var insertedNode_1;
            if (block) {
                var refNode = isBegin ? block.getStartNode() : block.getEndNode();
                if (option.insertOnNewLine ||
                    refNode.nodeType == 3 /* Text */ ||
                    roosterjs_editor_dom_1.isVoidHtmlElement(refNode)) {
                    // For insert on new line, or refNode is text or void html element (HR, BR etc.)
                    // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the
                    // first and last node. Insert before 'hello' or after 'world', but still inside DIV
                    if (roosterjs_editor_dom_1.safeInstanceOf(node, 'DocumentFragment')) {
                        // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode
                        // because insertBefore() returns an empty DocumentFragment
                        insertedNode_1 = roosterjs_editor_dom_1.toArray(node.childNodes);
                        refNode.parentNode.insertBefore(node, isBegin ? refNode : refNode.nextSibling);
                    }
                    else {
                        insertedNode_1 = refNode.parentNode.insertBefore(node, isBegin ? refNode : refNode.nextSibling);
                    }
                }
                else {
                    // if the refNode can have child, use appendChild (which is like to insert as first/last child)
                    // i.e. <div>hello</div>, the content will be inserted before/after hello
                    insertedNode_1 = refNode.insertBefore(node, isBegin ? refNode.firstChild : null);
                }
            }
            else {
                // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv
                insertedNode_1 = contentDiv.appendChild(node);
            }
            // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,
            // add a DIV wrapping
            if (insertedNode_1 && option.insertOnNewLine) {
                var nodes = Array.isArray(insertedNode_1) ? insertedNode_1 : [insertedNode_1];
                if (!roosterjs_editor_dom_1.isBlockElement(nodes[0]) || !roosterjs_editor_dom_1.isBlockElement(nodes[nodes.length - 1])) {
                    roosterjs_editor_dom_1.wrap(nodes);
                }
            }
            break;
        }
        case 2 /* DomEnd */:
            // Use appendChild to insert the node at the end of the content div.
            var insertedNode = contentDiv.appendChild(node);
            // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,
            // add a DIV wrapping
            if (insertedNode && option.insertOnNewLine && !roosterjs_editor_dom_1.isBlockElement(insertedNode)) {
                roosterjs_editor_dom_1.wrap(insertedNode);
            }
            break;
        case 5 /* Range */:
        case 3 /* SelectionStart */:
            var _a = getInitialRange(core, option), range = _a.range, rangeToRestore = _a.rangeToRestore;
            if (!range) {
                return;
            }
            // if to replace the selection and the selection is not collapsed, remove the the content at selection first
            if (option.replaceSelection && !range.collapsed) {
                range.deleteContents();
            }
            var pos = roosterjs_editor_dom_1.Position.getStart(range);
            var blockElement = void 0;
            if (option.insertOnNewLine &&
                (blockElement = roosterjs_editor_dom_1.getBlockElementAtNode(contentDiv, pos.normalize().node))) {
                pos = new roosterjs_editor_dom_1.Position(blockElement.getEndNode(), -3 /* After */);
            }
            else {
                pos = roosterjs_editor_dom_1.adjustNodeInsertPosition(contentDiv, node, pos);
            }
            var nodeForCursor = node.nodeType == 11 /* DocumentFragment */ ? node.lastChild : node;
            range = roosterjs_editor_dom_1.createRange(pos);
            range.insertNode(node);
            if (option.updateCursor && nodeForCursor) {
                rangeToRestore = roosterjs_editor_dom_1.createRange(new roosterjs_editor_dom_1.Position(nodeForCursor, -3 /* After */).normalize());
            }
            core.api.selectRange(core, rangeToRestore);
            break;
        case 4 /* Outside */:
            core.contentDiv.parentNode.insertBefore(node, contentDiv.nextSibling);
            break;
    }
    return true;
};
//# sourceMappingURL=insertNode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/selectRange.js":
/*!***********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/selectRange.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var hasFocus_1 = __webpack_require__(/*! ./hasFocus */ "./node_modules/roosterjs-editor-core/lib/coreAPI/hasFocus.js");
/**
 * Change the editor selection to the given range
 * @param core The EditorCore object
 * @param range The range to select
 * @param skipSameRange When set to true, do nothing if the given range is the same with current selection
 * in editor, otherwise it will always remove current selection ranage and set to the given one.
 * This parameter is always treat as true in Edge to avoid some weird runtime exception.
 */
exports.selectRange = function (core, range, skipSameRange) {
    var selection;
    var needAddRange = true;
    if (!roosterjs_editor_dom_1.contains(core.contentDiv, range) ||
        !(selection = core.document.defaultView.getSelection())) {
        return false;
    }
    if (selection.rangeCount > 0) {
        // Workaround IE exception 800a025e
        try {
            var currentRange = void 0;
            // Do not remove/add range if current selection is the same with target range
            // Without this check, execCommand() may fail in Edge since we changed the selection
            if ((skipSameRange || roosterjs_editor_dom_1.Browser.isEdge) &&
                (currentRange = selection.rangeCount == 1 ? selection.getRangeAt(0) : null) &&
                currentRange.startContainer == range.startContainer &&
                currentRange.startOffset == range.startOffset &&
                currentRange.endContainer == range.endContainer &&
                currentRange.endOffset == range.endOffset) {
                needAddRange = false;
            }
            else {
                selection.removeAllRanges();
            }
        }
        catch (e) { }
    }
    if (needAddRange) {
        selection.addRange(range);
    }
    if (!hasFocus_1.hasFocus(core)) {
        core.cachedSelectionRange = range;
    }
    if (range.collapsed) {
        // If selected, and current selection is collapsed,
        // need to restore pending format state if exists.
        core.corePlugins.domEvent.restorePendingFormatState();
    }
    return true;
};
/**
 * @deprecated Only for compatibility with existing code, don't use ths function, use selectRange instead
 */
exports.select = function (core, arg1, arg2, arg3, arg4) {
    var range = roosterjs_editor_dom_1.isRange(arg1) ? arg1 : roosterjs_editor_dom_1.createRange(arg1, arg2, arg3, arg4);
    return core.api.selectRange(core, range);
};
//# sourceMappingURL=selectRange.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/coreAPI/triggerEvent.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/coreAPI/triggerEvent.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Trigger a plugin event
 * @param core The EditorCore object
 * @param pluginEvent The event object to trigger
 * @param broadcast Set to true to skip the shouldHandleEventExclusively check
 */
exports.triggerEvent = function (core, pluginEvent, broadcast) {
    if (broadcast ||
        !core.eventHandlerPlugins.some(function (plugin) { return handledExclusively(pluginEvent, plugin); })) {
        core.eventHandlerPlugins.forEach(function (plugin) {
            if (plugin.onPluginEvent) {
                plugin.onPluginEvent(pluginEvent);
            }
        });
    }
};
function handledExclusively(event, plugin) {
    if (plugin.onPluginEvent &&
        plugin.willHandleEventExclusively &&
        plugin.willHandleEventExclusively(event)) {
        plugin.onPluginEvent(event);
        return true;
    }
    return false;
}
//# sourceMappingURL=triggerEvent.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/corePlugins/CopyPlugin.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/corePlugins/CopyPlugin.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var normalizeContentColor_1 = __webpack_require__(/*! ../darkMode/normalizeContentColor */ "./node_modules/roosterjs-editor-core/lib/darkMode/normalizeContentColor.js");
// TODO: Rename to DarkmodePlugin in next major release
/**
 * Copy plugin, hijacks copy events to normalize the content to the clipboard.
 */
var CopyPlugin = /** @class */ (function () {
    function CopyPlugin() {
        var _this = this;
        this.onExtract = function (isCut) { return function (event) {
            // if it's dark mode...
            if (_this.editor && _this.editor.isDarkMode()) {
                // get whatever the current selection range is
                var selectionRange = _this.editor.getSelectionRange();
                if (selectionRange && !selectionRange.collapsed) {
                    var clipboardEvent = event;
                    var copyFragment = _this.editor.getSelectionRange().cloneContents();
                    var containerDiv = _this.editor.getDocument().createElement('div');
                    // Leverage script execution policy on CEDs to try and prevent XSS
                    containerDiv.contentEditable = 'true';
                    containerDiv.appendChild(copyFragment);
                    // revert just this selected range to light mode colors
                    normalizeContentColor_1.default(containerDiv);
                    // put it on the clipboard
                    clipboardEvent.clipboardData.setData('text/html', containerDiv.innerHTML);
                    clipboardEvent.clipboardData.setData('text/plain', containerDiv.innerText);
                    // if it's cut, delete the contents
                    if (isCut) {
                        _this.editor.getSelectionRange().deleteContents();
                    }
                    event.preventDefault();
                }
            }
        }; };
    }
    /**
     * Get a friendly name of  this plugin
     */
    CopyPlugin.prototype.getName = function () {
        return 'Copy';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    CopyPlugin.prototype.initialize = function (editor) {
        this.editor = editor;
        this.eventDisposer = editor.addDomEventHandler({
            copy: this.onExtract(false),
            cut: this.onExtract(true),
        });
    };
    /**
     * Dispose this plugin
     */
    CopyPlugin.prototype.dispose = function () {
        this.eventDisposer();
        this.eventDisposer = null;
        this.editor = null;
    };
    return CopyPlugin;
}());
exports.default = CopyPlugin;
//# sourceMappingURL=CopyPlugin.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/corePlugins/CorePastePlugin.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/corePlugins/CorePastePlugin.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var CONTAINER_HTML = '<div contenteditable style="width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text"></div>';
/**
 * Core paste plugin for handling onPaste event and extract the pasted content
 */
var CorePastePlugin = /** @class */ (function () {
    function CorePastePlugin() {
        var _this = this;
        this.onPaste = function (event) {
            roosterjs_editor_dom_1.extractClipboardEvent(event, function (items) {
                if (items.html === undefined) {
                    // Can't get pasted HTML directly, need to use a temp DIV to retrieve pasted content.
                    // This is mostly for IE
                    var originalSelectionRange_1 = _this.editor.getSelectionRange();
                    var tempDiv_1 = _this.editor.getCustomData('PasteDiv', _this.createTempDivForIE, function (pasteDiv) { return pasteDiv.parentNode.removeChild(pasteDiv); });
                    tempDiv_1.style.display = '';
                    tempDiv_1.focus();
                    _this.editor.runAsync(function () {
                        // restore original selection range in editor
                        _this.editor.select(originalSelectionRange_1);
                        items.html = tempDiv_1.innerHTML;
                        tempDiv_1.style.display = 'none';
                        tempDiv_1.innerHTML = '';
                        _this.paste(items);
                    });
                }
                else {
                    _this.paste(items);
                }
            });
        };
        this.createTempDivForIE = function () {
            var pasteDiv = roosterjs_editor_dom_1.fromHtml(CONTAINER_HTML, _this.editor.getDocument())[0];
            _this.editor.insertNode(pasteDiv, {
                position: 4 /* Outside */,
            });
            return pasteDiv;
        };
    }
    CorePastePlugin.prototype.getName = function () {
        return 'CorePaste';
    };
    CorePastePlugin.prototype.initialize = function (editor) {
        this.editor = editor;
        this.disposer = this.editor.addDomEventHandler('paste', this.onPaste);
    };
    CorePastePlugin.prototype.dispose = function () {
        this.disposer();
        this.disposer = null;
        this.editor = null;
    };
    CorePastePlugin.prototype.paste = function (items) {
        var _this = this;
        var clipboardData = {
            types: items.types,
            image: items.image,
            text: items.text,
            rawHtml: items.html,
            // Will be set later
            snapshotBeforePaste: null,
            imageDataUri: null,
            // TODO: deprecated properties
            html: null,
            originalFormat: null,
        };
        if (clipboardData.image) {
            var reader_1 = new FileReader();
            reader_1.onload = function () {
                clipboardData.imageDataUri = reader_1.result;
                _this.editor.paste(clipboardData);
            };
            reader_1.onerror = function () {
                clipboardData.image = null;
                _this.editor.paste(clipboardData);
            };
            reader_1.readAsDataURL(clipboardData.image);
        }
        else {
            this.editor.paste(clipboardData);
        }
    };
    return CorePastePlugin;
}());
exports.default = CorePastePlugin;
//# sourceMappingURL=CorePastePlugin.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.js":
/*!******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * DOMEventPlugin handles customized DOM events, including:
 * 1. IME state management
 * 2. Selection management
 * 3. Cut and Drop management
 * 4. Pending format state management
 * 5. Scroll container and scroll event management
 */
var DOMEventPlugin = /** @class */ (function () {
    function DOMEventPlugin(disableRestoreSelectionOnFocus) {
        var _this = this;
        this.disableRestoreSelectionOnFocus = disableRestoreSelectionOnFocus;
        this.inIme = false;
        this.onNativeEvent = function (e) {
            _this.editor.runAsync(function () {
                _this.editor.addUndoSnapshot(function () { }, e.type == 'cut' ? "Cut" /* Cut */ : "Drop" /* Drop */);
            });
        };
        this.onFocus = function () {
            if (_this.disableRestoreSelectionOnFocus) {
                if (_this.cachedPosition && _this.cachedFormatState) {
                    var range = _this.editor.getSelectionRange();
                    if (range.collapsed &&
                        roosterjs_editor_dom_1.Position.getStart(range).normalize().equalTo(_this.cachedPosition)) {
                        _this.restorePendingFormatState();
                    }
                    else {
                        _this.clear();
                    }
                }
            }
            else {
                _this.editor.restoreSavedRange();
            }
        };
        this.onBlur = function () {
            _this.editor.saveSelectionRange();
        };
        this.onScroll = function (e) {
            _this.editor.triggerPluginEvent(15 /* Scroll */, {
                rawEvent: e,
                scrollContainer: _this.editor.getScrollContainer(),
            });
        };
    }
    DOMEventPlugin.prototype.getName = function () {
        return 'DOMEvent';
    };
    DOMEventPlugin.prototype.initialize = function (editor) {
        var _a;
        var _this = this;
        this.editor = editor;
        this.disposer = editor.addDomEventHandler((_a = {
                // 1. IME state management
                compositionstart: function () { return (_this.inIme = true); },
                compositionend: function (rawEvent) {
                    _this.inIme = false;
                    editor.triggerPluginEvent(3 /* CompositionEnd */, {
                        rawEvent: rawEvent,
                    });
                },
                // 2. Cut and drop management
                drop: this.onNativeEvent,
                cut: this.onNativeEvent,
                // 3. Selection mangement
                focus: this.onFocus
            },
            _a[roosterjs_editor_dom_1.Browser.isIEOrEdge ? 'beforedeactivate' : 'blur'] = this.onBlur,
            _a));
        this.editor.getScrollContainer().addEventListener('scroll', this.onScroll);
    };
    DOMEventPlugin.prototype.dispose = function () {
        this.editor.getScrollContainer().removeEventListener('scroll', this.onScroll);
        this.disposer();
        this.disposer = null;
        this.editor = null;
        this.clear();
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    DOMEventPlugin.prototype.onPluginEvent = function (event) {
        switch (event.eventType) {
            case 13 /* PendingFormatStateChanged */:
                // Got PendingFormatStateChagned event, cache current position and pending format
                this.cachedPosition = this.getCurrentPosition();
                this.cachedFormatState = event.formatState;
                break;
            case 0 /* KeyDown */:
            case 4 /* MouseDown */:
            case 6 /* ContentChanged */:
                // If content or position is changed (by keyboard, mouse, or code),
                // check if current position is still the same with the cached one (if exist),
                // and clear cached format if position is changed since it is out-of-date now
                if (this.cachedPosition &&
                    !this.cachedPosition.equalTo(this.getCurrentPosition())) {
                    this.clear();
                }
                break;
        }
    };
    /**
     * Restore cached pending format state (if exist) to current selection
     */
    DOMEventPlugin.prototype.restorePendingFormatState = function () {
        var _this = this;
        if (this.cachedFormatState) {
            var formatState_1 = roosterjs_editor_dom_1.getPendableFormatState(this.editor.getDocument());
            Object.keys(roosterjs_editor_dom_1.PendableFormatCommandMap).forEach(function (key) {
                if (_this.cachedFormatState[key] != formatState_1[key]) {
                    _this.editor
                        .getDocument()
                        .execCommand(roosterjs_editor_dom_1.PendableFormatCommandMap[key], false, null);
                }
            });
            this.cachedPosition = this.getCurrentPosition();
        }
    };
    /**
     * Check if editor is in IME input sequence
     * @returns True if editor is in IME input sequence, otherwise false
     */
    DOMEventPlugin.prototype.isInIME = function () {
        return this.inIme;
    };
    DOMEventPlugin.prototype.clear = function () {
        this.cachedPosition = null;
        this.cachedFormatState = null;
    };
    DOMEventPlugin.prototype.getCurrentPosition = function () {
        var range = this.editor.getSelectionRange();
        return range && roosterjs_editor_dom_1.Position.getStart(range).normalize();
    };
    return DOMEventPlugin;
}());
exports.default = DOMEventPlugin;
//# sourceMappingURL=DOMEventPlugin.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/corePlugins/EditPlugin.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/corePlugins/EditPlugin.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isCtrlOrMetaPressed_1 = __webpack_require__(/*! ../eventApi/isCtrlOrMetaPressed */ "./node_modules/roosterjs-editor-core/lib/eventApi/isCtrlOrMetaPressed.js");
/**
 * Edit Component helps handle Content edit features
 */
var EditPlugin = /** @class */ (function () {
    function EditPlugin() {
        this.featureMap = {};
        this.autoCompleteSnapshot = null;
        this.autoCompleteChangeSource = null;
    }
    EditPlugin.prototype.getName = function () {
        return 'Edit';
    };
    EditPlugin.prototype.initialize = function (editor) {
        var _this = this;
        this.editor = editor;
        this.addFeature({
            keys: [8 /* BACKSPACE */],
            shouldHandleEvent: function () { return _this.autoCompleteSnapshot !== null; },
            handleEvent: function (event, editor) {
                event.rawEvent.preventDefault();
                editor.setContent(_this.autoCompleteSnapshot, false /*triggerContentChangedEvent*/);
            },
        });
    };
    EditPlugin.prototype.dispose = function () {
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    EditPlugin.prototype.onPluginEvent = function (event) {
        var contentChanged = false;
        var currentFeature = this.findFeature(event);
        switch (event.eventType) {
            case 6 /* ContentChanged */:
                contentChanged = this.autoCompleteChangeSource != event.source;
                break;
            case 4 /* MouseDown */:
            case 0 /* KeyDown */:
                contentChanged = true;
                break;
        }
        if (currentFeature) {
            currentFeature.handleEvent(event, this.editor);
        }
        if (contentChanged) {
            this.autoCompleteSnapshot = null;
            this.autoCompleteChangeSource = null;
        }
    };
    /**
     * Add a Content Edit feature
     * @param feature The feature to add
     */
    EditPlugin.prototype.addFeature = function (feature) {
        var _this = this;
        feature.keys.forEach(function (key) {
            var array = _this.featureMap[key] || [];
            array.push(feature);
            _this.featureMap[key] = array;
        });
    };
    /**
     * Perform an auto complete action in the callback, save a snapsnot of content before the action,
     * and trigger ContentChangedEvent with the change source if specified
     * @param callback The auto complete callback, return value will be used as data field of ContentChangedEvent
     * @param changeSource Chagne source of ContentChangedEvent. If not passed, no ContentChangedEvent will be  triggered
     */
    EditPlugin.prototype.performAutoComplete = function (callback, changeSource) {
        var _this = this;
        this.editor.addUndoSnapshot(function (start, end, snapshot) {
            var data = callback();
            _this.autoCompleteSnapshot = snapshot;
            _this.autoCompleteChangeSource = changeSource;
            return data;
        }, changeSource);
    };
    EditPlugin.prototype.findFeature = function (event) {
        var _this = this;
        var hasFunctionKey = false;
        var features;
        var ctrlOrMeta = false;
        if (event.eventType == 0 /* KeyDown */) {
            var rawEvent = event.rawEvent;
            ctrlOrMeta = isCtrlOrMetaPressed_1.default(rawEvent);
            hasFunctionKey = ctrlOrMeta || rawEvent.altKey;
            features = this.featureMap[rawEvent.which];
        }
        else if (event.eventType == 6 /* ContentChanged */) {
            features = this.featureMap[2048 /* CONTENTCHANGED */];
        }
        return (features &&
            features.filter(function (feature) {
                return (feature.allowFunctionKeys || !hasFunctionKey) &&
                    feature.shouldHandleEvent(event, _this.editor, ctrlOrMeta);
            })[0]);
    };
    return EditPlugin;
}());
exports.default = EditPlugin;
//# sourceMappingURL=EditPlugin.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/corePlugins/FirefoxTypeAfterLink.js":
/*!************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/corePlugins/FirefoxTypeAfterLink.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var cacheGetContentSearcher_1 = __webpack_require__(/*! ../eventApi/cacheGetContentSearcher */ "./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetContentSearcher.js");
/**
 * FirefoxTypeAfterLink Component helps handle typing event when cursor is right after a link.
 * When typing/pasting after a link, browser may put the new charactor inside link.
 * This plugin overrides this behavior to always insert outside of link.
 *
 * TODO: Rename this file in next major release since it is not only applied to Firefox now
 */
var FirefoxTypeAfterLink = /** @class */ (function () {
    function FirefoxTypeAfterLink() {
    }
    FirefoxTypeAfterLink.prototype.getName = function () {
        return 'FirefoxTypeAfterLink';
    };
    FirefoxTypeAfterLink.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    FirefoxTypeAfterLink.prototype.dispose = function () {
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    FirefoxTypeAfterLink.prototype.onPluginEvent = function (event) {
        if ((roosterjs_editor_dom_1.Browser.isFirefox && event.eventType == 1 /* KeyPress */) ||
            event.eventType == 9 /* BeforePaste */) {
            var range = this.editor.getSelectionRange();
            if (range && range.collapsed && this.editor.getElementAtCursor('A[href]')) {
                var searcher = cacheGetContentSearcher_1.cacheGetContentSearcher(event, this.editor);
                var inlineElement = searcher.getInlineElementBefore();
                if (inlineElement instanceof roosterjs_editor_dom_1.LinkInlineElement) {
                    this.editor.select(new roosterjs_editor_dom_1.Position(inlineElement.getContainerNode(), -3 /* After */));
                }
            }
        }
    };
    return FirefoxTypeAfterLink;
}());
exports.default = FirefoxTypeAfterLink;
//# sourceMappingURL=FirefoxTypeAfterLink.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * MouseUp Component helps handle mouse up event
 * this can trigger mouse up event after mousedown happens in editor
 * even mouse up is happening outside editor
 */
var MouseUpPlugin = /** @class */ (function () {
    function MouseUpPlugin() {
        var _this = this;
        this.onMouseUp = function (rawEvent) {
            if (_this.editor) {
                _this.removeMouseUpEventListener();
                _this.editor.triggerPluginEvent(5 /* MouseUp */, {
                    rawEvent: rawEvent,
                });
            }
        };
    }
    MouseUpPlugin.prototype.getName = function () {
        return 'MouseUp';
    };
    MouseUpPlugin.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    MouseUpPlugin.prototype.dispose = function () {
        this.removeMouseUpEventListener();
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    MouseUpPlugin.prototype.onPluginEvent = function (event) {
        if (event.eventType == 4 /* MouseDown */ && !this.mouseUpEventListerAdded) {
            this.editor
                .getDocument()
                .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);
            this.mouseUpEventListerAdded = true;
        }
    };
    MouseUpPlugin.prototype.removeMouseUpEventListener = function () {
        if (this.mouseUpEventListerAdded) {
            this.mouseUpEventListerAdded = false;
            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);
        }
    };
    return MouseUpPlugin;
}());
exports.default = MouseUpPlugin;
//# sourceMappingURL=MouseUpPlugin.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Typing Component helps to ensure typing is always happening under a DOM container
 */
var TypeInContainerPlugin = /** @class */ (function () {
    function TypeInContainerPlugin() {
    }
    TypeInContainerPlugin.prototype.getName = function () {
        return 'TypeInContainer';
    };
    TypeInContainerPlugin.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    TypeInContainerPlugin.prototype.dispose = function () {
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    TypeInContainerPlugin.prototype.onPluginEvent = function (event) {
        if (event.eventType == 1 /* KeyPress */) {
            this.onKeyPress(event);
        }
    };
    /**
     * Ensure we are typing in an HTML Element inside editor, and apply default format if current block is empty
     * @param node Current node
     * @param event (optional) The keyboard event that we are ensuring is typing in an element.
     * @returns A new position to select
     */
    TypeInContainerPlugin.prototype.ensureTypeInElement = function (position, event) {
        var result = position.normalize();
        var block = this.editor.getBlockElementAtNode(result.node);
        var formatNode;
        if (block) {
            formatNode = block.collapseToSingleElement();
            // if the block is empty, apply default format
            // Otherwise, leave it as it is as we don't want to change the style for existing data
            // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)
            var shouldSetNodeStyles = roosterjs_editor_dom_1.isNodeEmpty(formatNode) ||
                (event && this.wasNodeJustCreatedByKeyboardEvent(event, formatNode));
            formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;
        }
        else {
            // Only reason we don't get the selection block is that we have an empty content div
            // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)
            // The fix is to add a DIV wrapping, apply default format and move cursor over
            formatNode = roosterjs_editor_dom_1.fromHtml(roosterjs_editor_dom_1.Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>', this.editor.getDocument())[0];
            this.editor.insertNode(formatNode, {
                position: 1 /* End */,
                updateCursor: false,
                replaceSelection: false,
                insertOnNewLine: false,
            });
            // element points to a wrapping node we added "<div><br></div>". We should move the selection left to <br>
            result = new roosterjs_editor_dom_1.Position(formatNode.firstChild, 0 /* Begin */);
        }
        if (formatNode) {
            roosterjs_editor_dom_1.applyFormat(formatNode, this.editor.getDefaultFormat(), this.editor.isDarkMode());
        }
        return result;
    };
    TypeInContainerPlugin.prototype.onKeyPress = function (event) {
        var _this = this;
        // If normalization was not possible before the keypress,
        // check again after the keyboard event has been processed by browser native behaviour.
        //
        // This handles the case where the keyboard event that first inserts content happens when
        // there is already content under the selection (e.g. Ctrl+a -> type new content).
        //
        // Only scheudle when the range is not collapsed to catch this edge case.
        var range = this.editor.getSelectionRange();
        if (!range || this.editor.contains(roosterjs_editor_dom_1.findClosestElementAncestor(range.startContainer))) {
            return;
        }
        if (range.collapsed) {
            this.tryNormalizeTyping(event, range);
        }
        else if (!range.collapsed) {
            this.editor.runAsync(function () {
                _this.tryNormalizeTyping(event);
            });
        }
    };
    /**
     * When typing goes directly under content div, many things can go wrong
     * We fix it by wrapping it with a div and reposition cursor within the div
     */
    TypeInContainerPlugin.prototype.tryNormalizeTyping = function (event, range) {
        var position = this.ensureTypeInElement(roosterjs_editor_dom_1.Position.getStart(range || this.editor.getSelectionRange()), event);
        this.editor.select(position);
    };
    TypeInContainerPlugin.prototype.wasNodeJustCreatedByKeyboardEvent = function (event, formatNode) {
        return (roosterjs_editor_dom_1.isNode(event.rawEvent.target) &&
            event.rawEvent.target.contains(formatNode) &&
            event.rawEvent.key === formatNode.innerText);
    };
    return TypeInContainerPlugin;
}());
exports.default = TypeInContainerPlugin;
//# sourceMappingURL=TypeInContainerPlugin.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/darkMode/convertContentToDarkMode.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/darkMode/convertContentToDarkMode.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Converter for dark mode that runs all child elements of a node through the content transform function.
 * @param node The node containing HTML elements to convert.
 * @param skipRootElement Optional parameter to skip the root element of the Node passed in, if applicable.
 */
function convertContentToDarkMode(node, onExternalContentTransform, skipRootElement) {
    var childElements = [];
    // Get a list of all the decendents of a node.
    // querySelectorAll doesn't return a live list when called on an HTMLElement
    // So we use getElementsByTagName instead for HTMLElement types.
    if (roosterjs_editor_dom_1.isHTMLElement(node)) {
        childElements = Array.prototype.slice.call(node.getElementsByTagName('*'));
        if (!skipRootElement) {
            childElements.unshift(node);
        }
    }
    else if (roosterjs_editor_dom_1.isDocumentFragment(node)) {
        childElements = Array.prototype.slice.call(node.querySelectorAll('*'));
    }
    return childElements.length > 0
        ? function () {
            childElements.forEach(function (element) {
                if (onExternalContentTransform) {
                    onExternalContentTransform(element);
                }
                else {
                    element.style.color = null;
                    element.style.backgroundColor = null;
                }
            });
        }
        : null;
}
exports.convertContentToDarkMode = convertContentToDarkMode;
//# sourceMappingURL=convertContentToDarkMode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/darkMode/normalizeContentColor.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/darkMode/normalizeContentColor.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * @internal
 */
function normalizeContentColor(root) {
    var allChildElements = root.getElementsByTagName('*');
    roosterjs_editor_dom_1.toArray(allChildElements).forEach(function (e) {
        var element = e;
        if (element.dataset) {
            // Reset color styles based on the content of the ogsc/ogsb data element.
            // If those data properties are empty or do not exist, set them anyway to clear the content.
            element.style.color = isDataAttributeSettable(element.dataset.ogsc)
                ? element.dataset.ogsc
                : '';
            element.style.backgroundColor = isDataAttributeSettable(element.dataset.ogsb)
                ? element.dataset.ogsb
                : '';
            // Some elements might have set attribute colors. We need to reset these as well.
            if (isDataAttributeSettable(element.dataset.ogac)) {
                element.setAttribute('color', element.dataset.ogac);
            }
            else {
                element.removeAttribute('color');
            }
            if (isDataAttributeSettable(element.dataset.ogab)) {
                element.setAttribute('bgcolor', element.dataset.ogab);
            }
            else {
                element.removeAttribute('bgcolor');
            }
            // Clean up any remaining data attributes.
            if (element.dataset.ogsc) {
                delete element.dataset.ogsc;
            }
            if (element.dataset.ogsb) {
                delete element.dataset.ogsb;
            }
            if (element.dataset.ogac) {
                delete element.dataset.ogac;
            }
            if (element.dataset.ogab) {
                delete element.dataset.ogab;
            }
        }
    });
}
exports.default = normalizeContentColor;
function isDataAttributeSettable(newStyle) {
    return newStyle && newStyle != 'undefined' && newStyle != 'null';
}
//# sourceMappingURL=normalizeContentColor.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/editor/Editor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/editor/Editor.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var adjustBrowserBehavior_1 = __webpack_require__(/*! ./adjustBrowserBehavior */ "./node_modules/roosterjs-editor-core/lib/editor/adjustBrowserBehavior.js");
var createEditorCore_1 = __webpack_require__(/*! ./createEditorCore */ "./node_modules/roosterjs-editor-core/lib/editor/createEditorCore.js");
var mapPluginEvents_1 = __webpack_require__(/*! ./mapPluginEvents */ "./node_modules/roosterjs-editor-core/lib/editor/mapPluginEvents.js");
var normalizeContentColor_1 = __webpack_require__(/*! ../darkMode/normalizeContentColor */ "./node_modules/roosterjs-editor-core/lib/darkMode/normalizeContentColor.js");
var calculateDefaultFormat_1 = __webpack_require__(/*! ../coreAPI/calculateDefaultFormat */ "./node_modules/roosterjs-editor-core/lib/coreAPI/calculateDefaultFormat.js");
var convertContentToDarkMode_1 = __webpack_require__(/*! ../darkMode/convertContentToDarkMode */ "./node_modules/roosterjs-editor-core/lib/darkMode/convertContentToDarkMode.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * RoosterJs core editor class
 */
var Editor = /** @class */ (function () {
    //#region Lifecycle
    /**
     * Creates an instance of Editor
     * @param contentDiv The DIV HTML element which will be the container element of editor
     * @param options An optional options object to customize the editor
     */
    function Editor(contentDiv, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // 1. Make sure all parameters are valid
        if (roosterjs_editor_dom_1.getTagOfNode(contentDiv) != 'DIV') {
            throw new Error('contentDiv must be an HTML DIV element');
        }
        // 2. Store options values to local variables
        this.core = createEditorCore_1.default(contentDiv, options);
        this.enableExperimentFeatures = options.enableExperimentFeatures;
        // 3. Initialize plugins
        this.core.plugins.forEach(function (plugin) { return plugin.initialize(_this); });
        // 4. Ensure initial content and its format
        this.setContent(options.initialContent || contentDiv.innerHTML || '', false /*triggerContentChangedEvent*/);
        // 5. Create event handler to bind DOM events
        this.eventDisposers = mapPluginEvents_1.default(this.core);
        // 6. Add additional content edit features to the editor if specified
        if (options.additionalEditFeatures) {
            options.additionalEditFeatures.forEach(function (feature) { return _this.addContentEditFeature(feature); });
        }
        // 7. Make the container editable and set its selection styles
        if (!options.omitContentEditableAttributeChanges && !contentDiv.isContentEditable) {
            contentDiv.setAttribute('contenteditable', 'true');
            var styles = contentDiv.style;
            styles.userSelect = styles.msUserSelect = styles.webkitUserSelect = 'text';
            this.contenteditableChanged = true;
        }
        // 8. Do proper change for browsers to disable some browser-specified behaviors.
        adjustBrowserBehavior_1.default(this.core.document);
        // 9. Let plugins know that we are ready
        this.triggerPluginEvent(10 /* EditorReady */, {}, true /*broadcast*/);
        // 10. Before give editor to user, make sure there is at least one DIV element to accept typing
        this.core.corePlugins.typeInContainer.ensureTypeInElement(this.getFocusedPosition() || new roosterjs_editor_dom_1.Position(contentDiv, 0 /* Begin */));
    }
    /**
     * Dispose this editor, dispose all plugins and custom data
     */
    Editor.prototype.dispose = function () {
        this.triggerPluginEvent(11 /* BeforeDispose */, {}, true /*broadcast*/);
        this.core.plugins.forEach(function (plugin) { return plugin.dispose(); });
        this.eventDisposers.forEach(function (disposer) { return disposer(); });
        this.eventDisposers = null;
        for (var _i = 0, _a = Object.keys(this.core.customData); _i < _a.length; _i++) {
            var key = _a[_i];
            var data = this.core.customData[key];
            if (data && data.disposer) {
                data.disposer(data.value);
            }
            delete this.core.customData[key];
        }
        if (this.contenteditableChanged) {
            var styles = this.core.contentDiv.style;
            styles.userSelect = styles.msUserSelect = styles.webkitUserSelect = '';
            this.core.contentDiv.removeAttribute('contenteditable');
        }
        this.core = null;
    };
    /**
     * Get whether this editor is disposed
     * @returns True if editor is disposed, otherwise false
     */
    Editor.prototype.isDisposed = function () {
        return !this.core;
    };
    //#endregion
    //#region Node API
    /**
     * Insert node into editor
     * @param node The node to insert
     * @param option Insert options. Default value is:
     *  position: ContentPosition.SelectionStart
     *  updateCursor: true
     *  replaceSelection: true
     *  insertOnNewLine: false
     * @returns true if node is inserted. Otherwise false
     */
    Editor.prototype.insertNode = function (node, option) {
        // DocumentFragment type nodes become empty after they're inserted.
        // Therefore, we get the list of nodes to transform prior to their insertion.
        var darkModeOptions = this.getDarkModeOptions();
        var darkModeTransform = this.isDarkMode()
            ? convertContentToDarkMode_1.convertContentToDarkMode(node, darkModeOptions && darkModeOptions.onExternalContentTransform
                ? darkModeOptions.onExternalContentTransform
                : undefined)
            : null;
        var result = node ? this.core.api.insertNode(this.core, node, option) : false;
        if (result && darkModeTransform) {
            darkModeTransform();
        }
        return result;
    };
    /**
     * Delete a node from editor content
     * @param node The node to delete
     * @returns true if node is deleted. Otherwise false
     */
    Editor.prototype.deleteNode = function (node) {
        // Only remove the node when it falls within editor
        if (node && this.contains(node)) {
            node.parentNode.removeChild(node);
            return true;
        }
        return false;
    };
    /**
     * Replace a node in editor content with another node
     * @param existingNode The existing node to be replaced
     * @param new node to replace to
     * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false
     * @returns true if node is replaced. Otherwise false
     */
    Editor.prototype.replaceNode = function (existingNode, toNode, transformColorForDarkMode) {
        // Transform the new node to replace to
        var darkModeTransform = null;
        if (transformColorForDarkMode) {
            var darkModeOptions = this.getDarkModeOptions();
            darkModeTransform = this.isDarkMode()
                ? convertContentToDarkMode_1.convertContentToDarkMode(toNode, darkModeOptions && darkModeOptions.onExternalContentTransform
                    ? darkModeOptions.onExternalContentTransform
                    : undefined)
                : null;
        }
        // Only replace the node when it falls within editor
        if (existingNode && toNode && this.contains(existingNode)) {
            existingNode.parentNode.replaceChild(toNode, existingNode);
            if (darkModeTransform) {
                darkModeTransform();
            }
            return true;
        }
        return false;
    };
    /**
     * Get InlineElement at given node
     * @param node The node to create InlineElement
     * @returns The InlineElement result
     */
    Editor.prototype.getInlineElementAtNode = function (node) {
        return roosterjs_editor_dom_1.getInlineElementAtNode(this.core.contentDiv, node);
    };
    /**
     * Get BlockElement at given node
     * @param node The node to create InlineElement
     * @returns The BlockElement result
     */
    Editor.prototype.getBlockElementAtNode = function (node) {
        return roosterjs_editor_dom_1.getBlockElementAtNode(this.core.contentDiv, node);
    };
    Editor.prototype.contains = function (arg) {
        return roosterjs_editor_dom_1.contains(this.core.contentDiv, arg);
    };
    Editor.prototype.queryElements = function (selector, scopeOrCallback, callback) {
        if (scopeOrCallback === void 0) { scopeOrCallback = 0 /* Body */; }
        var scope = scopeOrCallback instanceof Function ? 0 /* Body */ : scopeOrCallback;
        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;
        var range = scope == 0 /* Body */ ? null : this.getSelectionRange();
        return roosterjs_editor_dom_1.queryElements(this.core.contentDiv, selector, callback, scope, range);
    };
    /**
     * Collapse nodes within the given start and end nodes to their common ascenstor node,
     * split parent nodes if necessary
     * @param start The start node
     * @param end The end node
     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent
     * and the returned nodes will be all nodes from start trhough end after splitting
     * False to disallow split parent
     * @returns When cansplitParent is true, returns all node from start through end after splitting,
     * otherwise just return start and end
     */
    Editor.prototype.collapseNodes = function (start, end, canSplitParent) {
        return roosterjs_editor_dom_1.collapseNodes(this.core.contentDiv, start, end, canSplitParent);
    };
    //#endregion
    //#region Content API
    /**
     * Check whether the editor contains any visible content
     * @param trim Whether trime the content string before check. Default is false
     * @returns True if there's no visible content, otherwise false
     */
    Editor.prototype.isEmpty = function (trim) {
        return roosterjs_editor_dom_1.isNodeEmpty(this.core.contentDiv, trim);
    };
    /**
     * Get current editor content as HTML string
     * @param triggerExtractContentEvent Whether trigger ExtractContent event to all plugins
     * before return. Use this parameter to remove any temporary content added by plugins.
     * @param includeSelectionMarker Set to true if need include selection marker inside the content.
     * When restore this content, editor will set the selection to the position marked by these markers.
     * This parameter will be ignored when triggerExtractContentEvent is set to true
     * @returns HTML string representing current editor content
     */
    Editor.prototype.getContent = function (triggerExtractContentEvent, includeSelectionMarker) {
        if (triggerExtractContentEvent === void 0) { triggerExtractContentEvent = true; }
        if (includeSelectionMarker === void 0) { includeSelectionMarker = false; }
        var content = '';
        var isDarkMode = this.core.inDarkMode;
        if (triggerExtractContentEvent || isDarkMode) {
            var clonedRoot = this.core.contentDiv.cloneNode(true /*deep*/);
            var path = includeSelectionMarker && this.getSelectionPath();
            var range = path && roosterjs_editor_dom_1.createRange(clonedRoot, path.start, path.end);
            if (isDarkMode) {
                normalizeContentColor_1.default(clonedRoot);
            }
            if (triggerExtractContentEvent) {
                this.triggerPluginEvent(8 /* ExtractContentWithDom */, {
                    clonedRoot: clonedRoot,
                }, true /*broadcast*/);
                // TODO: Deprecated ExtractContentEvent once we have entity API ready in next major release
                content = this.triggerPluginEvent(7 /* ExtractContent */, { content: clonedRoot.innerHTML }, true /*broadcast*/).content;
            }
            else if (range) {
                // range is not null, which means we want to include a selection path in the content
                content = roosterjs_editor_dom_1.getHtmlWithSelectionPath(clonedRoot, range);
            }
            else {
                content = clonedRoot.innerHTML;
            }
        }
        else {
            content = roosterjs_editor_dom_1.getHtmlWithSelectionPath(this.core.contentDiv, includeSelectionMarker && this.getSelectionRange());
        }
        return content;
    };
    /**
     * Get plain text content inside editor
     * @returns The text content inside editor
     */
    Editor.prototype.getTextContent = function () {
        return roosterjs_editor_dom_1.getTextContent(this.core.contentDiv);
    };
    /**
     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered
     * @param content HTML content to set in
     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true
     */
    Editor.prototype.setContent = function (content, triggerContentChangedEvent) {
        if (triggerContentChangedEvent === void 0) { triggerContentChangedEvent = true; }
        var contentDiv = this.core.contentDiv;
        var contentChanged = false;
        if (contentDiv.innerHTML != content) {
            var range = roosterjs_editor_dom_1.setHtmlWithSelectionPath(contentDiv, content);
            this.select(range);
            contentChanged = true;
        }
        // Convert content even if it hasn't changed.
        if (this.core.inDarkMode) {
            var darkModeOptions = this.getDarkModeOptions();
            var convertFunction = convertContentToDarkMode_1.convertContentToDarkMode(contentDiv, darkModeOptions && darkModeOptions.onExternalContentTransform
                ? darkModeOptions.onExternalContentTransform
                : undefined, true /* skipRootElement */);
            if (convertFunction) {
                convertFunction();
                contentChanged = true;
            }
        }
        if (triggerContentChangedEvent && contentChanged) {
            this.triggerContentChangedEvent();
        }
    };
    /**
     * Insert HTML content into editor
     * @param HTML content to insert
     * @param option Insert options. Default value is:
     *  position: ContentPosition.SelectionStart
     *  updateCursor: true
     *  replaceSelection: true
     *  insertOnNewLine: false
     */
    Editor.prototype.insertContent = function (content, option) {
        if (content) {
            var allNodes = roosterjs_editor_dom_1.fromHtml(content, this.core.document);
            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with
            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped
            // separately to show up on its own line
            if (option && option.insertOnNewLine && allNodes.length > 1) {
                allNodes = [roosterjs_editor_dom_1.wrap(allNodes)];
            }
            var fragment_1 = this.core.document.createDocumentFragment();
            allNodes.forEach(function (node) { return fragment_1.appendChild(node); });
            this.insertNode(fragment_1, option);
        }
    };
    /**
     * Paste into editor using a clipboardData object
     * @param clipboardData Clipboard data retrieved from clipboard
     * @param pasteAsText Force pasting as plain text. Default value is false
     * @param applyCurrentStyle True if apply format of current selection to the pasted content,
     * false to keep original foramt.  Default value is false. When pasteAsText is true, this parameter is ignored
     */
    Editor.prototype.paste = function (clipboardData, pasteAsText, applyCurrentFormat) {
        var _this = this;
        var range = this.getSelectionRange();
        var pos = range && roosterjs_editor_dom_1.Position.getStart(range);
        if (clipboardData && pos) {
            if (clipboardData.snapshotBeforePaste) {
                // Restore original content before paste a new one
                this.setContent(clipboardData.snapshotBeforePaste);
            }
            else {
                clipboardData.snapshotBeforePaste = this.getContent(false /*triggerExtractContentEvent*/, true /*includeSelectionMarker*/);
            }
            var fragment_2 = this.core.api.createPasteFragment(this.core, clipboardData, pos, pasteAsText, applyCurrentFormat);
            this.addUndoSnapshot(function () {
                _this.insertNode(fragment_2);
                return clipboardData;
            }, "Paste" /* Paste */);
        }
    };
    //#endregion
    //#region Focus and Selection
    /**
     * Get current selection range from Editor.
     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.
     * @returns current selection range, or null if editor never got focus before
     */
    Editor.prototype.getSelectionRange = function () {
        return this.core.api.getSelectionRange(this.core, true /*tryGetFromCache*/);
    };
    /**
     * Get current selection in a serializable format
     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.
     * @returns current selection path, or null if editor never got focus before
     */
    Editor.prototype.getSelectionPath = function () {
        var range = this.getSelectionRange();
        return range && roosterjs_editor_dom_1.getSelectionPath(this.core.contentDiv, range);
    };
    /**
     * Check if focus is in editor now
     * @returns true if focus is in editor, otherwise false
     */
    Editor.prototype.hasFocus = function () {
        return this.core.api.hasFocus(this.core);
    };
    /**
     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.
     */
    Editor.prototype.focus = function () {
        this.core.api.focus(this.core);
    };
    Editor.prototype.select = function (arg1, arg2, arg3, arg4) {
        var range = !arg1
            ? null
            : roosterjs_editor_dom_1.isRange(arg1)
                ? arg1
                : Array.isArray(arg1.start) && Array.isArray(arg1.end)
                    ? roosterjs_editor_dom_1.createRange(this.core.contentDiv, arg1.start, arg1.end)
                    : roosterjs_editor_dom_1.createRange(arg1, arg2, arg3, arg4);
        return this.contains(range) && this.core.api.selectRange(this.core, range);
    };
    /**
     * Get current selection
     * @return current selection object
     */
    Editor.prototype.getSelection = function () {
        return this.core.document.defaultView.getSelection();
    };
    /**
     * Save the current selection in editor so that when focus again, the selection can be restored
     */
    Editor.prototype.saveSelectionRange = function () {
        this.core.cachedSelectionRange = this.core.api.getSelectionRange(this.core, false /*tryGetFromCache*/);
    };
    /**
     * Restore the saved selection range and clear it
     */
    Editor.prototype.restoreSavedRange = function () {
        this.select(this.core.cachedSelectionRange);
        this.core.cachedSelectionRange = null;
    };
    /**
     * Get current focused position. Return null if editor doesn't have focus at this time.
     */
    Editor.prototype.getFocusedPosition = function () {
        var sel = this.getSelection();
        if (this.contains(sel && sel.focusNode)) {
            return new roosterjs_editor_dom_1.Position(sel.focusNode, sel.focusOffset);
        }
        var range = this.getSelectionRange();
        if (range) {
            return roosterjs_editor_dom_1.Position.getStart(range);
        }
        return null;
    };
    /**
     * Get a rect representing the location of the cursor.
     * @returns a Rect object representing cursor location
     */
    Editor.prototype.getCursorRect = function () {
        var position = this.getFocusedPosition();
        return position && roosterjs_editor_dom_1.getPositionRect(position);
    };
    /**
     * Get an HTML element from current cursor position.
     * When expectedTags is not specified, return value is the current node (if it is HTML element)
     * or its parent node (if current node is a Text node).
     * When expectedTags is specified, return value is the first anscestor of current node which has
     * one of the expected tags.
     * If no element found within editor by the given tag, return null.
     * @param selector Optional, an HTML selector to find HTML element with.
     * @param startFrom Start search from this node. If not specified, start from current focused position
     */
    Editor.prototype.getElementAtCursor = function (selector, startFrom) {
        if (!startFrom) {
            var position = this.getFocusedPosition();
            startFrom = position && position.node;
        }
        return startFrom && roosterjs_editor_dom_1.findClosestElementAncestor(startFrom, this.core.contentDiv, selector);
    };
    /**
     * Check if this position is at beginning of the editor.
     * This will return true if all nodes between the beginning of target node and the position are empty.
     * @param position The position to check
     * @returns True if position is at beginning of the editor, otherwise false
     */
    Editor.prototype.isPositionAtBeginning = function (position) {
        return roosterjs_editor_dom_1.isPositionAtBeginningOf(position, this.core.contentDiv);
    };
    /**
     * Get impacted regions from selection
     */
    Editor.prototype.getSelectedRegions = function (type) {
        if (type === void 0) { type = 0 /* Table */; }
        // Make sure there is a wrpper around cursor first, otherwise there will be no valid region
        this.core.corePlugins.typeInContainer.ensureTypeInElement(this.getFocusedPosition() || new roosterjs_editor_dom_1.Position(this.core.contentDiv, 0 /* Begin */));
        var range = this.getSelectionRange();
        return range ? roosterjs_editor_dom_1.getRegionsFromRange(this.core.contentDiv, range, type) : [];
    };
    Editor.prototype.addDomEventHandler = function (nameOrMap, handler) {
        var _this = this;
        if (nameOrMap instanceof Object) {
            var handlers_1 = Object.keys(nameOrMap)
                .map(function (eventName) {
                return nameOrMap[eventName] &&
                    _this.core.api.attachDomEvent(_this.core, eventName, null /*pluginEventType*/, nameOrMap[eventName]);
            })
                .filter(function (x) { return x; });
            return function () { return handlers_1.forEach(function (handler) { return handler(); }); };
        }
        else {
            return this.core.api.attachDomEvent(this.core, nameOrMap, null /*pluginEventType*/, handler);
        }
    };
    /**
     * Trigger an event to be dispatched to all plugins
     * @param eventType Type of the event
     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type
     * @param broadcast indicates if the event needs to be dispatched to all plugins
     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that
     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so
     * the result of this function provides a chance to read the modified result
     */
    Editor.prototype.triggerPluginEvent = function (eventType, data, broadcast) {
        var event = __assign({ eventType: eventType }, data);
        this.core.api.triggerEvent(this.core, event, broadcast);
        return event;
    };
    /**
     * @deprecated Use triggerPluginEvent instead
     */
    Editor.prototype.triggerEvent = function (pluginEvent, broadcast) {
        if (broadcast === void 0) { broadcast = true; }
        this.core.api.triggerEvent(this.core, pluginEvent, broadcast);
    };
    /**
     * Trigger a ContentChangedEvent
     * @param source Source of this event, by default is 'SetContent'
     * @param data additional data for this event
     */
    Editor.prototype.triggerContentChangedEvent = function (source, data) {
        if (source === void 0) { source = "SetContent" /* SetContent */; }
        this.triggerPluginEvent(6 /* ContentChanged */, {
            source: source,
            data: data,
        });
    };
    //#endregion
    //#region Undo API
    /**
     * Undo last edit operation
     */
    Editor.prototype.undo = function () {
        this.focus();
        this.core.corePlugins.undo.undo();
    };
    /**
     * Redo next edit operation
     */
    Editor.prototype.redo = function () {
        this.focus();
        this.core.corePlugins.undo.redo();
    };
    /**
     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger
     * ContentChangedEvent with given change source.
     * If this function is called nested, undo snapshot will only be added in the outside one
     * @param callback The callback function to perform formatting, returns a data object which will be used as
     * the data field in ContentChangedEvent if changeSource is not null.
     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,
     * a ContentChangedEvent will be fired with change source equal to this value
     */
    Editor.prototype.addUndoSnapshot = function (callback, changeSource) {
        this.core.api.editWithUndo(this.core, callback, changeSource);
    };
    /**
     * Perform an auto complete action in the callback, save a snapsnot of content before the action,
     * and trigger ContentChangedEvent with the change source if specified
     * @param callback The auto complete callback, return value will be used as data field of ContentChangedEvent
     * @param changeSource Chagne source of ContentChangedEvent. If not passed, no ContentChangedEvent will be  triggered
     */
    Editor.prototype.performAutoComplete = function (callback, changeSource) {
        this.core.corePlugins.edit.performAutoComplete(callback, changeSource);
    };
    /**
     * Whether there is an available undo snapshot
     */
    Editor.prototype.canUndo = function () {
        return this.core.corePlugins.undo.canUndo();
    };
    /**
     * Whether there is an available redo snapshot
     */
    Editor.prototype.canRedo = function () {
        return this.core.corePlugins.undo.canRedo();
    };
    //#endregion
    //#region Misc
    /**
     * Get document which contains this editor
     * @returns The HTML document which contains this editor
     */
    Editor.prototype.getDocument = function () {
        return this.core.document;
    };
    /**
     * Get the scroll container of the editor
     */
    Editor.prototype.getScrollContainer = function () {
        return this.core.scrollContainer;
    };
    /**
     * Get custom data related to this editor
     * @param key Key of the custom data
     * @param getter Getter function. If custom data for the given key doesn't exist,
     * call this function to get one and store it if it is specified. Otherwise return undefined
     * @param disposer An optional disposer function to dispose this custom data when
     * dispose editor.
     */
    Editor.prototype.getCustomData = function (key, getter, disposer) {
        return this.core.api.getCustomData(this.core, key, getter, disposer);
    };
    /**
     * Check if editor is in IME input sequence
     * @returns True if editor is in IME input sequence, otherwise false
     */
    Editor.prototype.isInIME = function () {
        return this.core.corePlugins.domEvent.isInIME();
    };
    /**
     * Get default format of this editor
     * @returns Default format object of this editor
     */
    Editor.prototype.getDefaultFormat = function () {
        return this.core.defaultFormat;
    };
    /**
     * Get a content traverser for the whole editor
     * @param startNode The node to start from. If not passed, it will start from the beginning of the body
     */
    Editor.prototype.getBodyTraverser = function (startNode) {
        return roosterjs_editor_dom_1.ContentTraverser.createBodyTraverser(this.core.contentDiv, startNode);
    };
    /**
     * Get a content traverser for current selection
     */
    Editor.prototype.getSelectionTraverser = function () {
        var range = this.getSelectionRange();
        return (range &&
            roosterjs_editor_dom_1.ContentTraverser.createSelectionTraverser(this.core.contentDiv, this.getSelectionRange()));
    };
    /**
     * Get a content traverser for current block element start from specified position
     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart
     */
    Editor.prototype.getBlockTraverser = function (startFrom) {
        if (startFrom === void 0) { startFrom = 3 /* SelectionStart */; }
        var range = this.getSelectionRange();
        return (range && roosterjs_editor_dom_1.ContentTraverser.createBlockTraverser(this.core.contentDiv, range, startFrom));
    };
    /**
     * Get a text traverser of current selection
     */
    Editor.prototype.getContentSearcherOfCursor = function () {
        var range = this.getSelectionRange();
        return range && new roosterjs_editor_dom_1.PositionContentSearcher(this.core.contentDiv, roosterjs_editor_dom_1.Position.getStart(range));
    };
    /**
     * Run a callback function asynchronously
     * @param callback The callback function to run
     */
    Editor.prototype.runAsync = function (callback) {
        var _this = this;
        var win = this.core.contentDiv.ownerDocument.defaultView || window;
        win.requestAnimationFrame(function () {
            if (!_this.isDisposed() && callback) {
                callback();
            }
        });
    };
    /**
     * Set DOM attribute of editor content DIV
     * @param name Name of the attribute
     * @param value Value of the attribute
     */
    Editor.prototype.setEditorDomAttribute = function (name, value) {
        if (value === null) {
            this.core.contentDiv.removeAttribute(name);
        }
        else {
            this.core.contentDiv.setAttribute(name, value);
        }
    };
    /**
     * get DOM attribute of editor content DIV
     * @param name Name of the attribute
     */
    Editor.prototype.getEditorDomAttribute = function (name) {
        return this.core.contentDiv.getAttribute(name);
    };
    /**
     * Add a Content Edit feature. This is mostly called from ContentEdit plugin
     * @param feature The feature to add
     */
    Editor.prototype.addContentEditFeature = function (feature) {
        this.core.corePlugins.edit.addFeature(feature);
    };
    /**
     * Get style based format state from current selection, including font name/size and colors
     */
    Editor.prototype.getStyleBasedFormatState = function (node) {
        if (!node) {
            var range = this.getSelectionRange();
            node = range && roosterjs_editor_dom_1.Position.getStart(range).normalize().node;
        }
        return this.core.api.getStyleBasedFormatState(this.core, node);
    };
    //#endregion
    //#region Dark mode APIs
    /**
     * Set the dark mode state and transforms the content to match the new state.
     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.
     */
    Editor.prototype.setDarkModeState = function (nextDarkMode) {
        if (this.isDarkMode() == nextDarkMode) {
            return;
        }
        var currentContent = this.getContent(undefined /* triggerContentChangedEvent */, true /* getSelectionMarker */);
        this.core.inDarkMode = nextDarkMode;
        this.core.defaultFormat = calculateDefaultFormat_1.calculateDefaultFormat(this.core.contentDiv, this.core.defaultFormat, this.core.inDarkMode);
        this.setContent(currentContent);
        this.triggerPluginEvent(14 /* DarkModeChanged */, {
            changedToDarkMode: nextDarkMode,
        });
    };
    /**
     * Check if the editor is in dark mode
     * @returns True if the editor is in dark mode, otherwise false
     */
    Editor.prototype.isDarkMode = function () {
        return this.core.inDarkMode;
    };
    /**
     * Returns the dark mode options set on the editor
     * @returns A DarkModeOptions object
     */
    Editor.prototype.getDarkModeOptions = function () {
        return this.core.darkModeOptions;
    };
    /**
     * Whether experiment features can be used
     */
    Editor.prototype.useExperimentFeatures = function () {
        return !!this.enableExperimentFeatures;
    };
    return Editor;
}());
exports.default = Editor;
//# sourceMappingURL=Editor.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/editor/adjustBrowserBehavior.js":
/*!********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/editor/adjustBrowserBehavior.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var COMMANDS = roosterjs_editor_dom_1.Browser.isFirefox
    ? (_a = {},
        /**
         * Disable these object resizing for firefox since other browsers don't have these behaviors
         */
        _a["enableObjectResizing" /* EnableObjectResizing */] = false,
        _a["enableInlineTableEditing" /* EnableInlineTableEditing */] = false,
        _a) : roosterjs_editor_dom_1.Browser.isIE
    ? (_b = {},
        /**
         * Change the default paragraph separater to DIV. This is mainly for IE since its default setting is P
         */
        _b["defaultParagraphSeparator" /* DefaultParagraphSeparator */] = 'div',
        /**
         * Disable auto link feature in IE since we have our own implementation
         */
        _b["AutoUrlDetect" /* AutoUrlDetect */] = false,
        _b) : {};
/**
 * Execute document command to adjust browser default behavior
 */
function adjustBrowserBehavior(document) {
    Object.keys(COMMANDS).forEach(function (command) {
        // Catch any possible exception since this should not block the initialization of editor
        try {
            document.execCommand(command, false, COMMANDS[command]);
        }
        catch (_a) { }
    });
}
exports.default = adjustBrowserBehavior;
//# sourceMappingURL=adjustBrowserBehavior.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/editor/createEditorCore.js":
/*!***************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/editor/createEditorCore.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var CopyPlugin_1 = __webpack_require__(/*! ../corePlugins/CopyPlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/CopyPlugin.js");
var CorePastePlugin_1 = __webpack_require__(/*! ../corePlugins/CorePastePlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/CorePastePlugin.js");
var DOMEventPlugin_1 = __webpack_require__(/*! ../corePlugins/DOMEventPlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.js");
var EditPlugin_1 = __webpack_require__(/*! ../corePlugins/EditPlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/EditPlugin.js");
var FirefoxTypeAfterLink_1 = __webpack_require__(/*! ../corePlugins/FirefoxTypeAfterLink */ "./node_modules/roosterjs-editor-core/lib/corePlugins/FirefoxTypeAfterLink.js");
var MouseUpPlugin_1 = __webpack_require__(/*! ../corePlugins/MouseUpPlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.js");
var TypeInContainerPlugin_1 = __webpack_require__(/*! ../corePlugins/TypeInContainerPlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.js");
var Undo_1 = __webpack_require__(/*! ../undo/Undo */ "./node_modules/roosterjs-editor-core/lib/undo/Undo.js");
var attachDomEvent_1 = __webpack_require__(/*! ../coreAPI/attachDomEvent */ "./node_modules/roosterjs-editor-core/lib/coreAPI/attachDomEvent.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var calculateDefaultFormat_1 = __webpack_require__(/*! ../coreAPI/calculateDefaultFormat */ "./node_modules/roosterjs-editor-core/lib/coreAPI/calculateDefaultFormat.js");
var createPasteFragment_1 = __webpack_require__(/*! ../coreAPI/createPasteFragment */ "./node_modules/roosterjs-editor-core/lib/coreAPI/createPasteFragment.js");
var editWithUndo_1 = __webpack_require__(/*! ../coreAPI/editWithUndo */ "./node_modules/roosterjs-editor-core/lib/coreAPI/editWithUndo.js");
var focus_1 = __webpack_require__(/*! ../coreAPI/focus */ "./node_modules/roosterjs-editor-core/lib/coreAPI/focus.js");
var getCustomData_1 = __webpack_require__(/*! ../coreAPI/getCustomData */ "./node_modules/roosterjs-editor-core/lib/coreAPI/getCustomData.js");
var getSelectionRange_1 = __webpack_require__(/*! ../coreAPI/getSelectionRange */ "./node_modules/roosterjs-editor-core/lib/coreAPI/getSelectionRange.js");
var getStyleBasedFormatState_1 = __webpack_require__(/*! ../coreAPI/getStyleBasedFormatState */ "./node_modules/roosterjs-editor-core/lib/coreAPI/getStyleBasedFormatState.js");
var hasFocus_1 = __webpack_require__(/*! ../coreAPI/hasFocus */ "./node_modules/roosterjs-editor-core/lib/coreAPI/hasFocus.js");
var insertNode_1 = __webpack_require__(/*! ../coreAPI/insertNode */ "./node_modules/roosterjs-editor-core/lib/coreAPI/insertNode.js");
var selectRange_1 = __webpack_require__(/*! ../coreAPI/selectRange */ "./node_modules/roosterjs-editor-core/lib/coreAPI/selectRange.js");
var triggerEvent_1 = __webpack_require__(/*! ../coreAPI/triggerEvent */ "./node_modules/roosterjs-editor-core/lib/coreAPI/triggerEvent.js");
/**
 * Create core object for editor
 * @param contentDiv The DIV element used for editor
 * @param options Options to create an editor
 */
function createEditorCore(contentDiv, options) {
    var corePlugins = {
        undo: options.undo || new Undo_1.default(),
        edit: new EditPlugin_1.default(),
        typeInContainer: new TypeInContainerPlugin_1.default(),
        mouseUp: new MouseUpPlugin_1.default(),
        domEvent: new DOMEventPlugin_1.default(options.disableRestoreSelectionOnFocus),
        firefoxTypeAfterLink: new FirefoxTypeAfterLink_1.default(),
        copyPlugin: !roosterjs_editor_dom_1.Browser.isIE && new CopyPlugin_1.default(),
        pastePlugin: new CorePastePlugin_1.default(),
    };
    var allPlugins = buildPluginList(corePlugins, options.plugins);
    var eventHandlerPlugins = allPlugins.filter(function (plugin) { return plugin.onPluginEvent || plugin.willHandleEventExclusively; });
    return {
        contentDiv: contentDiv,
        scrollContainer: options.scrollContainer || contentDiv,
        document: contentDiv.ownerDocument,
        defaultFormat: calculateDefaultFormat_1.calculateDefaultFormat(contentDiv, options.defaultFormat, options.inDarkMode),
        corePlugins: corePlugins,
        currentUndoSnapshot: null,
        customData: createCustomData(options.customData || {}),
        cachedSelectionRange: null,
        plugins: allPlugins,
        eventHandlerPlugins: eventHandlerPlugins,
        api: createCoreApiMap(options.coreApiOverride),
        defaultApi: createCoreApiMap(),
        inDarkMode: options.inDarkMode,
        darkModeOptions: options.darkModeOptions,
    };
}
exports.default = createEditorCore;
function buildPluginList(corePlugins, plugins) {
    return __spreadArrays([
        corePlugins.typeInContainer,
        corePlugins.edit,
        corePlugins.mouseUp
    ], (plugins || []), [
        corePlugins.firefoxTypeAfterLink,
        corePlugins.undo,
        corePlugins.domEvent,
        corePlugins.copyPlugin,
        corePlugins.pastePlugin,
    ]).filter(function (plugin) { return !!plugin; });
}
function createCoreApiMap(map) {
    map = map || {};
    return {
        attachDomEvent: map.attachDomEvent || attachDomEvent_1.attachDomEvent,
        editWithUndo: map.editWithUndo || editWithUndo_1.editWithUndo,
        focus: map.focus || focus_1.focus,
        getCustomData: map.getCustomData || getCustomData_1.getCustomData,
        getSelectionRange: map.getSelectionRange || getSelectionRange_1.getSelectionRange,
        getStyleBasedFormatState: map.getStyleBasedFormatState || getStyleBasedFormatState_1.getStyleBasedFormatState,
        hasFocus: map.hasFocus || hasFocus_1.hasFocus,
        insertNode: map.insertNode || insertNode_1.insertNode,
        createPasteFragment: map.createPasteFragment || createPasteFragment_1.createPasteFragment,
        select: map.select || selectRange_1.select,
        selectRange: map.selectRange || selectRange_1.selectRange,
        triggerEvent: map.triggerEvent || triggerEvent_1.triggerEvent,
    };
}
function createCustomData(initValue) {
    return Object.keys(initValue).reduce(function (result, key) {
        result[key] = {
            value: initValue[key],
        };
        return result;
    }, {});
}
//# sourceMappingURL=createEditorCore.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/editor/mapPluginEvents.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/editor/mapPluginEvents.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var EVENT_MAPPING = (_a = {
        keypress: 1 /* KeyPress */,
        keydown: 0 /* KeyDown */,
        keyup: 2 /* KeyUp */,
        mousedown: 4 /* MouseDown */
    },
    _a[roosterjs_editor_dom_1.Browser.isIE ? 'textinput' : 'input'] = 12 /* Input */,
    _a);
/**
 * Map DOM events to editor plugin events
 * @param core The EditorCore object
 */
function mapPluginEvents(core) {
    return Object.keys(EVENT_MAPPING).map(function (pluginEvent) {
        return core.api.attachDomEvent(core, pluginEvent, EVENT_MAPPING[pluginEvent]);
    });
}
exports.default = mapPluginEvents;
//# sourceMappingURL=mapPluginEvents.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetContentSearcher.js":
/*!************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetContentSearcher.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var cacheGetEventData_1 = __webpack_require__(/*! ./cacheGetEventData */ "./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetEventData.js");
var clearEventDataCache_1 = __webpack_require__(/*! ./clearEventDataCache */ "./node_modules/roosterjs-editor-core/lib/eventApi/clearEventDataCache.js");
var CONTENTSEARCHER_KEY = 'CONTENTSEARCHER';
/**
 * Try get existing PositionContentSearcher from an event. If there isn't one, create a new one from editor.
 * @param event The plugin event, it stores the event cached data for looking up.
 * If passed as null, we will create a new PositionContentSearcher
 * @param editor The editor instance
 * @returns The PositionContentSearcher object
 */
function cacheGetContentSearcher(event, editor) {
    return cacheGetEventData_1.default(event, CONTENTSEARCHER_KEY, function () { return editor.getContentSearcherOfCursor(); });
}
exports.cacheGetContentSearcher = cacheGetContentSearcher;
/**
 * Clear the PositionContentSearcher in a plugin event.
 * This is called when the content is changed
 * @param event The plugin event
 */
function clearContentSearcherCache(event) {
    clearEventDataCache_1.default(event, CONTENTSEARCHER_KEY);
}
exports.clearContentSearcherCache = clearContentSearcherCache;
//# sourceMappingURL=cacheGetContentSearcher.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetElementAtCursor.js":
/*!************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetElementAtCursor.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var cacheGetEventData_1 = __webpack_require__(/*! ./cacheGetEventData */ "./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetEventData.js");
var CACHE_KEY_PREFIX = 'GET_ELEMENT_AT_CURSOR_';
/**
 * Get an HTML element at cursor from event cache if it exists.
 * If an selector is specified, return the nearest ancestor of current node
 * which matches the selector, or null if no match found in editor.
 * @param editor The editor instance
 * @param event Event object to get cached object from
 * @param selector The expected selector. If null, return the element at cursor
 * @returns The element at cursor or the nearest ancestor with the tag name is specified
 */
function cacheGetElementAtCursor(editor, event, selector) {
    return cacheGetEventData_1.default(event, CACHE_KEY_PREFIX + selector, function () {
        return editor.getElementAtCursor(selector);
    });
}
exports.default = cacheGetElementAtCursor;
//# sourceMappingURL=cacheGetElementAtCursor.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetEventData.js":
/*!******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetEventData.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Gets the cached event data by cache key from event object if there is already one.
 * Otherwise, call getter function to create one, and cache it.
 * @param event The event object
 * @param key Cache key string, need to be unique
 * @param getter Getter function to get the object when it is not in cache yet
 */
function cacheGetEventData(event, key, getter) {
    var result = event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)
        ? event.eventDataCache[key]
        : getter();
    if (event) {
        event.eventDataCache = event.eventDataCache || {};
        event.eventDataCache[key] = result;
    }
    return result;
}
exports.default = cacheGetEventData;
//# sourceMappingURL=cacheGetEventData.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/eventApi/clearEventDataCache.js":
/*!********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/eventApi/clearEventDataCache.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Clear a cached object by its key from an event object
 * @param event The event object
 * @param key The cache key
 */
function clearEventDataCache(event, key) {
    if (event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)) {
        delete event.eventDataCache[key];
    }
}
exports.default = clearEventDataCache;
//# sourceMappingURL=clearEventDataCache.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/eventApi/isCharacterValue.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/eventApi/isCharacterValue.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isModifierKey_1 = __webpack_require__(/*! ./isModifierKey */ "./node_modules/roosterjs-editor-core/lib/eventApi/isModifierKey.js");
/**
 * Returns true when the event was fired from a key that produces a character value, otherwise false
 * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),
 * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.
 * So if we missed some case here it is still acceptable.
 * @param event The keyboard event object
 */
function isCharacterValue(event) {
    return !isModifierKey_1.default(event) && event.key && event.key.length == 1;
}
exports.default = isCharacterValue;
//# sourceMappingURL=isCharacterValue.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/eventApi/isCtrlOrMetaPressed.js":
/*!********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/eventApi/isCtrlOrMetaPressed.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Check if Ctrl key (Windows) or Meta key (Mac) is pressed for the given Event
 * @param event A Keyboard event or Mouse event object
 * @returns True if Ctrl key is pressed on Windows or Meta key is pressed on Mac
 */
var isCtrlOrMetaPressed = roosterjs_editor_dom_1.Browser.isMac
    ? function (event) { return event.metaKey; }
    : function (event) { return event.ctrlKey; };
exports.default = isCtrlOrMetaPressed;
//# sourceMappingURL=isCtrlOrMetaPressed.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/eventApi/isModifierKey.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/eventApi/isModifierKey.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CTRL_CHARCODE = 'Control';
var ALT_CHARCODE = 'Alt';
var META_CHARCODE = 'Meta';
/**
 * Returns true when the event was fired from a modifier key, otherwise false
 * @param event The keyboard event object
 */
function isModifierKey(event) {
    var isCtrlKey = event.ctrlKey || event.key === CTRL_CHARCODE;
    var isAltKey = event.altKey || event.key === ALT_CHARCODE;
    var isMetaKey = event.metaKey || event.key === META_CHARCODE;
    return isCtrlKey || isAltKey || isMetaKey;
}
exports.default = isModifierKey;
//# sourceMappingURL=isModifierKey.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// Interfaces
var ContentEditFeature_1 = __webpack_require__(/*! ./interfaces/ContentEditFeature */ "./node_modules/roosterjs-editor-core/lib/interfaces/ContentEditFeature.js");
exports.Keys = ContentEditFeature_1.Keys;
// Classes
var Editor_1 = __webpack_require__(/*! ./editor/Editor */ "./node_modules/roosterjs-editor-core/lib/editor/Editor.js");
exports.Editor = Editor_1.default;
var Undo_1 = __webpack_require__(/*! ./undo/Undo */ "./node_modules/roosterjs-editor-core/lib/undo/Undo.js");
exports.Undo = Undo_1.default;
// Core Plugins
var EditPlugin_1 = __webpack_require__(/*! ./corePlugins/EditPlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/EditPlugin.js");
exports.EditPlugin = EditPlugin_1.default;
var MouseUpPlugin_1 = __webpack_require__(/*! ./corePlugins/MouseUpPlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.js");
exports.MouseUpPlugin = MouseUpPlugin_1.default;
var DOMEventPlugin_1 = __webpack_require__(/*! ./corePlugins/DOMEventPlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.js");
exports.DOMEventPlugin = DOMEventPlugin_1.default;
var TypeInContainerPlugin_1 = __webpack_require__(/*! ./corePlugins/TypeInContainerPlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.js");
exports.TypeInContainerPlugin = TypeInContainerPlugin_1.default;
var FirefoxTypeAfterLink_1 = __webpack_require__(/*! ./corePlugins/FirefoxTypeAfterLink */ "./node_modules/roosterjs-editor-core/lib/corePlugins/FirefoxTypeAfterLink.js");
exports.FirefoxTypeAfterLink = FirefoxTypeAfterLink_1.default;
var CopyPlugin_1 = __webpack_require__(/*! ./corePlugins/CopyPlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/CopyPlugin.js");
exports.CopyPlugin = CopyPlugin_1.default;
var CorePastePlugin_1 = __webpack_require__(/*! ./corePlugins/CorePastePlugin */ "./node_modules/roosterjs-editor-core/lib/corePlugins/CorePastePlugin.js");
exports.CorePastePlugin = CorePastePlugin_1.default;
// Event APIs
var cacheGetEventData_1 = __webpack_require__(/*! ./eventApi/cacheGetEventData */ "./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetEventData.js");
exports.cacheGetEventData = cacheGetEventData_1.default;
var clearEventDataCache_1 = __webpack_require__(/*! ./eventApi/clearEventDataCache */ "./node_modules/roosterjs-editor-core/lib/eventApi/clearEventDataCache.js");
exports.clearEventDataCache = clearEventDataCache_1.default;
var cacheGetContentSearcher_1 = __webpack_require__(/*! ./eventApi/cacheGetContentSearcher */ "./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetContentSearcher.js");
exports.cacheGetContentSearcher = cacheGetContentSearcher_1.cacheGetContentSearcher;
exports.clearContentSearcherCache = cacheGetContentSearcher_1.clearContentSearcherCache;
var cacheGetElementAtCursor_1 = __webpack_require__(/*! ./eventApi/cacheGetElementAtCursor */ "./node_modules/roosterjs-editor-core/lib/eventApi/cacheGetElementAtCursor.js");
exports.cacheGetElementAtCursor = cacheGetElementAtCursor_1.default;
var isModifierKey_1 = __webpack_require__(/*! ./eventApi/isModifierKey */ "./node_modules/roosterjs-editor-core/lib/eventApi/isModifierKey.js");
exports.isModifierKey = isModifierKey_1.default;
var isCharacterValue_1 = __webpack_require__(/*! ./eventApi/isCharacterValue */ "./node_modules/roosterjs-editor-core/lib/eventApi/isCharacterValue.js");
exports.isCharacterValue = isCharacterValue_1.default;
var isCtrlOrMetaPressed_1 = __webpack_require__(/*! ./eventApi/isCtrlOrMetaPressed */ "./node_modules/roosterjs-editor-core/lib/eventApi/isCtrlOrMetaPressed.js");
exports.isCtrlOrMetaPressed = isCtrlOrMetaPressed_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/interfaces/ContentEditFeature.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/interfaces/ContentEditFeature.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Key numbers used for ContentEditFeature
 */
var Keys;
(function (Keys) {
    Keys[Keys["NULL"] = 0] = "NULL";
    Keys[Keys["BACKSPACE"] = 8] = "BACKSPACE";
    Keys[Keys["TAB"] = 9] = "TAB";
    Keys[Keys["ENTER"] = 13] = "ENTER";
    Keys[Keys["ESCAPE"] = 27] = "ESCAPE";
    Keys[Keys["SPACE"] = 32] = "SPACE";
    Keys[Keys["LEFT"] = 37] = "LEFT";
    Keys[Keys["UP"] = 38] = "UP";
    Keys[Keys["RIGHT"] = 39] = "RIGHT";
    Keys[Keys["DOWN"] = 40] = "DOWN";
    Keys[Keys["DELETE"] = 46] = "DELETE";
    Keys[Keys["EIGHT_ASTIRISK"] = 56] = "EIGHT_ASTIRISK";
    Keys[Keys["B"] = 66] = "B";
    Keys[Keys["I"] = 73] = "I";
    Keys[Keys["U"] = 85] = "U";
    Keys[Keys["Y"] = 89] = "Y";
    Keys[Keys["Z"] = 90] = "Z";
    Keys[Keys["COMMA"] = 188] = "COMMA";
    Keys[Keys["DASH_UNDERSCORE"] = 189] = "DASH_UNDERSCORE";
    Keys[Keys["PERIOD"] = 190] = "PERIOD";
    Keys[Keys["FORWARDSLASH"] = 191] = "FORWARDSLASH";
    Keys[Keys["GRAVE_TILDE"] = 192] = "GRAVE_TILDE";
    Keys[Keys["Ctrl"] = 256] = "Ctrl";
    Keys[Keys["Meta"] = 512] = "Meta";
    Keys[Keys["Shift"] = 1024] = "Shift";
    Keys[Keys["CONTENTCHANGED"] = 2048] = "CONTENTCHANGED";
    Keys[Keys["MOUSEDOWN"] = 4096] = "MOUSEDOWN";
})(Keys = exports.Keys || (exports.Keys = {}));
//# sourceMappingURL=ContentEditFeature.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/undo/Undo.js":
/*!*************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/undo/Undo.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isCtrlOrMetaPressed_1 = __webpack_require__(/*! ../eventApi/isCtrlOrMetaPressed */ "./node_modules/roosterjs-editor-core/lib/eventApi/isCtrlOrMetaPressed.js");
var UndoSnapshots_1 = __webpack_require__(/*! ./UndoSnapshots */ "./node_modules/roosterjs-editor-core/lib/undo/UndoSnapshots.js");
var KEY_BACKSPACE = 8;
var KEY_DELETE = 46;
var KEY_SPACE = 32;
var KEY_ENTER = 13;
var KEY_PAGEUP = 33;
var KEY_DOWN = 40;
/**
 * Provides snapshot based undo service for Editor
 */
var Undo = /** @class */ (function () {
    /**
     * Create an instance of Undo
     * @param preserveSnapshots True to preserve the snapshots after dispose, this allows
     * this object to be reused when editor is disposed and created again
     * @param maxBufferSize The max buffer size for snapshots. Default value is 10MB
     */
    function Undo(preserveSnapshots, maxBufferSize) {
        if (maxBufferSize === void 0) { maxBufferSize = 1e7; }
        this.preserveSnapshots = preserveSnapshots;
        this.maxBufferSize = maxBufferSize;
    }
    /**
     * Get a friendly name of  this plugin
     */
    Undo.prototype.getName = function () {
        return 'Undo';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    Undo.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    /**
     * Dispose this plugin
     */
    Undo.prototype.dispose = function () {
        this.editor = null;
        if (!this.preserveSnapshots) {
            this.clear();
        }
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    Undo.prototype.onPluginEvent = function (event) {
        // if editor is in IME, don't do anything
        if (this.editor.isInIME()) {
            return;
        }
        switch (event.eventType) {
            case 10 /* EditorReady */:
                if (!this.preserveSnapshots || (!this.canUndo() && !this.canRedo())) {
                    // Only add initial snapshot when we don't need to preserve snapshots or there is no existing snapshot
                    // Otherwise preserved undo/redo state may be ruined
                    this.addUndoSnapshot();
                }
                break;
            case 0 /* KeyDown */:
                this.onKeyDown(event.rawEvent);
                break;
            case 1 /* KeyPress */:
                this.onKeyPress(event.rawEvent);
                break;
            case 3 /* CompositionEnd */:
                this.clearRedoForInput();
                this.addUndoSnapshot();
                break;
            case 6 /* ContentChanged */:
                if (!this.isRestoring) {
                    this.clearRedoForInput();
                }
                break;
        }
    };
    /**
     * Clear all existing undo snapshots
     */
    Undo.prototype.clear = function () {
        this.undoSnapshots = null;
        this.hasNewContent = false;
    };
    /**
     * Restore an undo snapshot to editor
     */
    Undo.prototype.undo = function () {
        if (this.hasNewContent) {
            this.addUndoSnapshot();
        }
        this.restoreSnapshot(-1 /*previousSnapshot*/);
    };
    /**
     * Restore a redo snapshot to editor
     */
    Undo.prototype.redo = function () {
        this.restoreSnapshot(1 /*nextSnapshot*/);
    };
    /**
     * Whether there is a snapshot for undo
     */
    Undo.prototype.canUndo = function () {
        return this.hasNewContent || this.getSnapshotsManager().canMove(-1 /*previousSnapshot*/);
    };
    /**
     * Whether there is a snapshot for redo
     */
    Undo.prototype.canRedo = function () {
        return this.getSnapshotsManager().canMove(1 /*nextSnapshot*/);
    };
    /**
     * Add an undo snapshot
     */
    Undo.prototype.addUndoSnapshot = function () {
        var snapshot = this.editor.getContent(false /*triggerExtractContentEvent*/, true /* includeSelectionMarker */);
        this.getSnapshotsManager().addSnapshot(snapshot);
        this.hasNewContent = false;
        return snapshot;
    };
    Undo.prototype.getSnapshotsManager = function () {
        if (!this.undoSnapshots) {
            this.undoSnapshots = new UndoSnapshots_1.default(this.maxBufferSize);
        }
        return this.undoSnapshots;
    };
    Undo.prototype.restoreSnapshot = function (delta) {
        var snapshot = this.getSnapshotsManager().move(delta);
        if (snapshot != null) {
            try {
                this.isRestoring = true;
                this.editor.setContent(snapshot);
            }
            finally {
                this.isRestoring = false;
            }
        }
    };
    Undo.prototype.onKeyDown = function (evt) {
        // Handle backspace/delete when there is a selection to take a snapshot
        // since we want the state prior to deletion restorable
        if (evt.which == KEY_BACKSPACE || evt.which == KEY_DELETE) {
            var selectionRange = this.editor.getSelectionRange();
            // Add snapshot when
            // 1. Something has been selected (not collapsed), or
            // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or
            // 3. Ctrl/Meta key is pressed so that a whole word will be deleted
            if (selectionRange &&
                (!selectionRange.collapsed ||
                    this.lastKeyPress != evt.which ||
                    isCtrlOrMetaPressed_1.default(evt))) {
                this.addUndoSnapshot();
            }
            // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time
            this.hasNewContent = true;
            this.lastKeyPress = evt.which;
        }
        else if (evt.which >= KEY_PAGEUP && evt.which <= KEY_DOWN) {
            // PageUp, PageDown, Home, End, Left, Right, Up, Down
            if (this.hasNewContent) {
                this.addUndoSnapshot();
            }
            this.lastKeyPress = 0;
        }
    };
    Undo.prototype.onKeyPress = function (evt) {
        if (evt.metaKey) {
            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.
            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.
            return;
        }
        var range = this.editor.getSelectionRange();
        if ((range && !range.collapsed) ||
            (evt.which == KEY_SPACE && this.lastKeyPress != KEY_SPACE) ||
            evt.which == KEY_ENTER) {
            this.addUndoSnapshot();
            if (evt.which == KEY_ENTER) {
                // Treat ENTER as new content so if there is no input after ENTER and undo,
                // we restore the snapshot before ENTER
                this.hasNewContent = true;
            }
        }
        else {
            this.clearRedoForInput();
        }
        this.lastKeyPress = evt.which;
    };
    Undo.prototype.clearRedoForInput = function () {
        this.getSnapshotsManager().clearRedo();
        this.lastKeyPress = 0;
        this.hasNewContent = true;
    };
    return Undo;
}());
exports.default = Undo;
//# sourceMappingURL=Undo.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-core/lib/undo/UndoSnapshots.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-core/lib/undo/UndoSnapshots.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped
// to keep size under limit. This is kept at 10MB
var MAXSIZELIMIT = 1e7;
/**
 * A class to help manage undo snapshots
 */
var UndoSnapshots = /** @class */ (function () {
    function UndoSnapshots(maxSize) {
        if (maxSize === void 0) { maxSize = MAXSIZELIMIT; }
        this.maxSize = maxSize;
        this.snapshots = roosterjs_editor_dom_1.createSnapshots(maxSize);
    }
    /**
     * Check whether can move current undo snapshot with the given step
     * @param step The step to check, can be positive, negative or 0
     * @returns True if can move current snapshot with the given step, otherwise false
     */
    UndoSnapshots.prototype.canMove = function (delta) {
        return roosterjs_editor_dom_1.canMoveCurrentSnapshot(this.snapshots, delta);
    };
    /**
     * Move current snapshot with the given step if can move this step. Otherwise no action and return null
     * @param step The step to move
     * @returns If can move with the given step, returns the snapshot after move, otherwise null
     */
    UndoSnapshots.prototype.move = function (delta) {
        return roosterjs_editor_dom_1.moveCurrentSnapsnot(this.snapshots, delta);
    };
    /**
     * Add a new undo snapshot
     * @param snapshot The snapshot to add
     */
    UndoSnapshots.prototype.addSnapshot = function (snapshot) {
        roosterjs_editor_dom_1.addSnapshot(this.snapshots, snapshot);
    };
    /**
     * Clear all undo snapshots after the current one
     */
    UndoSnapshots.prototype.clearRedo = function () {
        roosterjs_editor_dom_1.clearProceedingSnapshots(this.snapshots);
    };
    return UndoSnapshots;
}());
exports.default = UndoSnapshots;
//# sourceMappingURL=UndoSnapshots.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = __webpack_require__(/*! ../utils/contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
var isNodeAfter_1 = __webpack_require__(/*! ../utils/isNodeAfter */ "./node_modules/roosterjs-editor-dom/lib/utils/isNodeAfter.js");
/**
 * This presents a content block that can be reprented by a single html block type element.
 * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.
 */
var NodeBlockElement = /** @class */ (function () {
    function NodeBlockElement(element) {
        this.element = element;
    }
    /**
     * Collapse this element to a single DOM element.
     * If the content nodes are separated in different root nodes, wrap them to a single node
     * If the content nodes are included in root node with other nodes, split root node
     */
    NodeBlockElement.prototype.collapseToSingleElement = function () {
        return this.element;
    };
    /**
     * Get the start node of the block
     * For NodeBlockElement, start and end essentially refers to same node
     */
    NodeBlockElement.prototype.getStartNode = function () {
        return this.element;
    };
    /**
     * Get the end node of the block
     * For NodeBlockElement, start and end essentially refers to same node
     */
    NodeBlockElement.prototype.getEndNode = function () {
        return this.element;
    };
    /**
     * Checks if it refers to same block
     */
    NodeBlockElement.prototype.equals = function (blockElement) {
        // Ideally there is only one unique way to generate a block so we only need to compare the startNode
        return this.element == blockElement.getStartNode();
    };
    /**
     * Checks if a block is after the current block
     */
    NodeBlockElement.prototype.isAfter = function (blockElement) {
        // if the block's startNode is after current node endEnd, we say it is after
        return isNodeAfter_1.default(this.element, blockElement.getEndNode());
    };
    /**
     * Checks if a certain html node is within the block
     */
    NodeBlockElement.prototype.contains = function (node) {
        return contains_1.default(this.element, node, true /*treatSameNodeAsContain*/);
    };
    /**
     * Get the text content of this block element
     */
    NodeBlockElement.prototype.getTextContent = function () {
        return this.element ? this.element.textContent : '';
    };
    return NodeBlockElement;
}());
exports.default = NodeBlockElement;
//# sourceMappingURL=NodeBlockElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var collapseNodes_1 = __webpack_require__(/*! ../utils/collapseNodes */ "./node_modules/roosterjs-editor-dom/lib/utils/collapseNodes.js");
var contains_1 = __webpack_require__(/*! ../utils/contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
var createRange_1 = __webpack_require__(/*! ../selection/createRange */ "./node_modules/roosterjs-editor-dom/lib/selection/createRange.js");
var getTagOfNode_1 = __webpack_require__(/*! ../utils/getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var isBlockElement_1 = __webpack_require__(/*! ../utils/isBlockElement */ "./node_modules/roosterjs-editor-dom/lib/utils/isBlockElement.js");
var isNodeAfter_1 = __webpack_require__(/*! ../utils/isNodeAfter */ "./node_modules/roosterjs-editor-dom/lib/utils/isNodeAfter.js");
var wrap_1 = __webpack_require__(/*! ../utils/wrap */ "./node_modules/roosterjs-editor-dom/lib/utils/wrap.js");
var splitParentNode_1 = __webpack_require__(/*! ../utils/splitParentNode */ "./node_modules/roosterjs-editor-dom/lib/utils/splitParentNode.js");
var STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];
/**
 * This reprents a block that is identified by a start and end node
 * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;
 * in that case, Hello&lt;BR&gt; is a block, World is another block
 * Such block cannot be represented by a NodeBlockElement since they don't chained up
 * to a single parent node, instead they have a start and end
 * This start and end must be in same sibling level and have same parent in DOM tree
 */
var StartEndBlockElement = /** @class */ (function () {
    function StartEndBlockElement(rootNode, startNode, endNode) {
        this.rootNode = rootNode;
        this.startNode = startNode;
        this.endNode = endNode;
    }
    StartEndBlockElement.getBlockContext = function (node) {
        while (node && !isBlockElement_1.default(node)) {
            node = node.parentNode;
        }
        return node;
    };
    /**
     * Collapse this element to a single DOM element.
     * If the content nodes are separated in different root nodes, wrap them to a single node
     * If the content nodes are included in root node with other nodes, split root node
     */
    StartEndBlockElement.prototype.collapseToSingleElement = function () {
        var nodes = collapseNodes_1.default(StartEndBlockElement.getBlockContext(this.startNode), this.startNode, this.endNode, true /*canSplitParent*/);
        var blockContext = StartEndBlockElement.getBlockContext(this.startNode);
        while (nodes[0] &&
            nodes[0] != blockContext &&
            nodes[0].parentNode != this.rootNode &&
            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode_1.default(nodes[0].parentNode)) < 0) {
            nodes = [splitParentNode_1.splitBalancedNodeRange(nodes)];
        }
        return nodes.length == 1 && isBlockElement_1.default(nodes[0])
            ? nodes[0]
            : wrap_1.default(nodes);
    };
    /**
     * Gets the start node
     */
    StartEndBlockElement.prototype.getStartNode = function () {
        return this.startNode;
    };
    /**
     * Gets the end node
     */
    StartEndBlockElement.prototype.getEndNode = function () {
        return this.endNode;
    };
    /**
     * Checks equals of two blocks
     */
    StartEndBlockElement.prototype.equals = function (blockElement) {
        return (this.startNode == blockElement.getStartNode() &&
            this.endNode == blockElement.getEndNode());
    };
    /**
     * Checks if another block is after this current
     */
    StartEndBlockElement.prototype.isAfter = function (blockElement) {
        return isNodeAfter_1.default(this.getStartNode(), blockElement.getEndNode());
    };
    /**
     * Checks if an Html node is contained within the block
     */
    StartEndBlockElement.prototype.contains = function (node) {
        return (contains_1.default(this.startNode, node, true /*treatSameNodeAsContain*/) ||
            contains_1.default(this.endNode, node, true /*treatSameNodeAsContain*/) ||
            (isNodeAfter_1.default(node, this.startNode) && isNodeAfter_1.default(this.endNode, node)));
    };
    /**
     * Get the text content of this block element
     */
    StartEndBlockElement.prototype.getTextContent = function () {
        var range = createRange_1.default(this.getStartNode(), this.getEndNode());
        return range ? range.toString() : '';
    };
    return StartEndBlockElement;
}());
exports.default = StartEndBlockElement;
//# sourceMappingURL=StartEndBlockElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var collapseNodes_1 = __webpack_require__(/*! ../utils/collapseNodes */ "./node_modules/roosterjs-editor-dom/lib/utils/collapseNodes.js");
var contains_1 = __webpack_require__(/*! ../utils/contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
var getTagOfNode_1 = __webpack_require__(/*! ../utils/getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var isBlockElement_1 = __webpack_require__(/*! ../utils/isBlockElement */ "./node_modules/roosterjs-editor-dom/lib/utils/isBlockElement.js");
var NodeBlockElement_1 = __webpack_require__(/*! ./NodeBlockElement */ "./node_modules/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.js");
var StartEndBlockElement_1 = __webpack_require__(/*! ./StartEndBlockElement */ "./node_modules/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.js");
/**
 * This produces a block element from a a node
 * It needs to account for various HTML structure. Examples:
 * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;
 *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;
 * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;
 *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;
 * 3) &lt;root&gt;abc&lt;/root&gt;
 *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc
 *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node
 * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;
 *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:
 *   block1: 1) abc&lt;br&gt; block2: 123
 * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;
 *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;
 * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;
 *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;
 *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456
 * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:
 * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered
 * 2) same for identifying tail
 * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node
 * @param rootNode Root node of the scope, the block element will be inside of this node
 * @param node The node to get BlockElement start from
 */
function getBlockElementAtNode(rootNode, node) {
    if (!contains_1.default(rootNode, node)) {
        return null;
    }
    // Identify the containing block. This serves as ceiling for traversing down below
    // NOTE: this container block could be just the rootNode,
    // which cannot be used to create block element. We will special case handle it later on
    var containerBlockNode = StartEndBlockElement_1.default.getBlockContext(node);
    if (containerBlockNode == node) {
        return new NodeBlockElement_1.default(containerBlockNode);
    }
    // Find the head and leaf node in the block
    var headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);
    var tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);
    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to
    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;
    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style="font-family: Arial"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world
    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block
    // So we shall try to collapse as much as we can to the nearest common ancester
    var nodes = collapseNodes_1.default(rootNode, headNode, tailNode, false /*canSplitParent*/);
    headNode = nodes[0];
    tailNode = nodes[nodes.length - 1];
    if (headNode.parentNode != tailNode.parentNode) {
        // Un-Balanced start and end, create a start-end block
        return new StartEndBlockElement_1.default(rootNode, headNode, tailNode);
    }
    else {
        // Balanced start and end (point to same parent), need to see if further collapsing can be done
        while (!headNode.previousSibling && !tailNode.nextSibling) {
            var parentNode = headNode.parentNode;
            if (parentNode == containerBlockNode) {
                // Has reached the container block
                if (containerBlockNode != rootNode) {
                    // If the container block is not the root, use the container block
                    headNode = tailNode = parentNode;
                }
                break;
            }
            else {
                // Continue collapsing to parent
                headNode = tailNode = parentNode;
            }
        }
        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block
        return headNode == tailNode && isBlockElement_1.default(headNode)
            ? new NodeBlockElement_1.default(headNode)
            : new StartEndBlockElement_1.default(rootNode, headNode, tailNode);
    }
}
exports.default = getBlockElementAtNode;
/**
 * Given a node and container block, identify the first/last leaf node
 * A leaf node is defined as deepest first/last node in a block
 * i.e. &lt;div&gt;&lt;span style="font-family: Arial"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block
 * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf
 * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;
 * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;
 */
function findHeadTailLeafNode(node, containerBlockNode, isTail) {
    var result = node;
    if (getTagOfNode_1.default(result) == 'BR' && isTail) {
        return result;
    }
    while (result) {
        var sibling = node;
        while (!(sibling = isTail ? node.nextSibling : node.previousSibling)) {
            node = node.parentNode;
            if (node == containerBlockNode) {
                return result;
            }
        }
        while (sibling) {
            if (isBlockElement_1.default(sibling)) {
                return result;
            }
            else if (getTagOfNode_1.default(sibling) == 'BR') {
                return isTail ? sibling : result;
            }
            node = sibling;
            sibling = isTail ? node.firstChild : node.lastChild;
        }
        result = node;
    }
    return result;
}
//# sourceMappingURL=getBlockElementAtNode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getBlockElementAtNode_1 = __webpack_require__(/*! ./getBlockElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.js");
/**
 * Get the first/last BlockElement of under the root node.
 * If no suitable BlockElement found, returns null
 * @param rootNode The root node to get BlockElement from
 * @param isFirst True to get first BlockElement, false to get last BlockElement
 */
function getFirstLastBlockElement(rootNode, isFirst) {
    var node = rootNode;
    do {
        node = node && (isFirst ? node.firstChild : node.lastChild);
    } while (node && node.firstChild);
    return node && getBlockElementAtNode_1.default(rootNode, node);
}
exports.default = getFirstLastBlockElement;
/**
 * Get the first BlockElement of under the root node.
 * If no suitable BlockElement found, returns null
 * @param rootNode The root node to get BlockElement from
 */
function getFirstBlockElement(rootNode) {
    return getFirstLastBlockElement(rootNode, true /*isFirst*/);
}
exports.getFirstBlockElement = getFirstBlockElement;
/**
 * Get the last BlockElement of under the root node.
 * If no suitable BlockElement found, returns null
 * @param rootNode The root node to get BlockElement from
 */
function getLastBlockElement(rootNode) {
    return getFirstLastBlockElement(rootNode, false /*isFirst*/);
}
exports.getLastBlockElement = getLastBlockElement;
//# sourceMappingURL=getFirstLastBlockElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.js":
/*!******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = __webpack_require__(/*! ../utils/contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
var getBlockElementAtNode_1 = __webpack_require__(/*! ../blockElements/getBlockElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.js");
var getInlineElementAtNode_1 = __webpack_require__(/*! ../inlineElements/getInlineElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.js");
var getFirstLastBlockElement_1 = __webpack_require__(/*! ../blockElements/getFirstLastBlockElement */ "./node_modules/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.js");
var getFirstLastInlineElement_1 = __webpack_require__(/*! ../inlineElements/getFirstLastInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.js");
/**
 * provides scoper for traversing the entire editor body starting from the beginning
 */
var BodyScoper = /** @class */ (function () {
    /**
     * Construct a new instance of BodyScoper class
     * @param rootNode Root node of the body
     * @param startNode The node to start from. If not passed, it will start from the beginning of the body
     */
    function BodyScoper(rootNode, startNode) {
        this.rootNode = rootNode;
        this.startNode = contains_1.default(rootNode, startNode) ? startNode : null;
    }
    /**
     * Get the start block element
     */
    BodyScoper.prototype.getStartBlockElement = function () {
        return this.startNode
            ? getBlockElementAtNode_1.default(this.rootNode, this.startNode)
            : getFirstLastBlockElement_1.getFirstBlockElement(this.rootNode);
    };
    /**
     * Get the start inline element
     */
    BodyScoper.prototype.getStartInlineElement = function () {
        return this.startNode
            ? getInlineElementAtNode_1.default(this.rootNode, this.startNode)
            : getFirstLastInlineElement_1.getFirstInlineElement(this.rootNode);
    };
    /**
     * Since the scope is global, all blocks under the root node are in scope
     */
    BodyScoper.prototype.isBlockInScope = function (blockElement) {
        return contains_1.default(this.rootNode, blockElement.getStartNode());
    };
    /**
     * Since we're at body scope, inline elements never need to be trimmed
     */
    BodyScoper.prototype.trimInlineElement = function (inlineElement) {
        return inlineElement;
    };
    return BodyScoper;
}());
exports.default = BodyScoper;
//# sourceMappingURL=BodyScoper.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.js":
/*!************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BodyScoper_1 = __webpack_require__(/*! ./BodyScoper */ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.js");
var EmptyInlineElement_1 = __webpack_require__(/*! ../inlineElements/EmptyInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.js");
var getBlockElementAtNode_1 = __webpack_require__(/*! ../blockElements/getBlockElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.js");
var getInlineElementAtNode_1 = __webpack_require__(/*! ../inlineElements/getInlineElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.js");
var PartialInlineElement_1 = __webpack_require__(/*! ../inlineElements/PartialInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.js");
var SelectionBlockScoper_1 = __webpack_require__(/*! ./SelectionBlockScoper */ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.js");
var SelectionScoper_1 = __webpack_require__(/*! ./SelectionScoper */ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.js");
var getInlineElementBeforeAfter_1 = __webpack_require__(/*! ../inlineElements/getInlineElementBeforeAfter */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.js");
var getLeafSibling_1 = __webpack_require__(/*! ../utils/getLeafSibling */ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafSibling.js");
/**
 * The provides traversing of content inside editor.
 * There are two ways to traverse, block by block, or inline element by inline element
 * Block and inline traversing is independent from each other, meanning if you traverse block by block, it does not change
 * the current inline element position
 */
var ContentTraverser = /** @class */ (function () {
    /**
     * Create a content traverser for the whole body of given root node
     * @param scoper Traversing scoper object to help scope the traversing
     * @param skipTags (Optional) tags that child elements will be skipped
     */
    function ContentTraverser(scoper, skipTags) {
        this.scoper = scoper;
        this.skipTags = skipTags;
    }
    /**
     * Create a content traverser for the whole body of given root node
     * @param rootNode The root node to traverse in
     * @param startNode The node to start from. If not passed, it will start from the beginning of the body
     * @param skipTags (Optional) tags that child elements will be skipped
     */
    ContentTraverser.createBodyTraverser = function (rootNode, startNode, skipTags) {
        return new ContentTraverser(new BodyScoper_1.default(rootNode, startNode));
    };
    /**
     * Create a content traverser for the given selection
     * @param rootNode The root node to traverse in
     * @param range The selection range to scope the traversing
     * @param skipTags (Optional) tags that child elements will be skipped
     */
    ContentTraverser.createSelectionTraverser = function (rootNode, range, skipTags) {
        return new ContentTraverser(new SelectionScoper_1.default(rootNode, range), skipTags);
    };
    /**
     * Create a content traverser for a block element which contains the given position
     * @param rootNode The root node to traverse in
     * @param position A position inside a block, traversing will be scoped within this block.
     * If passing a range, the start position of this range will be used
     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart
     * @param skipTags (Optional) tags that child elements will be skipped
     */
    ContentTraverser.createBlockTraverser = function (rootNode, position, start, skipTags) {
        if (start === void 0) { start = 3 /* SelectionStart */; }
        return new ContentTraverser(new SelectionBlockScoper_1.default(rootNode, position, start));
    };
    Object.defineProperty(ContentTraverser.prototype, "currentBlockElement", {
        /**
         * Get current block
         */
        get: function () {
            // Prepare currentBlock from the scoper
            if (!this.currentBlock) {
                this.currentBlock = this.scoper.getStartBlockElement();
            }
            return this.currentBlock;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get next block element
     */
    ContentTraverser.prototype.getNextBlockElement = function () {
        return this.getPreviousNextBlockElement(true /*isNext*/);
    };
    /**
     * Get previous block element
     */
    ContentTraverser.prototype.getPreviousBlockElement = function () {
        return this.getPreviousNextBlockElement(false /*isNext*/);
    };
    ContentTraverser.prototype.getPreviousNextBlockElement = function (isNext) {
        var current = this.currentBlockElement;
        if (!current) {
            return null;
        }
        var leaf = getLeafSibling_1.getLeafSibling(this.scoper.rootNode, isNext ? current.getEndNode() : current.getStartNode(), isNext, this.skipTags);
        var newBlock = leaf ? getBlockElementAtNode_1.default(this.scoper.rootNode, leaf) : null;
        // Make sure this is right block:
        // 1) the block is in scope per scoper
        // 2) the block is after (for next) or before (for previous) the current block
        // Then:
        // 1) Re-position current block to newly found block
        if (newBlock &&
            this.scoper.isBlockInScope(newBlock) &&
            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))) {
            this.currentBlock = newBlock;
            return this.currentBlock;
        }
        return null;
    };
    Object.defineProperty(ContentTraverser.prototype, "currentInlineElement", {
        /**
         * Current inline element getter
         */
        get: function () {
            // Retrieve a start inline from scoper
            if (!this.currentInline) {
                this.currentInline = this.scoper.getStartInlineElement();
            }
            return this.currentInline instanceof EmptyInlineElement_1.default ? null : this.currentInline;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get next inline element
     */
    ContentTraverser.prototype.getNextInlineElement = function () {
        return this.getPreviousNextInlineElement(true /*isNext*/);
    };
    /**
     * Get previous inline element
     */
    ContentTraverser.prototype.getPreviousInlineElement = function () {
        return this.getPreviousNextInlineElement(false /*isNext*/);
    };
    ContentTraverser.prototype.getPreviousNextInlineElement = function (isNext) {
        var current = this.currentInlineElement || this.currentInline;
        var newInline;
        if (!current) {
            return null;
        }
        if (current instanceof EmptyInlineElement_1.default) {
            newInline = getInlineElementBeforeAfter_1.getInlineElementBeforeAfter(this.scoper.rootNode, current.getStartPosition(), isNext);
            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {
                newInline = null;
            }
        }
        else {
            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);
            newInline =
                newInline &&
                    current &&
                    ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))
                    ? newInline
                    : null;
        }
        // For inline, we need to make sure:
        // 1) it is really next/previous to current
        // 2) pass on the new inline to this.scoper to do the triming and we still get back an inline
        // Then
        // 1) re-position current inline
        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {
            this.currentInline = newInline;
            return this.currentInline;
        }
        return null;
    };
    return ContentTraverser;
}());
exports.default = ContentTraverser;
function getNextPreviousInlineElement(rootNode, current, isNext) {
    if (!current) {
        return null;
    }
    if (current instanceof PartialInlineElement_1.default) {
        // if current is partial, get the the othe half of the inline unless it is no more
        var result = isNext ? current.nextInlineElement : current.previousInlineElement;
        if (result) {
            return result;
        }
    }
    // Get a leaf node after startNode and use that base to find next inline
    var startNode = current.getContainerNode();
    startNode = getLeafSibling_1.getLeafSibling(rootNode, startNode, isNext);
    return getInlineElementAtNode_1.default(rootNode, startNode);
}
//# sourceMappingURL=ContentTraverser.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ContentTraverser_1 = __webpack_require__(/*! ./ContentTraverser */ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.js");
var createRange_1 = __webpack_require__(/*! ../selection/createRange */ "./node_modules/roosterjs-editor-dom/lib/selection/createRange.js");
// White space matching regex. It matches following chars:
// \s: white space
// \u00A0: no-breaking white space
// \u200B: zero width space
// \u3000: full width space (which can come from JPN IME)
var WHITESPACE_REGEX = /[\s\u00A0\u200B\u3000]+([^\s\u00A0\u200B\u3000]*)$/i;
/**
 * The class that helps search content around a position
 */
var PositionContentSearcher = /** @class */ (function () {
    /**
     * Create a new CursorData instance
     * @param rootNode Root node of the whole scope
     * @param position Start position
     */
    function PositionContentSearcher(rootNode, position) {
        this.rootNode = rootNode;
        this.position = position;
        // The cached text before position that has been read so far
        this.text = '';
        // All inline elements before position that have been read so far
        this.inlineElements = [];
    }
    /**
     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion
     * between position and the white space is the word before position
     * @returns The word before position
     */
    PositionContentSearcher.prototype.getWordBefore = function () {
        var _this = this;
        if (!this.word) {
            this.traverse(function () { return _this.word; });
        }
        return this.word;
    };
    /**
     * Get the inline element before position
     * @returns The inlineElement before position
     */
    PositionContentSearcher.prototype.getInlineElementBefore = function () {
        if (!this.inlineBefore) {
            this.traverse(null);
        }
        return this.inlineBefore;
    };
    /**
     * Get the inline element after position
     * @returns The inline element after position
     */
    PositionContentSearcher.prototype.getInlineElementAfter = function () {
        if (!this.inlineAfter) {
            this.inlineAfter = ContentTraverser_1.default.createBlockTraverser(this.rootNode, this.position).currentInlineElement;
        }
        return this.inlineAfter;
    };
    /**
     * Get X number of chars before position
     * The actual returned chars may be less than what is requested.
     * @param length The length of string user want to get, the string always ends at the position,
     * so this length determins the start position of the string
     * @returns The actual string we get as a sub string, or the whole string before position when
     * there is not enough chars in the string
     */
    PositionContentSearcher.prototype.getSubStringBefore = function (length) {
        var _this = this;
        if (this.text.length < length) {
            this.traverse(function () { return _this.text.length >= length; });
        }
        return this.text.substr(Math.max(0, this.text.length - length));
    };
    /**
     * Try to get a range matches the given text before the position
     * @param text The text to match against
     * @param exactMatch Whether it is an exact match
     * @returns The range for the matched text, null if unable to find a match
     */
    PositionContentSearcher.prototype.getRangeFromText = function (text, exactMatch) {
        if (!text) {
            return null;
        }
        var startPosition;
        var endPosition;
        var textIndex = text.length - 1;
        this.forEachTextInlineElement(function (textInline) {
            var nodeContent = textInline.getTextContent() || '';
            var nodeIndex = nodeContent.length - 1;
            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {
                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {
                    textIndex--;
                    // on first time when end is matched, set the end of range
                    if (!endPosition) {
                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);
                    }
                }
                else if (exactMatch || endPosition) {
                    // Mismatch found when exact match or end already match, so return since matching failed
                    return true;
                }
            }
            // when textIndex == -1, we have a successful complete match
            if (textIndex == -1) {
                startPosition = textInline.getStartPosition().move(nodeIndex + 1);
                return true;
            }
            return false;
        });
        return startPosition && endPosition && createRange_1.default(startPosition, endPosition);
    };
    /**
     * Get text section before position till stop condition is met.
     * This offers consumers to retrieve text section by section
     * The section essentially is just an inline element which has Container element
     * so that the consumer can remember it for anchoring popup or verification purpose
     * when position moves out of context etc.
     * @param stopFunc The callback stop function
     */
    PositionContentSearcher.prototype.forEachTextInlineElement = function (callback) {
        // We cache all text sections read so far
        // Every time when you ask for textSection, we start with the cached first
        // and resort to further reading once we exhausted with the cache
        if (!this.inlineElements.some(callback)) {
            this.traverse(callback);
        }
    };
    /**
     * Get first non textual inline element before position
     * @returns First non textutal inline element before position or null if no such element exists
     */
    PositionContentSearcher.prototype.getNearestNonTextInlineElement = function () {
        var _this = this;
        if (!this.nearestNonTextInlineElement) {
            this.traverse(function () { return _this.nearestNonTextInlineElement; });
        }
        return this.nearestNonTextInlineElement;
    };
    /**
     * Continue traversing backward till stop condition is met or begin of block is reached
     */
    PositionContentSearcher.prototype.traverse = function (callback) {
        this.traverser =
            this.traverser || ContentTraverser_1.default.createBlockTraverser(this.rootNode, this.position);
        if (!this.traverser || this.traversingComplete) {
            return;
        }
        var previousInline = this.traverser.getPreviousInlineElement();
        while (!this.traversingComplete) {
            this.inlineBefore = this.inlineBefore || previousInline;
            if (previousInline && previousInline.isTextualInlineElement()) {
                var textContent = previousInline.getTextContent();
                // build the word before position if it is not built yet
                if (!this.word) {
                    // Match on the white space, the portion after space is on the index of 1 of the matched result
                    // (index at 0 is whole match result, index at 1 is the word)
                    var matches = WHITESPACE_REGEX.exec(textContent);
                    if (matches && matches.length == 2) {
                        this.word = matches[1] + this.text;
                    }
                }
                this.text = textContent + this.text;
                this.inlineElements.push(previousInline);
                // Check if stop condition is met
                if (callback && callback(previousInline)) {
                    break;
                }
            }
            else {
                this.nearestNonTextInlineElement = previousInline;
                this.traversingComplete = true;
                if (!this.word) {
                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor
                    this.word = this.text;
                }
                // When a non-textual inline element, or null is seen, we consider parsing complete
                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.
                // we have aaa @someone bbb<position>, and we want to read the text before @someone
                break;
            }
            previousInline = this.traverser.getPreviousInlineElement();
        }
    };
    return PositionContentSearcher;
}());
exports.default = PositionContentSearcher;
//# sourceMappingURL=PositionContentSearcher.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EmptyInlineElement_1 = __webpack_require__(/*! ../inlineElements/EmptyInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.js");
var getBlockElementAtNode_1 = __webpack_require__(/*! ../blockElements/getBlockElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.js");
var getInlineElementAtNode_1 = __webpack_require__(/*! ../inlineElements/getInlineElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.js");
var isRange_1 = __webpack_require__(/*! ../typeUtils/isRange */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isRange.js");
var NodeBlockElement_1 = __webpack_require__(/*! ../blockElements/NodeBlockElement */ "./node_modules/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.js");
var Position_1 = __webpack_require__(/*! ../selection/Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
var getInlineElementBeforeAfter_1 = __webpack_require__(/*! ../inlineElements/getInlineElementBeforeAfter */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.js");
var getFirstLastInlineElement_1 = __webpack_require__(/*! ../inlineElements/getFirstLastInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.js");
/**
 * This provides traversing content in a selection start block
 * This is commonly used for those cursor context sensitive plugin,
 * they want to know text being typed at cursor
 * This provides a scope for parsing from cursor position up to begin of the selection block
 */
var SelectionBlockScoper = /** @class */ (function () {
    /**
     * Create a new instance of SelectionBlockScoper class
     * @param rootNode The root node of the whole scope
     * @param position Position of the selection start
     * @param startFrom Where to start, can be Begin, End, SelectionStart
     */
    function SelectionBlockScoper(rootNode, position, startFrom) {
        this.rootNode = rootNode;
        this.startFrom = startFrom;
        position = isRange_1.default(position) ? Position_1.default.getStart(position) : position;
        this.position = position.normalize();
        this.block = getBlockElementAtNode_1.default(this.rootNode, this.position.node);
    }
    /**
     * Get the start block element
     */
    SelectionBlockScoper.prototype.getStartBlockElement = function () {
        return this.block;
    };
    /**
     * Get the start inline element
     * The start inline refers to inline before the selection start
     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragragh,
     * the one after likely will point to inline in next paragragh which may be null if the cursor is at bottom of editor
     */
    SelectionBlockScoper.prototype.getStartInlineElement = function () {
        if (this.block) {
            switch (this.startFrom) {
                case 0 /* Begin */:
                case 1 /* End */:
                case 2 /* DomEnd */:
                    return getFirstLastInlineElementFromBlockElement(this.block, this.startFrom == 0 /* Begin */);
                case 3 /* SelectionStart */:
                    // Get the inline before selection start point, and ensure it falls in the selection block
                    var startInline = getInlineElementBeforeAfter_1.getInlineElementAfter(this.rootNode, this.position);
                    return startInline && this.block.contains(startInline.getContainerNode())
                        ? startInline
                        : new EmptyInlineElement_1.default(this.position, this.block);
            }
        }
        return null;
    };
    /**
     * Check if the given block element is in current scope
     * @param blockElement The block element to check
     */
    SelectionBlockScoper.prototype.isBlockInScope = function (blockElement) {
        return this.block && blockElement ? this.block.equals(blockElement) : false;
    };
    /**
     * Trim the incoming inline element, and return an inline element
     * This just tests and return the inline element if it is in block
     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half
     * A block scoper does not cut an inline in half
     */
    SelectionBlockScoper.prototype.trimInlineElement = function (inlineElement) {
        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())
            ? inlineElement
            : null;
    };
    return SelectionBlockScoper;
}());
exports.default = SelectionBlockScoper;
/**
 * Get first/last InlineElement of the given BlockElement
 * @param block The BlockElement to get InlineElement from
 * @param isFirst True to get first InlineElement, false to get last InlineElement
 */
function getFirstLastInlineElementFromBlockElement(block, isFirst) {
    if (block instanceof NodeBlockElement_1.default) {
        var blockNode = block.getStartNode();
        return isFirst ? getFirstLastInlineElement_1.getFirstInlineElement(blockNode) : getFirstLastInlineElement_1.getLastInlineElement(blockNode);
    }
    else {
        return getInlineElementAtNode_1.default(block, isFirst ? block.getStartNode() : block.getEndNode());
    }
}
//# sourceMappingURL=SelectionBlockScoper.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getBlockElementAtNode_1 = __webpack_require__(/*! ../blockElements/getBlockElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.js");
var PartialInlineElement_1 = __webpack_require__(/*! ../inlineElements/PartialInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.js");
var Position_1 = __webpack_require__(/*! ../selection/Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
var getInlineElementBeforeAfter_1 = __webpack_require__(/*! ../inlineElements/getInlineElementBeforeAfter */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.js");
/**
 * This is selection scoper that provide a start inline as the start of the selection
 * and checks if a block falls in the selection (isBlockInScope)
 * last trimInlineElement to trim any inline element to return a partial that falls in the selection
 */
var SelectionScoper = /** @class */ (function () {
    /**
     * Create a new instance of SelectionScoper class
     * @param rootNode The root node of the content
     * @param range The selection range to scope to
     */
    function SelectionScoper(rootNode, range) {
        this.rootNode = rootNode;
        this.start = Position_1.default.getStart(range).normalize();
        this.end = Position_1.default.getEnd(range).normalize();
    }
    /**
     * Provide a start block as the first block after the cursor
     */
    SelectionScoper.prototype.getStartBlockElement = function () {
        if (!this.startBlock) {
            this.startBlock = getBlockElementAtNode_1.default(this.rootNode, this.start.node);
        }
        return this.startBlock;
    };
    /**
     * Provide a start inline as the first inline after the cursor
     */
    SelectionScoper.prototype.getStartInlineElement = function () {
        if (!this.startInline) {
            this.startInline = this.trimInlineElement(getInlineElementBeforeAfter_1.getInlineElementAfter(this.rootNode, this.start));
        }
        return this.startInline;
    };
    /**
     * Checks if a block completely falls in the selection
     * @param block The BlockElement to check
     */
    SelectionScoper.prototype.isBlockInScope = function (block) {
        if (!block) {
            return false;
        }
        var inScope = false;
        var selStartBlock = this.getStartBlockElement();
        if (this.start.equalTo(this.end)) {
            inScope = selStartBlock && selStartBlock.equals(block);
        }
        else {
            var selEndBlock = getBlockElementAtNode_1.default(this.rootNode, this.end.node);
            // There are three cases that are considered as "block in scope"
            // 1) The start of selection falls on the block
            // 2) The end of selection falls on the block
            // 3) the block falls in-between selection start and end
            inScope =
                selStartBlock &&
                    selEndBlock &&
                    (block.equals(selStartBlock) ||
                        block.equals(selEndBlock) ||
                        (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));
        }
        return inScope;
    };
    /**
     * Trim an incoming inline. If it falls completely outside selection, return null
     * otherwise return a partial that represents the portion that falls in the selection
     * @param inline The InlineElement to check
     */
    SelectionScoper.prototype.trimInlineElement = function (inline) {
        if (!inline || this.start.equalTo(this.end)) {
            return null;
        }
        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon
        var start = inline.getStartPosition();
        var end = inline.getEndPosition();
        if (start.isAfter(this.end) || this.start.isAfter(end)) {
            return null;
        }
        var startPartial = false;
        var endPartial = false;
        if (this.start.isAfter(start)) {
            start = this.start;
            startPartial = true;
        }
        if (end.isAfter(this.end)) {
            end = this.end;
            endPartial = true;
        }
        return start.isAfter(end) || start.equalTo(end)
            ? null
            : startPartial || endPartial
                ? new PartialInlineElement_1.default(inline, startPartial && start, endPartial && end)
                : inline;
    };
    return SelectionScoper;
}());
exports.default = SelectionScoper;
//# sourceMappingURL=SelectionScoper.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/HtmlSanitizer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/HtmlSanitizer.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getInheritableStyles_1 = __webpack_require__(/*! ./getInheritableStyles */ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/getInheritableStyles.js");
var htmlToDom_1 = __webpack_require__(/*! ./htmlToDom */ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/htmlToDom.js");
var isHTMLElement_1 = __webpack_require__(/*! ../typeUtils/isHTMLElement */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLElement.js");
var cloneObject_1 = __webpack_require__(/*! ./cloneObject */ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/cloneObject.js");
var getAllowedValues_1 = __webpack_require__(/*! ./getAllowedValues */ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/getAllowedValues.js");
/**
 * HTML sanitizer class provides two featuers:
 * 1. Convert global CSS to inline CSS
 * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes
 */
var HtmlSanitizer = /** @class */ (function () {
    /**
     * Construct a new instance of HtmlSanitizer
     * @param options Options for HtmlSanitizer
     */
    function HtmlSanitizer(options) {
        options = options || {};
        this.elementCallbacks = cloneObject_1.cloneObject(options.elementCallbacks);
        this.styleCallbacks = getAllowedValues_1.getStyleCallbacks(options.styleCallbacks);
        this.attributeCallbacks = cloneObject_1.cloneObject(options.attributeCallbacks);
        this.allowedTags = getAllowedValues_1.getAllowedTags(options.additionalAllowedTags);
        this.allowedAttributes = getAllowedValues_1.getAllowedAttributes(options.additionalAllowAttributes);
        this.allowedCssClassesRegex = getAllowedValues_1.getAllowedCssClassesRegex(options.additionalAllowedCssClasses);
        this.defaultStyleValues = getAllowedValues_1.getDefaultStyleValues(options.additionalDefaultStyleValues);
        this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];
        this.allowPreserveWhiteSpace = options.allowPreserveWhiteSpace;
    }
    /**
     * Convert global CSS to inline CSS if any
     * @param html HTML source
     * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS
     */
    HtmlSanitizer.convertInlineCss = function (html, additionalStyleNodes) {
        var sanitizer = new HtmlSanitizer({
            additionalGlobalStyleNodes: additionalStyleNodes,
        });
        return sanitizer.exec(html, true /*convertCssOnly*/);
    };
    /**
     * Sanitize HTML string, remove any unuseful HTML node/attribute/CSS.
     * @param html HTML source string
     * @param options Options used for this sanitizing process
     */
    HtmlSanitizer.sanitizeHtml = function (html, options) {
        options = options || {};
        var sanitizer = new HtmlSanitizer(options);
        var currentStyles = isHTMLElement_1.default(options.currentElementOrStyle)
            ? getInheritableStyles_1.default(options.currentElementOrStyle)
            : options.currentElementOrStyle;
        return sanitizer.exec(html, options.convertCssOnly, options.preserveFragmentOnly, currentStyles);
    };
    /**
     * Sanitize HTML string
     * This function will do the following work:
     * 1. Convert global CSS into inline CSS
     * 2. Remove dangerous HTML tags and attributes
     * 3. Remove useless CSS properties
     * @param html The input HTML
     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing
     * @param preserveFragmentOnly If set to true, only preserve the html content between &lt;!--StartFragment--&gt; and &lt;!--Endfragment--&gt;
     * @param currentStyles Current inheritable CSS styles
     */
    HtmlSanitizer.prototype.exec = function (html, convertCssOnly, preserveFragmentOnly, currentStyles) {
        var doc = htmlToDom_1.default(html, preserveFragmentOnly);
        if (doc) {
            this.convertGlobalCssToInlineCss(doc);
            if (!convertCssOnly) {
                this.sanitize(doc.body, currentStyles);
            }
        }
        return (doc && doc.body && doc.body.innerHTML) || '';
    };
    /**
     * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules
     * @param rootNode Root node to sanitize
     * @param currentStyles Current CSS styles. Inheritable styles in the given node which has
     * the same value with current styles will be ignored.
     */
    HtmlSanitizer.prototype.sanitize = function (rootNode, currentStyles) {
        if (!rootNode) {
            return '';
        }
        currentStyles = cloneObject_1.cloneObject(currentStyles, getInheritableStyles_1.default(null));
        this.processNode(rootNode, currentStyles, {});
    };
    /**
     * Convert global CSS into inline CSS
     * @param rootNode The HTML Document
     */
    HtmlSanitizer.prototype.convertGlobalCssToInlineCss = function (rootNode) {
        var styleNodes = toArray(rootNode.querySelectorAll('style'));
        var styleSheets = this.additionalGlobalStyleNodes
            .reverse()
            .map(function (node) { return node.sheet; })
            .concat(styleNodes.map(function (node) { return node.sheet; }).reverse())
            .filter(function (sheet) { return sheet; });
        for (var _i = 0, styleSheets_1 = styleSheets; _i < styleSheets_1.length; _i++) {
            var styleSheet = styleSheets_1[_i];
            var _loop_1 = function (j) {
                // Skip any none-style rule, i.e. @page
                var styleRule = styleSheet.cssRules[j];
                var text = styleRule && styleRule.style ? styleRule.style.cssText : null;
                if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {
                    return "continue";
                }
                // Make sure the selector is not empty
                for (var _i = 0, _a = styleRule.selectorText.split(','); _i < _a.length; _i++) {
                    var selector = _a[_i];
                    if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {
                        continue;
                    }
                    var nodes = toArray(rootNode.querySelectorAll(selector));
                    // Always put existing styles after so that they have higher priority
                    // Which means if both global style and inline style apply to the same element,
                    // inline style will have higher priority
                    nodes.forEach(function (node) {
                        return node.setAttribute('style', text + (node.getAttribute('style') || ''));
                    });
                }
            };
            for (var j = styleSheet.cssRules.length - 1; j >= 0; j--) {
                _loop_1(j);
            }
        }
        styleNodes.forEach(function (node) {
            if (node.parentNode) {
                node.parentNode.removeChild(node);
            }
        });
    };
    HtmlSanitizer.prototype.processNode = function (node, currentStyle, context) {
        var nodeType = node.nodeType;
        var isElement = nodeType == 1 /* Element */;
        var isText = nodeType == 3 /* Text */;
        var isFragment = nodeType == 11 /* DocumentFragment */;
        var element = node;
        var tag = isElement ? element.tagName.toUpperCase() : '';
        if ((isElement && !this.allowElement(element, tag, context)) ||
            (isText && /^[\r\n]*$/g.test(node.nodeValue) && !currentStyle.insidePRE) ||
            (!isElement && !isText && !isFragment)) {
            node.parentNode.removeChild(node);
        }
        else if (isText &&
            !this.allowPreserveWhiteSpace &&
            currentStyle['white-space'] == 'pre') {
            node.nodeValue = node.nodeValue.replace(/^ /gm, '\u00A0').replace(/ {2}/g, ' \u00A0');
        }
        else if (isElement || isFragment) {
            var thisStyle = cloneObject_1.cloneObject(currentStyle);
            if (isElement) {
                this.processAttributes(element, context);
                this.processCss(element, tag, thisStyle, context);
                // Special handling for PRE tag, need to preserve \r\n inside PRE
                if (tag == 'PRE') {
                    thisStyle.insidePRE = 'true';
                }
            }
            var child = element.firstChild;
            var next = void 0;
            for (; child; child = next) {
                next = child.nextSibling;
                this.processNode(child, thisStyle, context);
            }
        }
    };
    HtmlSanitizer.prototype.processCss = function (element, tag, thisStyle, context) {
        var _this = this;
        var styleNode = element.getAttributeNode('style');
        if (!styleNode) {
            return;
        }
        var source = styleNode.value.split(';');
        var result = source.filter(function (style) {
            var pair;
            if (!style || style.trim() == '' || (pair = style.split(':')).length != 2) {
                return false;
            }
            var name = pair[0].trim().toLowerCase();
            var value = pair[1].trim().toLowerCase();
            var callback = _this.styleCallbacks[name];
            var isInheritable = thisStyle[name] != undefined;
            var keep = (!callback || callback(value, element, context)) &&
                value != 'inherit' &&
                value.indexOf('expression') < 0 &&
                name.substr(0, 1) != '-' &&
                _this.defaultStyleValues[name] != value &&
                ((isInheritable && value != thisStyle[name]) ||
                    (!isInheritable && value != 'initial' && value != 'normal'));
            if (keep && isInheritable) {
                thisStyle[name] = value;
            }
            return keep && (_this.allowPreserveWhiteSpace || name != 'white-space');
        });
        if (source.length != result.length) {
            if (result.length > 0) {
                element.setAttribute('style', result.map(function (s) { return s.trim(); }).join('; '));
            }
            else {
                element.removeAttribute('style');
            }
        }
    };
    HtmlSanitizer.prototype.processAttributes = function (element, context) {
        for (var i = element.attributes.length - 1; i >= 0; i--) {
            var attribute = element.attributes[i];
            var name_1 = attribute.name.toLowerCase().trim();
            var value = attribute.value;
            var callback = this.attributeCallbacks[name_1];
            var newValue = callback
                ? callback(value, element, context)
                : this.allowedAttributes.indexOf(name_1) >= 0 || name_1.indexOf('data-') == 0
                    ? value
                    : null;
            if (name_1 == 'class' && this.allowedCssClassesRegex) {
                newValue = this.processCssClass(value, newValue);
            }
            if (newValue === null ||
                newValue === undefined ||
                newValue.match(/s\n*c\n*r\n*i\n*p\n*t\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix
            ) {
                element.removeAttribute(name_1);
            }
            else {
                attribute.value = newValue;
            }
        }
    };
    HtmlSanitizer.prototype.processCssClass = function (originalValue, calculatedValue) {
        var _this = this;
        var originalClasses = originalValue ? originalValue.split(' ') : [];
        var calculatedClasses = calculatedValue ? calculatedValue.split(' ') : [];
        originalClasses.forEach(function (className) {
            if (_this.allowedCssClassesRegex.test(className) &&
                calculatedClasses.indexOf(className) < 0) {
                calculatedClasses.push(className);
            }
        });
        return calculatedClasses.length > 0 ? calculatedClasses.join(' ') : null;
    };
    HtmlSanitizer.prototype.allowElement = function (element, tag, context) {
        var callback = this.elementCallbacks[tag];
        return callback
            ? callback(element, context)
            : this.allowedTags.indexOf(tag) >= 0 || tag.indexOf(':') > 0;
    };
    return HtmlSanitizer;
}());
exports.default = HtmlSanitizer;
function toArray(list) {
    return [].slice.call(list);
}
//# sourceMappingURL=HtmlSanitizer.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/chainSanitizerCallback.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/chainSanitizerCallback.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Chain all callback for an attribute together
 * @param map The source callback map
 * @param name Name of the property to chain
 * @param newCallback A new callback to process the given name on the given map.
 * If the same property got multiple callbacks, the final return value will be the return
 * value of the latest callback
 */
function chainSanitizerCallback(map, name, newCallback) {
    if (!map[name]) {
        map[name] = newCallback;
    }
    else {
        var originalCallback_1 = map[name];
        map[name] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            originalCallback_1.apply(void 0, args);
            return newCallback.apply(void 0, args);
        };
    }
}
exports.default = chainSanitizerCallback;
//# sourceMappingURL=chainSanitizerCallback.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/cloneObject.js":
/*!****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/cloneObject.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function nativeClone(source, existingObj) {
    return Object.assign(existingObj || {}, source);
}
function customClone(source, existingObj) {
    var result = existingObj || {};
    if (source) {
        for (var _i = 0, _a = Object.keys(source); _i < _a.length; _i++) {
            var key = _a[_i];
            result[key] = source[key];
        }
    }
    return result;
}
/**
 * @internal
 */
exports.cloneObject = Object.assign ? nativeClone : customClone;
//# sourceMappingURL=cloneObject.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/createDefaultHtmlSanitizerOptions.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/createDefaultHtmlSanitizerOptions.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Create default value of HtmlSanitizerOptions with every property set
 */
function createDefaultHtmlSanitizerOptions() {
    return {
        elementCallbacks: {},
        attributeCallbacks: {},
        styleCallbacks: {},
        additionalAllowedTags: [],
        additionalAllowAttributes: [],
        additionalAllowedCssClasses: [],
        additionalDefaultStyleValues: {},
        additionalGlobalStyleNodes: [],
        allowPreserveWhiteSpace: false,
    };
}
exports.default = createDefaultHtmlSanitizerOptions;
//# sourceMappingURL=createDefaultHtmlSanitizerOptions.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/getAllowedValues.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/getAllowedValues.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var cloneObject_1 = __webpack_require__(/*! ./cloneObject */ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/cloneObject.js");
var ALLOWED_HTML_TAGS = ('BODY,H1,H2,H3,H4,H5,H6,FORM,P,BR,NOBR,HR,ACRONYM,ABBR,ADDRESS,B,' +
    'BDI,BDO,BIG,BLOCKQUOTE,CENTER,CITE,CODE,DEL,DFN,EM,FONT,I,INS,KBD,MARK,METER,PRE,PROGRESS,' +
    'Q,RP,RT,RUBY,S,SAMP,SMALL,STRIKE,STRONG,SUB,SUP,TEMPLATE,TIME,TT,U,VAR,WBR,XMP,INPUT,TEXTAREA,' +
    'BUTTON,SELECT,OPTGROUP,OPTION,LABEL,FIELDSET,LEGEND,DATALIST,OUTPUT,IMG,MAP,AREA,CANVAS,FIGCAPTION,' +
    'FIGURE,PICTURE,A,NAV,UL,OL,LI,DIR,UL,DL,DT,DD,MENU,MENUITEM,TABLE,CAPTION,TH,TR,TD,THEAD,TBODY,' +
    'TFOOT,COL,COLGROUP,DIV,SPAN,HEADER,FOOTER,MAIN,SECTION,ARTICLE,ASIDE,DETAILS,DIALOG,SUMMARY,DATA').split(',');
var ALLOWED_HTML_ATTRIBUTES = ('accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +
    'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +
    'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +
    'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +
    'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,value,' +
    'width,wrap').split(',');
var DEFAULT_STYLE_VALUES = {
    'background-color': 'transparent',
    'border-bottom-color': 'rgb(0, 0, 0)',
    'border-bottom-style': 'none',
    'border-bottom-width': '0px',
    'border-image-outset': '0',
    'border-image-repeat': 'stretch',
    'border-image-slice': '100%',
    'border-image-source': 'none',
    'border-image-width': '1',
    'border-left-color': 'rgb(0, 0, 0)',
    'border-left-style': 'none',
    'border-left-width': '0px',
    'border-right-color': 'rgb(0, 0, 0)',
    'border-right-style': 'none',
    'border-right-width': '0px',
    'border-top-color': 'rgb(0, 0, 0)',
    'border-top-style': 'none',
    'border-top-width': '0px',
    'outline-color': 'transparent',
    'outline-style': 'none',
    'outline-width': '0px',
    overflow: 'visible',
    'text-decoration': 'none',
    '-webkit-text-stroke-width': '0px',
    'word-wrap': 'break-word',
    'margin-left': '0px',
    'margin-right': '0px',
    padding: '0px',
    'padding-top': '0px',
    'padding-left': '0px',
    'padding-right': '0px',
    'padding-bottom': '0px',
    border: '0px',
    'border-top': '0px',
    'border-left': '0px',
    'border-right': '0px',
    'border-bottom': '0px',
    'vertical-align': 'baseline',
    float: 'none',
};
// This is to preserve entity related CSS classes when paste.
var ALLOWED_CSS_CLASSES = [];
/**
 * @internal
 */
function getAllowedTags(additionalTags) {
    return unique(ALLOWED_HTML_TAGS.concat(additionalTags || [])).map(function (tag) { return tag.toUpperCase(); });
}
exports.getAllowedTags = getAllowedTags;
/**
 * @internal
 */
function getAllowedAttributes(additionalAttributes) {
    return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(function (attr) {
        return attr.toLocaleLowerCase();
    });
}
exports.getAllowedAttributes = getAllowedAttributes;
/**
 * @internal
 */
function getAllowedCssClassesRegex(additionalCssClasses) {
    var patterns = ALLOWED_CSS_CLASSES.concat(additionalCssClasses || []);
    return patterns.length > 0 ? new RegExp(patterns.join('|')) : null;
}
exports.getAllowedCssClassesRegex = getAllowedCssClassesRegex;
/**
 * @internal
 */
function getDefaultStyleValues(additionalDefaultStyles) {
    var result = cloneObject_1.cloneObject(DEFAULT_STYLE_VALUES);
    if (additionalDefaultStyles) {
        Object.keys(additionalDefaultStyles).forEach(function (name) {
            var value = additionalDefaultStyles[name];
            if (value !== null && value !== undefined) {
                result[name] = value;
            }
            else {
                delete result[name];
            }
        });
    }
    return result;
}
exports.getDefaultStyleValues = getDefaultStyleValues;
/**
 * @internal
 */
function getStyleCallbacks(callbacks) {
    var result = cloneObject_1.cloneObject(callbacks);
    result.position = result.position || removeValue;
    result.width = result.width || removeWidthForLiAndDiv;
    return result;
}
exports.getStyleCallbacks = getStyleCallbacks;
function removeValue() {
    return null;
}
function removeWidthForLiAndDiv(value, element) {
    var tag = element.tagName;
    return !(tag == 'LI' || tag == 'DIV');
}
function unique(array) {
    return array.filter(function (value, index, self) { return self.indexOf(value) == index; });
}
//# sourceMappingURL=getAllowedValues.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/getInheritableStyles.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/getInheritableStyles.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// Inheritable CSS properties
// Ref: https://www.w3.org/TR/CSS21/propidx.html
var INHERITABLE_PROPERTIES = ('border-spacing,caption-side,color,' +
    'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +
    'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +
    'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +
    'widows,word-spacing').split(',');
/**
 * Get inheritable CSS style values from the given element
 * @param element The element to get style from
 */
function getInheritableStyles(element) {
    var win = element && element.ownerDocument && element.ownerDocument.defaultView;
    var styles = win && win.getComputedStyle(element);
    var result = {};
    INHERITABLE_PROPERTIES.forEach(function (name) { return (result[name] = (styles && styles.getPropertyValue(name)) || ''); });
    return result;
}
exports.default = getInheritableStyles;
//# sourceMappingURL=getInheritableStyles.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/htmlToDom.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/htmlToDom.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var START_FRAGMENT = '<!--StartFragment-->';
var END_FRAGMENT = '<!--EndFragment-->';
/**
 * Build DOM tree from the given HTML string
 * @param html Source HTML string
 * @param preserveFragmentOnly If there is fragment markup (&lt;!--StartFragment--&gt; and &lt;!--EndFragment--&gt;),
 * only preserve content between these markups
 * @param fragmentHandler An optional callback to do customized fragment handling
 */
function htmlToDom(html, preserveFragmentOnly, fragmentHandler) {
    var parser = new DOMParser();
    var doc = parser.parseFromString(html || '', 'text/html');
    if (doc && doc.body && doc.body.firstChild) {
        // 1. Filter out html code outside of Fragment tags if need
        if (preserveFragmentOnly) {
            (fragmentHandler || defaultFragmentTrimmer)(doc, html);
        }
        return doc;
    }
    else {
        return null;
    }
}
exports.default = htmlToDom;
function defaultFragmentTrimmer(doc, sourceHtml) {
    var html = splitWithFragment(sourceHtml)[0];
    doc.body.innerHTML = html;
}
/**
 * Split the HTML string using its fragment info
 * @param html Source html string
 * @returns [String within fragment, String before fragment, String after fragment]
 */
function splitWithFragment(html) {
    var startIndex = html.indexOf(START_FRAGMENT);
    var endIndex = html.lastIndexOf(END_FRAGMENT);
    if (startIndex >= 0 && endIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {
        var before = html.substr(0, startIndex);
        var after = html.substr(endIndex + END_FRAGMENT.length);
        html = html.substring(startIndex + START_FRAGMENT.length, endIndex);
        return [html, before, after];
    }
    else {
        return [html, null, null];
    }
}
exports.splitWithFragment = splitWithFragment;
//# sourceMappingURL=htmlToDom.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var NodeBlockElement_1 = __webpack_require__(/*! ./blockElements/NodeBlockElement */ "./node_modules/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.js");
exports.NodeBlockElement = NodeBlockElement_1.default;
var getBlockElementAtNode_1 = __webpack_require__(/*! ./blockElements/getBlockElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.js");
exports.getBlockElementAtNode = getBlockElementAtNode_1.default;
var getFirstLastBlockElement_1 = __webpack_require__(/*! ./blockElements/getFirstLastBlockElement */ "./node_modules/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.js");
exports.getFirstLastBlockElement = getFirstLastBlockElement_1.default;
var StartEndBlockElement_1 = __webpack_require__(/*! ./blockElements/StartEndBlockElement */ "./node_modules/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.js");
exports.StartEndBlockElement = StartEndBlockElement_1.default;
var ContentTraverser_1 = __webpack_require__(/*! ./contentTraverser/ContentTraverser */ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.js");
exports.ContentTraverser = ContentTraverser_1.default;
var PositionContentSearcher_1 = __webpack_require__(/*! ./contentTraverser/PositionContentSearcher */ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.js");
exports.PositionContentSearcher = PositionContentSearcher_1.default;
var getInlineElementAtNode_1 = __webpack_require__(/*! ./inlineElements/getInlineElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.js");
exports.getInlineElementAtNode = getInlineElementAtNode_1.default;
var ImageInlineElement_1 = __webpack_require__(/*! ./inlineElements/ImageInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.js");
exports.ImageInlineElement = ImageInlineElement_1.default;
var LinkInlineElement_1 = __webpack_require__(/*! ./inlineElements/LinkInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.js");
exports.LinkInlineElement = LinkInlineElement_1.default;
var NodeInlineElement_1 = __webpack_require__(/*! ./inlineElements/NodeInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.js");
exports.NodeInlineElement = NodeInlineElement_1.default;
var PartialInlineElement_1 = __webpack_require__(/*! ./inlineElements/PartialInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.js");
exports.PartialInlineElement = PartialInlineElement_1.default;
var applyTextStyle_1 = __webpack_require__(/*! ./utils/applyTextStyle */ "./node_modules/roosterjs-editor-dom/lib/utils/applyTextStyle.js");
exports.applyTextStyle = applyTextStyle_1.default;
var Browser_1 = __webpack_require__(/*! ./utils/Browser */ "./node_modules/roosterjs-editor-dom/lib/utils/Browser.js");
exports.Browser = Browser_1.Browser;
exports.getBrowserInfo = Browser_1.getBrowserInfo;
var applyFormat_1 = __webpack_require__(/*! ./utils/applyFormat */ "./node_modules/roosterjs-editor-dom/lib/utils/applyFormat.js");
exports.applyFormat = applyFormat_1.default;
var changeElementTag_1 = __webpack_require__(/*! ./utils/changeElementTag */ "./node_modules/roosterjs-editor-dom/lib/utils/changeElementTag.js");
exports.changeElementTag = changeElementTag_1.default;
var collapseNodes_1 = __webpack_require__(/*! ./utils/collapseNodes */ "./node_modules/roosterjs-editor-dom/lib/utils/collapseNodes.js");
exports.collapseNodes = collapseNodes_1.default;
var contains_1 = __webpack_require__(/*! ./utils/contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
exports.contains = contains_1.default;
var extractClipboardEvent_1 = __webpack_require__(/*! ./utils/extractClipboardEvent */ "./node_modules/roosterjs-editor-dom/lib/utils/extractClipboardEvent.js");
exports.extractClipboardEvent = extractClipboardEvent_1.default;
var findClosestElementAncestor_1 = __webpack_require__(/*! ./utils/findClosestElementAncestor */ "./node_modules/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.js");
exports.findClosestElementAncestor = findClosestElementAncestor_1.default;
var fromHtml_1 = __webpack_require__(/*! ./utils/fromHtml */ "./node_modules/roosterjs-editor-dom/lib/utils/fromHtml.js");
exports.fromHtml = fromHtml_1.default;
var getComputedStyles_1 = __webpack_require__(/*! ./utils/getComputedStyles */ "./node_modules/roosterjs-editor-dom/lib/utils/getComputedStyles.js");
exports.getComputedStyles = getComputedStyles_1.default;
exports.getComputedStyle = getComputedStyles_1.getComputedStyle;
var getPendableFormatState_1 = __webpack_require__(/*! ./utils/getPendableFormatState */ "./node_modules/roosterjs-editor-dom/lib/utils/getPendableFormatState.js");
exports.getPendableFormatState = getPendableFormatState_1.default;
exports.PendableFormatCommandMap = getPendableFormatState_1.PendableFormatCommandMap;
var getTagOfNode_1 = __webpack_require__(/*! ./utils/getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
exports.getTagOfNode = getTagOfNode_1.default;
var isBlockElement_1 = __webpack_require__(/*! ./utils/isBlockElement */ "./node_modules/roosterjs-editor-dom/lib/utils/isBlockElement.js");
exports.isBlockElement = isBlockElement_1.default;
var isNodeEmpty_1 = __webpack_require__(/*! ./utils/isNodeEmpty */ "./node_modules/roosterjs-editor-dom/lib/utils/isNodeEmpty.js");
exports.isNodeEmpty = isNodeEmpty_1.default;
var isRtl_1 = __webpack_require__(/*! ./utils/isRtl */ "./node_modules/roosterjs-editor-dom/lib/utils/isRtl.js");
exports.isRtl = isRtl_1.default;
var isVoidHtmlElement_1 = __webpack_require__(/*! ./utils/isVoidHtmlElement */ "./node_modules/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.js");
exports.isVoidHtmlElement = isVoidHtmlElement_1.default;
var matchLink_1 = __webpack_require__(/*! ./utils/matchLink */ "./node_modules/roosterjs-editor-dom/lib/utils/matchLink.js");
exports.matchLink = matchLink_1.default;
var adjustNodeInsertPosition_1 = __webpack_require__(/*! ./utils/adjustNodeInsertPosition */ "./node_modules/roosterjs-editor-dom/lib/utils/adjustNodeInsertPosition.js");
exports.adjustNodeInsertPosition = adjustNodeInsertPosition_1.default;
var queryElements_1 = __webpack_require__(/*! ./utils/queryElements */ "./node_modules/roosterjs-editor-dom/lib/utils/queryElements.js");
exports.queryElements = queryElements_1.default;
var splitParentNode_1 = __webpack_require__(/*! ./utils/splitParentNode */ "./node_modules/roosterjs-editor-dom/lib/utils/splitParentNode.js");
exports.splitParentNode = splitParentNode_1.default;
exports.splitBalancedNodeRange = splitParentNode_1.splitBalancedNodeRange;
var unwrap_1 = __webpack_require__(/*! ./utils/unwrap */ "./node_modules/roosterjs-editor-dom/lib/utils/unwrap.js");
exports.unwrap = unwrap_1.default;
var wrap_1 = __webpack_require__(/*! ./utils/wrap */ "./node_modules/roosterjs-editor-dom/lib/utils/wrap.js");
exports.wrap = wrap_1.default;
var getLeafSibling_1 = __webpack_require__(/*! ./utils/getLeafSibling */ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafSibling.js");
exports.getNextLeafSibling = getLeafSibling_1.getNextLeafSibling;
exports.getPreviousLeafSibling = getLeafSibling_1.getPreviousLeafSibling;
var getLeafNode_1 = __webpack_require__(/*! ./utils/getLeafNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafNode.js");
exports.getFirstLeafNode = getLeafNode_1.getFirstLeafNode;
exports.getLastLeafNode = getLeafNode_1.getLastLeafNode;
var getTextContent_1 = __webpack_require__(/*! ./utils/getTextContent */ "./node_modules/roosterjs-editor-dom/lib/utils/getTextContent.js");
exports.getTextContent = getTextContent_1.default;
var splitTextNode_1 = __webpack_require__(/*! ./utils/splitTextNode */ "./node_modules/roosterjs-editor-dom/lib/utils/splitTextNode.js");
exports.splitTextNode = splitTextNode_1.default;
var normalizeRect_1 = __webpack_require__(/*! ./utils/normalizeRect */ "./node_modules/roosterjs-editor-dom/lib/utils/normalizeRect.js");
exports.normalizeRect = normalizeRect_1.default;
var toArray_1 = __webpack_require__(/*! ./utils/toArray */ "./node_modules/roosterjs-editor-dom/lib/utils/toArray.js");
exports.toArray = toArray_1.default;
var VTable_1 = __webpack_require__(/*! ./table/VTable */ "./node_modules/roosterjs-editor-dom/lib/table/VTable.js");
exports.VTable = VTable_1.default;
var VList_1 = __webpack_require__(/*! ./list/VList */ "./node_modules/roosterjs-editor-dom/lib/list/VList.js");
exports.VList = VList_1.default;
var createVListFromRegion_1 = __webpack_require__(/*! ./list/createVListFromRegion */ "./node_modules/roosterjs-editor-dom/lib/list/createVListFromRegion.js");
exports.createVListFromRegion = createVListFromRegion_1.default;
var getRegionsFromRange_1 = __webpack_require__(/*! ./region/getRegionsFromRange */ "./node_modules/roosterjs-editor-dom/lib/region/getRegionsFromRange.js");
exports.getRegionsFromRange = getRegionsFromRange_1.default;
var getSelectedBlockElementsInRegion_1 = __webpack_require__(/*! ./region/getSelectedBlockElementsInRegion */ "./node_modules/roosterjs-editor-dom/lib/region/getSelectedBlockElementsInRegion.js");
exports.getSelectedBlockElementsInRegion = getSelectedBlockElementsInRegion_1.default;
var collapseNodesInRegion_1 = __webpack_require__(/*! ./region/collapseNodesInRegion */ "./node_modules/roosterjs-editor-dom/lib/region/collapseNodesInRegion.js");
exports.collapseNodesInRegion = collapseNodesInRegion_1.default;
var isNodeInRegion_1 = __webpack_require__(/*! ./region/isNodeInRegion */ "./node_modules/roosterjs-editor-dom/lib/region/isNodeInRegion.js");
exports.isNodeInRegion = isNodeInRegion_1.default;
var Position_1 = __webpack_require__(/*! ./selection/Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
exports.Position = Position_1.default;
var createRange_1 = __webpack_require__(/*! ./selection/createRange */ "./node_modules/roosterjs-editor-dom/lib/selection/createRange.js");
exports.createRange = createRange_1.default;
exports.getRangeFromSelectionPath = createRange_1.getRangeFromSelectionPath;
var getPositionRect_1 = __webpack_require__(/*! ./selection/getPositionRect */ "./node_modules/roosterjs-editor-dom/lib/selection/getPositionRect.js");
exports.getPositionRect = getPositionRect_1.default;
var isPositionAtBeginningOf_1 = __webpack_require__(/*! ./selection/isPositionAtBeginningOf */ "./node_modules/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.js");
exports.isPositionAtBeginningOf = isPositionAtBeginningOf_1.default;
var getSelectionPath_1 = __webpack_require__(/*! ./selection/getSelectionPath */ "./node_modules/roosterjs-editor-dom/lib/selection/getSelectionPath.js");
exports.getSelectionPath = getSelectionPath_1.default;
var getHtmlWithSelectionPath_1 = __webpack_require__(/*! ./selection/getHtmlWithSelectionPath */ "./node_modules/roosterjs-editor-dom/lib/selection/getHtmlWithSelectionPath.js");
exports.getHtmlWithSelectionPath = getHtmlWithSelectionPath_1.default;
var setHtmlWithSelectionPath_1 = __webpack_require__(/*! ./selection/setHtmlWithSelectionPath */ "./node_modules/roosterjs-editor-dom/lib/selection/setHtmlWithSelectionPath.js");
exports.setHtmlWithSelectionPath = setHtmlWithSelectionPath_1.default;
var addSnapshot_1 = __webpack_require__(/*! ./snapshots/addSnapshot */ "./node_modules/roosterjs-editor-dom/lib/snapshots/addSnapshot.js");
exports.addSnapshot = addSnapshot_1.default;
var canMoveCurrentSnapshot_1 = __webpack_require__(/*! ./snapshots/canMoveCurrentSnapshot */ "./node_modules/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.js");
exports.canMoveCurrentSnapshot = canMoveCurrentSnapshot_1.default;
var clearProceedingSnapshots_1 = __webpack_require__(/*! ./snapshots/clearProceedingSnapshots */ "./node_modules/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.js");
exports.clearProceedingSnapshots = clearProceedingSnapshots_1.default;
var moveCurrentSnapsnot_1 = __webpack_require__(/*! ./snapshots/moveCurrentSnapsnot */ "./node_modules/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapsnot.js");
exports.moveCurrentSnapsnot = moveCurrentSnapsnot_1.default;
var createSnapshots_1 = __webpack_require__(/*! ./snapshots/createSnapshots */ "./node_modules/roosterjs-editor-dom/lib/snapshots/createSnapshots.js");
exports.createSnapshots = createSnapshots_1.default;
var HtmlSanitizer_1 = __webpack_require__(/*! ./htmlSanitizer/HtmlSanitizer */ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/HtmlSanitizer.js");
exports.HtmlSanitizer = HtmlSanitizer_1.default;
var htmlToDom_1 = __webpack_require__(/*! ./htmlSanitizer/htmlToDom */ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/htmlToDom.js");
exports.htmlToDom = htmlToDom_1.default;
exports.splitWithFragment = htmlToDom_1.splitWithFragment;
var getInheritableStyles_1 = __webpack_require__(/*! ./htmlSanitizer/getInheritableStyles */ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/getInheritableStyles.js");
exports.getInheritableStyles = getInheritableStyles_1.default;
var createDefaultHtmlSanitizerOptions_1 = __webpack_require__(/*! ./htmlSanitizer/createDefaultHtmlSanitizerOptions */ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/createDefaultHtmlSanitizerOptions.js");
exports.createDefaultHtmlSanitizerOptions = createDefaultHtmlSanitizerOptions_1.default;
var chainSanitizerCallback_1 = __webpack_require__(/*! ./htmlSanitizer/chainSanitizerCallback */ "./node_modules/roosterjs-editor-dom/lib/htmlSanitizer/chainSanitizerCallback.js");
exports.chainSanitizerCallback = chainSanitizerCallback_1.default;
var isDocumentFragment_1 = __webpack_require__(/*! ./typeUtils/isDocumentFragment */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isDocumentFragment.js");
exports.isDocumentFragment = isDocumentFragment_1.default;
var isHTMLElement_1 = __webpack_require__(/*! ./typeUtils/isHTMLElement */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLElement.js");
exports.isHTMLElement = isHTMLElement_1.default;
var isHTMLOListElement_1 = __webpack_require__(/*! ./typeUtils/isHTMLOListElement */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLOListElement.js");
exports.isHTMLOListElement = isHTMLOListElement_1.default;
var isHTMLTableCellElement_1 = __webpack_require__(/*! ./typeUtils/isHTMLTableCellElement */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLTableCellElement.js");
exports.isHTMLTableCellElement = isHTMLTableCellElement_1.default;
var isHTMLTableElement_1 = __webpack_require__(/*! ./typeUtils/isHTMLTableElement */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLTableElement.js");
exports.isHTMLTableElement = isHTMLTableElement_1.default;
var isNode_1 = __webpack_require__(/*! ./typeUtils/isNode */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isNode.js");
exports.isNode = isNode_1.default;
var isRange_1 = __webpack_require__(/*! ./typeUtils/isRange */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isRange.js");
exports.isRange = isRange_1.default;
var safeInstanceOf_1 = __webpack_require__(/*! ./typeUtils/safeInstanceOf */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/safeInstanceOf.js");
exports.safeInstanceOf = safeInstanceOf_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.js":
/*!************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents an empty InlineElement.
 * This is used for ContentTraverser internally only.
 * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element
 */
var EmptyInlineElement = /** @class */ (function () {
    function EmptyInlineElement(position, parentBlock) {
        this.position = position;
        this.parentBlock = parentBlock;
    }
    /**
     * Get the text content of this inline element
     */
    EmptyInlineElement.prototype.getTextContent = function () {
        return '';
    };
    /**
     * Get the container node of this inline element
     */
    EmptyInlineElement.prototype.getContainerNode = function () {
        return this.position.node;
    };
    /**
     * Get the parent block element of this inline element
     */
    EmptyInlineElement.prototype.getParentBlock = function () {
        return this.parentBlock;
    };
    /**
     * Get the start position of this inline element
     */
    EmptyInlineElement.prototype.getStartPosition = function () {
        return this.position;
    };
    /**
     * Get the end position of this inline element
     */
    EmptyInlineElement.prototype.getEndPosition = function () {
        return this.position;
    };
    /**
     * Checks if the given inline element is after this inline element
     */
    EmptyInlineElement.prototype.isAfter = function (inlineElement) {
        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());
    };
    /**
     * Checks if this inline element is a textual inline element
     */
    EmptyInlineElement.prototype.isTextualInlineElement = function () {
        return false;
    };
    /**
     * Checks if the given editor position is contained in this inline element
     */
    EmptyInlineElement.prototype.contains = function (position) {
        return false;
    };
    /**
     * Apply inline style to a region of an inline element.
     */
    EmptyInlineElement.prototype.applyStyle = function (styler) { };
    return EmptyInlineElement;
}());
exports.default = EmptyInlineElement;
//# sourceMappingURL=EmptyInlineElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.js":
/*!************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var NodeInlineElement_1 = __webpack_require__(/*! ./NodeInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.js");
/**
 * This is an inline element representing an Html image
 */
var ImageInlineElement = /** @class */ (function (_super) {
    __extends(ImageInlineElement, _super);
    function ImageInlineElement(containerNode, parentBlock) {
        return _super.call(this, containerNode, parentBlock) || this;
    }
    return ImageInlineElement;
}(NodeInlineElement_1.default));
exports.default = ImageInlineElement;
//# sourceMappingURL=ImageInlineElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var NodeInlineElement_1 = __webpack_require__(/*! ./NodeInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.js");
/**
 * This is inline element presenting an html hyperlink
 */
var LinkInlineElement = /** @class */ (function (_super) {
    __extends(LinkInlineElement, _super);
    function LinkInlineElement(containerNode, parentBlock) {
        return _super.call(this, containerNode, parentBlock) || this;
    }
    return LinkInlineElement;
}(NodeInlineElement_1.default));
exports.default = LinkInlineElement;
//# sourceMappingURL=LinkInlineElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var applyTextStyle_1 = __webpack_require__(/*! ../utils/applyTextStyle */ "./node_modules/roosterjs-editor-dom/lib/utils/applyTextStyle.js");
var isNodeAfter_1 = __webpack_require__(/*! ../utils/isNodeAfter */ "./node_modules/roosterjs-editor-dom/lib/utils/isNodeAfter.js");
var Position_1 = __webpack_require__(/*! ../selection/Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
/**
 * This presents an inline element that can be reprented by a single html node.
 * This serves as base for most inline element as it contains most implentation
 * of all operations that can happen on an inline element. Other sub inline elements mostly
 * just identify themself for a certain type
 */
var NodeInlineElement = /** @class */ (function () {
    function NodeInlineElement(containerNode, parentBlock) {
        this.containerNode = containerNode;
        this.parentBlock = parentBlock;
    }
    /**
     * The text content for this inline element
     */
    NodeInlineElement.prototype.getTextContent = function () {
        // nodeValue is better way to retrieve content for a text. Others, just use textContent
        return this.containerNode.nodeType == 3 /* Text */
            ? this.containerNode.nodeValue
            : this.containerNode.textContent;
    };
    /**
     * Get the container node
     */
    NodeInlineElement.prototype.getContainerNode = function () {
        return this.containerNode;
    };
    // Get the parent block
    NodeInlineElement.prototype.getParentBlock = function () {
        return this.parentBlock;
    };
    /**
     * Get the start position of the inline element
     */
    NodeInlineElement.prototype.getStartPosition = function () {
        // For a position, we always want it to point to a leaf node
        // We should try to go get the lowest first child node from the container
        return new Position_1.default(this.containerNode, 0).normalize();
    };
    /**
     * Get the end position of the inline element
     */
    NodeInlineElement.prototype.getEndPosition = function () {
        // For a position, we always want it to point to a leaf node
        // We should try to go get the lowest last child node from the container
        return new Position_1.default(this.containerNode, -1 /* End */).normalize();
    };
    /**
     * Checks if this inline element is a textual inline element
     */
    NodeInlineElement.prototype.isTextualInlineElement = function () {
        return this.containerNode && this.containerNode.nodeType == 3 /* Text */;
    };
    /**
     * Checks if an inline element is after the current inline element
     */
    NodeInlineElement.prototype.isAfter = function (inlineElement) {
        return inlineElement && isNodeAfter_1.default(this.containerNode, inlineElement.getContainerNode());
    };
    /**
     * Checks if the given position is contained in the inline element
     */
    NodeInlineElement.prototype.contains = function (pos) {
        var start = this.getStartPosition();
        var end = this.getEndPosition();
        return pos && pos.isAfter(start) && end.isAfter(pos);
    };
    /**
     * Apply inline style to an inline element
     */
    NodeInlineElement.prototype.applyStyle = function (styler) {
        applyTextStyle_1.default(this.containerNode, styler);
    };
    return NodeInlineElement;
}());
exports.default = NodeInlineElement;
//# sourceMappingURL=NodeInlineElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var applyTextStyle_1 = __webpack_require__(/*! ../utils/applyTextStyle */ "./node_modules/roosterjs-editor-dom/lib/utils/applyTextStyle.js");
var createRange_1 = __webpack_require__(/*! ../selection/createRange */ "./node_modules/roosterjs-editor-dom/lib/selection/createRange.js");
var Position_1 = __webpack_require__(/*! ../selection/Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
var getLeafSibling_1 = __webpack_require__(/*! ../utils/getLeafSibling */ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafSibling.js");
/**
 * This is a special version of inline element that identifies a section of an inline element
 * We often have the need to cut an inline element in half and perform some operation only on half of an inline element
 * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element
 * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter
 * It also offers some special methods that others don't have, i.e. nextInlineElement etc.
 */
var PartialInlineElement = /** @class */ (function () {
    function PartialInlineElement(inlineElement, start, end) {
        this.inlineElement = inlineElement;
        this.start = start;
        this.end = end;
    }
    /**
     * Get the full inline element that this partial inline decorates
     */
    PartialInlineElement.prototype.getDecoratedInline = function () {
        return this.inlineElement;
    };
    /**
     * Gets the container node
     */
    PartialInlineElement.prototype.getContainerNode = function () {
        return this.inlineElement.getContainerNode();
    };
    /**
     * Gets the parent block
     */
    PartialInlineElement.prototype.getParentBlock = function () {
        return this.inlineElement.getParentBlock();
    };
    /**
     * Gets the text content
     */
    PartialInlineElement.prototype.getTextContent = function () {
        var range = createRange_1.default(this.getStartPosition(), this.getEndPosition());
        return range.toString();
    };
    /**
     * Get start position of this inline element.
     */
    PartialInlineElement.prototype.getStartPosition = function () {
        return this.start || this.inlineElement.getStartPosition();
    };
    /**
     * Get end position of this inline element.
     */
    PartialInlineElement.prototype.getEndPosition = function () {
        return this.end || this.inlineElement.getEndPosition();
    };
    Object.defineProperty(PartialInlineElement.prototype, "nextInlineElement", {
        /**
         * Get next partial inline element if it is not at the end boundary yet
         */
        get: function () {
            return this.end && new PartialInlineElement(this.inlineElement, this.end, null);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PartialInlineElement.prototype, "previousInlineElement", {
        /**
         * Get previous partial inline element if it is not at the begin boundary yet
         */
        get: function () {
            return this.start && new PartialInlineElement(this.inlineElement, null, this.start);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if it contains a position
     */
    PartialInlineElement.prototype.contains = function (pos) {
        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);
    };
    /**
     * Checks if this inline element is a textual inline element
     */
    PartialInlineElement.prototype.isTextualInlineElement = function () {
        return this.inlineElement && this.inlineElement.isTextualInlineElement();
    };
    /**
     * Check if this inline element is after the other inline element
     */
    PartialInlineElement.prototype.isAfter = function (inlineElement) {
        var thisStart = this.getStartPosition();
        var otherEnd = inlineElement && inlineElement.getEndPosition();
        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));
    };
    /**
     * apply style
     */
    PartialInlineElement.prototype.applyStyle = function (styler) {
        var from = this.getStartPosition().normalize();
        var to = this.getEndPosition().normalize();
        var container = this.getContainerNode();
        if (from.isAtEnd) {
            var nextNode = getLeafSibling_1.getNextLeafSibling(container, from.node);
            from = nextNode ? new Position_1.default(nextNode, 0 /* Begin */) : null;
        }
        if (to.offset == 0) {
            var previousNode = getLeafSibling_1.getPreviousLeafSibling(container, to.node);
            to = previousNode ? new Position_1.default(previousNode, -1 /* End */) : null;
        }
        applyTextStyle_1.default(container, styler, from, to);
    };
    return PartialInlineElement;
}());
exports.default = PartialInlineElement;
//# sourceMappingURL=PartialInlineElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getInlineElementAtNode_1 = __webpack_require__(/*! ./getInlineElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.js");
var getLeafNode_1 = __webpack_require__(/*! ../utils/getLeafNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafNode.js");
/**
 * Get the first inline element inside the given node
 */
function getFirstInlineElement(rootNode) {
    // getFirstLeafNode can return null for empty container
    // do check null before passing on to get inline from the node
    var node = getLeafNode_1.getFirstLeafNode(rootNode);
    return node ? getInlineElementAtNode_1.default(rootNode, node) : null;
}
exports.getFirstInlineElement = getFirstInlineElement;
/**
 * Get the last inline element inside the given node
 */
function getLastInlineElement(rootNode) {
    // getLastLeafNode can return null for empty container
    // do check null before passing on to get inline from the node
    var node = getLeafNode_1.getLastLeafNode(rootNode);
    return node ? getInlineElementAtNode_1.default(rootNode, node) : null;
}
exports.getLastInlineElement = getLastInlineElement;
//# sourceMappingURL=getFirstLastInlineElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getBlockElementAtNode_1 = __webpack_require__(/*! ../blockElements/getBlockElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.js");
var getTagOfNode_1 = __webpack_require__(/*! ../utils/getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var ImageInlineElement_1 = __webpack_require__(/*! ./ImageInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.js");
var isNode_1 = __webpack_require__(/*! ../typeUtils/isNode */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isNode.js");
var LinkInlineElement_1 = __webpack_require__(/*! ./LinkInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.js");
var NodeInlineElement_1 = __webpack_require__(/*! ./NodeInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.js");
function getInlineElementAtNode(parent, node) {
    // An inline element has to be in a block element, get the block first and then resolve through the factory
    var parentBlock = isNode_1.default(parent) ? getBlockElementAtNode_1.default(parent, node) : parent;
    return node && parentBlock && resolveInlineElement(node, parentBlock);
}
exports.default = getInlineElementAtNode;
/**
 * Resolve an inline element by a leaf node
 * @param node The node to resolve from
 * @param parentBlock The parent block element
 */
function resolveInlineElement(node, parentBlock) {
    var nodeChain = [node];
    for (var parent_1 = node.parentNode; parent_1 && parentBlock.contains(parent_1); parent_1 = parent_1.parentNode) {
        nodeChain.push(parent_1);
    }
    var inlineElement;
    for (var i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {
        var currentNode = nodeChain[i];
        var tag = getTagOfNode_1.default(currentNode);
        if (tag == 'A') {
            inlineElement = new LinkInlineElement_1.default(currentNode, parentBlock);
        }
        else if (tag == 'IMG') {
            inlineElement = new ImageInlineElement_1.default(currentNode, parentBlock);
        }
    }
    return inlineElement || new NodeInlineElement_1.default(node, parentBlock);
}
//# sourceMappingURL=getInlineElementAtNode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getInlineElementAtNode_1 = __webpack_require__(/*! ./getInlineElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.js");
var PartialInlineElement_1 = __webpack_require__(/*! ./PartialInlineElement */ "./node_modules/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.js");
var shouldSkipNode_1 = __webpack_require__(/*! ../utils/shouldSkipNode */ "./node_modules/roosterjs-editor-dom/lib/utils/shouldSkipNode.js");
var getLeafSibling_1 = __webpack_require__(/*! ../utils/getLeafSibling */ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafSibling.js");
/**
 * Get inline element before a position
 * This is mostly used when we want to get the inline element before selection/cursor
 * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)
 * in this case, we only want to return what is before cursor (a partial of an inline) to indicate
 * that we're in middle.
 * @param root Root node of current scope, use for create InlineElement
 * @param position The position to get InlineElement before
 */
function getInlineElementBefore(root, position) {
    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);
}
exports.getInlineElementBefore = getInlineElementBefore;
/**
 * Get inline element after a position
 * This is mostly used when we want to get the inline element after selection/cursor
 * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)
 * in this case, we only want to return what is before cursor (a partial of an inline) to indicate
 * that we're in middle.
 * @param root Root node of current scope, use for create InlineElement
 * @param position The position to get InlineElement after
 */
function getInlineElementAfter(root, position) {
    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);
}
exports.getInlineElementAfter = getInlineElementAfter;
function getInlineElementBeforeAfter(root, position, isAfter) {
    if (!root || !position || !position.node) {
        return null;
    }
    position = position.normalize();
    var node = position.node, offset = position.offset, isAtEnd = position.isAtEnd;
    var isPartial = false;
    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {
        node = getLeafSibling_1.getLeafSibling(root, node, isAfter);
    }
    else if (node.nodeType == 3 /* Text */ &&
        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))) {
        isPartial = true;
    }
    if (node && shouldSkipNode_1.default(node)) {
        node = getLeafSibling_1.getLeafSibling(root, node, isAfter);
    }
    var inlineElement = getInlineElementAtNode_1.default(root, node);
    if (inlineElement && (isPartial || inlineElement.contains(position))) {
        inlineElement = isAfter
            ? new PartialInlineElement_1.default(inlineElement, position, null)
            : new PartialInlineElement_1.default(inlineElement, null, position);
    }
    return inlineElement;
}
exports.getInlineElementBeforeAfter = getInlineElementBeforeAfter;
//# sourceMappingURL=getInlineElementBeforeAfter.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/list/VList.js":
/*!*************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/list/VList.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var changeElementTag_1 = __webpack_require__(/*! ../utils/changeElementTag */ "./node_modules/roosterjs-editor-dom/lib/utils/changeElementTag.js");
var getListTypeFromNode_1 = __webpack_require__(/*! ./getListTypeFromNode */ "./node_modules/roosterjs-editor-dom/lib/list/getListTypeFromNode.js");
var getTagOfNode_1 = __webpack_require__(/*! ../utils/getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var isBlockElement_1 = __webpack_require__(/*! ../utils/isBlockElement */ "./node_modules/roosterjs-editor-dom/lib/utils/isBlockElement.js");
var isNodeEmpty_1 = __webpack_require__(/*! ../utils/isNodeEmpty */ "./node_modules/roosterjs-editor-dom/lib/utils/isNodeEmpty.js");
var Position_1 = __webpack_require__(/*! ../selection/Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
var queryElements_1 = __webpack_require__(/*! ../utils/queryElements */ "./node_modules/roosterjs-editor-dom/lib/utils/queryElements.js");
var splitParentNode_1 = __webpack_require__(/*! ../utils/splitParentNode */ "./node_modules/roosterjs-editor-dom/lib/utils/splitParentNode.js");
var toArray_1 = __webpack_require__(/*! ../utils/toArray */ "./node_modules/roosterjs-editor-dom/lib/utils/toArray.js");
var unwrap_1 = __webpack_require__(/*! ../utils/unwrap */ "./node_modules/roosterjs-editor-dom/lib/utils/unwrap.js");
var VListItem_1 = __webpack_require__(/*! ./VListItem */ "./node_modules/roosterjs-editor-dom/lib/list/VListItem.js");
var wrap_1 = __webpack_require__(/*! ../utils/wrap */ "./node_modules/roosterjs-editor-dom/lib/utils/wrap.js");
/**
 * Represent a bullet or a numbering list
 *
 * @example
 * A VList is a logical representation of list items, it contains an item array with node and list type stack.
 * e.g. We have a list like this
 * ```html
 * <ol>
 *   <li>item 1</li>
 *   <li>item 2</li>
 *   <ul>
 *     <li>item 2.1</li>
 *     <li>item 2.2</li>
 *   <ul>
 * </ol>
 * ```
 *
 * A VList of this list will be like this:
 * ```javascript
 * {
 *   rootList: (OL node),
 *   items: [{
 *       node: (LI node with 'item 1'),
 *       listTypes: [null, OL],
 *     }, {
 *       node: (LI node with 'item 2'),
 *       listTypes: [null, OL],
 *     }, {
 *       node: (LI node with 'item 2.1),
 *       listTypes: [null, OL, UL],
 *     }, {
 *       node: (LI node with 'item 2.2'),
 *       listTypes: [null, OL, UL],
 *     }
 *   ]
 * }
 * ```
 *
 * When we want to outdent item 2.1, we just need to remove the last "UL" from listTypes of item 2.1, then
 * the writeBack() function will handle everything related to DOM change
 */
var VList = /** @class */ (function () {
    /**
     * Create a new instance of VList class
     * @param rootList The root list element, can be either OL or UL tag
     */
    function VList(rootList) {
        this.rootList = rootList;
        this.items = [];
        if (!rootList) {
            throw new Error('rootList must not be null');
        }
        // Before populate items, we need to normalize the list to make sure it is in a correct format
        // otherwise further action may mass thing up.
        //
        // There are two kinds of normalization to perform.
        // 1. Move nodes directly under OL/UL into a LI node, unless it is an orphan node
        // Please see comment for VListItem.isOrphanItem() for more information about orphan node
        // e.g.:
        // ```HTML
        // <ol>
        //   <li>item 1</li>
        //   <div>item 2</div>
        // </ol>
        // ```
        // After this step, it should become:
        // ```html
        // <ol>
        //   <li>item 1
        //     <div>item 2</div>
        //   <li>
        // </ol>
        // ```
        moveChildNodesToLi(this.rootList);
        queryElements_1.default(this.rootList, 'ol,ul', moveChildNodesToLi);
        // 2. Move LI node embeded into another LI node out to directly under OL/UL node
        // Ideally browser we do this for us automatically when out the HTML into DOM. However after
        // step 1, it is possible that we move some LI node into another one. e.g:
        // ```HTML
        // <ol>
        //   <li>item 1</li>
        //   <div>
        //     item 1.1
        //     <li>item 3</li>
        //   </div>
        // </ol>
        // ```
        // See that the second LI tag is not directly under OL, so after step 1, this will become:
        // ```html
        // <ol>
        //   <li>item 1
        //     <div>
        //       item 1.1
        //       <li>item 2</li>
        //     </div>
        //   <li>
        // </ol>
        // ```
        // Now we have a LI tag embeded into another LI tag. So we need step 2 to move the inner LI tag out to be:
        // ```html
        // <ol>
        //   <li>item1
        //     <div>item 1.1</div>
        //   </li>
        //   <li><div>item2</div></li>
        // </ol>
        // ```
        queryElements_1.default(this.rootList, 'li', moveLiToList);
        this.populateItems(this.rootList);
    }
    /**
     * Check if this list contains the given node
     * @param node The node to check
     */
    VList.prototype.contains = function (node) {
        // We don't check if the node is contained by this.rootList here, because after some operation,
        // it is possible a node is logically contained by this list but the container list item hasn't
        // been put under this.rootList in DOM tree yet.
        return this.items.some(function (item) { return item.contains(node); });
    };
    /**
     * Get the first or last node of this list
     * @param isLast true to get last node, false to get first node
     */
    VList.prototype.getFirstOrLastNode = function (isLast) {
        var item = this.items[isLast ? this.items.length - 1 : 0];
        return item === null || item === void 0 ? void 0 : item.getNode();
    };
    /**
     * Write the result back into DOM tree
     * After that, this VList becomes unavailable because we set this.rootList to null
     */
    VList.prototype.writeBack = function () {
        if (!this.rootList) {
            throw new Error('rootList must not be null');
        }
        var listStack = [this.rootList.ownerDocument.createDocumentFragment()];
        this.items.forEach(function (item) { return item.writeBack(listStack); });
        this.rootList.parentNode.replaceChild(listStack[0], this.rootList);
        // Set rootList to null to avoid this to be called again for the same VList, because
        // after change the rootList may not be available any more (e.g. outdent all items).
        this.rootList = null;
    };
    /**
     * Set indentation of the given range of this list
     * @param start Start position to operate from
     * @param end End positon to operate to
     * @param indentation Indent or outdent
     */
    VList.prototype.setIndentation = function (start, end, indentation) {
        this.findListItems(start, end, function (item) {
            return indentation == 1 /* Decrease */ ? item.outdent() : item.indent();
        });
    };
    /**
     * Change list type of the given range of this list.
     * If some of the items are not real list item yet, this will make them to be list item with given type
     * If all items in the given range are already in the type to change to, this becomes an outdent operation
     * @param start Start position to operate from
     * @param end End position to operate to
     * @param targetType Target list type
     */
    VList.prototype.changeListType = function (start, end, targetType) {
        var needChangeType = false;
        this.findListItems(start, end, function (item) {
            needChangeType = needChangeType || item.getListType() != targetType;
        });
        this.findListItems(start, end, function (item) {
            return needChangeType ? item.changeListType(targetType) : item.outdent();
        });
    };
    /**
     * Append a new item to this VList
     * @param node node of the item to append. If it is not wrapped with LI tag, it will be wrapped
     * @param type Type of this list item, can be ListType.None
     */
    VList.prototype.appendItem = function (node, type) {
        var newListNode = node;
        var nodeTag = getTagOfNode_1.default(node);
        if (nodeTag != 'LI' && nodeTag != 'TABLE') {
            newListNode = changeElementTag_1.default(node, 'LI');
        }
        else if (nodeTag == 'TABLE') {
            newListNode = wrap_1.default(node, 'li');
        }
        this.items.push(type == 0 /* None */ ? new VListItem_1.default(newListNode) : new VListItem_1.default(newListNode, type));
    };
    /**
     * Merge the given VList into current VList.
     * - All list items will be removed from the given VList and added into this list.
     * - The root node of the given VList will be removed from DOM tree
     * - If there are orphan items in the given VList, they will be merged into the last item
     *   of this list if any.
     * @param list The vList to merge from
     */
    VList.prototype.mergeVList = function (list) {
        var _this = this;
        var _a;
        if (list && list != this) {
            var originalLength = this.items.length;
            list.items.forEach(function (item) { return _this.items.push(item); });
            list.items.splice(0, list.items.length);
            this.mergeOrphanNodesAfter(originalLength - 1);
            (_a = list.rootList.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(list.rootList);
        }
    };
    VList.prototype.mergeOrphanNodesAfter = function (startIndex) {
        var item = this.items[startIndex];
        if (item && !item.isOrphanItem()) {
            for (var i = startIndex + 1; i <= this.items.length; i++) {
                if (!item || !item.canMerge(this.items[i])) {
                    item.mergeItems(this.items.splice(startIndex + 1, i - startIndex - 1));
                    break;
                }
            }
        }
    };
    VList.prototype.findListItems = function (start, end, callback) {
        if (this.items.length == 0) {
            return [];
        }
        var listStartPos = new Position_1.default(this.items[0].getNode(), 0 /* Begin */);
        var listEndPos = new Position_1.default(this.items[this.items.length - 1].getNode(), -1 /* End */);
        var startIndex = listStartPos.isAfter(start) ? 0 : -1;
        var endIndex = this.items.length - (end.isAfter(listEndPos) ? 1 : 0);
        this.items.forEach(function (item, index) {
            startIndex = item.contains(start.node) ? index : startIndex;
            endIndex = item.contains(end.node) ? index : endIndex;
        });
        startIndex = endIndex < this.items.length ? Math.max(0, startIndex) : startIndex;
        endIndex = startIndex >= 0 ? Math.min(this.items.length - 1, endIndex) : endIndex;
        var result = startIndex <= endIndex ? this.items.slice(startIndex, endIndex + 1) : [];
        if (callback) {
            result.forEach(callback);
            this.mergeOrphanNodesAfter(endIndex);
        }
        return result;
    };
    VList.prototype.populateItems = function (list, listTypes) {
        if (listTypes === void 0) { listTypes = []; }
        var type = getListTypeFromNode_1.default(list);
        for (var item = list.firstChild; !!item; item = item.nextSibling) {
            var newListTypes = __spreadArrays(listTypes, [type]);
            if (getListTypeFromNode_1.isListElement(item)) {
                this.populateItems(item, newListTypes);
            }
            else if (item.nodeType != 3 /* Text */ || item.nodeValue.trim() != '') {
                this.items.push(new (VListItem_1.default.bind.apply(VListItem_1.default, __spreadArrays([void 0, item], newListTypes)))());
            }
        }
    };
    return VList;
}());
exports.default = VList;
//Normalization
// Step 1: Move all non-LI direct children under list into LI
// e.g.
// From: <ul><li>line 1</li>line 2</ul>
// To:   <ul><li>line 1<div>line 2</div></li></ul>
function moveChildNodesToLi(list) {
    var currentItem = null;
    toArray_1.default(list.childNodes).forEach(function (child) {
        if (getTagOfNode_1.default(child) == 'LI') {
            currentItem = child;
        }
        else if (getListTypeFromNode_1.isListElement(child)) {
            currentItem = null;
        }
        else if (currentItem && !isNodeEmpty_1.default(child, true /*trimContent*/)) {
            currentItem.appendChild(isBlockElement_1.default(child) ? child : wrap_1.default(child));
        }
    });
}
// Step 2: Move nested LI up to under list directly
// e.g.
// From: <ul><li>line 1<li>line 2</li>line 3</li></ul>
// To:   <ul><li>line 1</li><li>line 2<div>line 3</div></li></ul>
function moveLiToList(li) {
    while (!getListTypeFromNode_1.isListElement(li.parentNode)) {
        splitParentNode_1.default(li, true /*splitBefore*/);
        var furtherNodes = toArray_1.default(li.parentNode.childNodes).slice(1);
        if (furtherNodes.length > 0) {
            if (!isBlockElement_1.default(furtherNodes[0])) {
                furtherNodes = [wrap_1.default(furtherNodes)];
            }
            furtherNodes.forEach(function (node) { return li.appendChild(node); });
        }
        unwrap_1.default(li.parentNode);
    }
}
//# sourceMappingURL=VList.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/list/VListItem.js":
/*!*****************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/list/VListItem.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = __webpack_require__(/*! ../utils/contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
var getListTypeFromNode_1 = __webpack_require__(/*! ./getListTypeFromNode */ "./node_modules/roosterjs-editor-dom/lib/list/getListTypeFromNode.js");
var getTagOfNode_1 = __webpack_require__(/*! ../utils/getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var isBlockElement_1 = __webpack_require__(/*! ../utils/isBlockElement */ "./node_modules/roosterjs-editor-dom/lib/utils/isBlockElement.js");
var toArray_1 = __webpack_require__(/*! ../utils/toArray */ "./node_modules/roosterjs-editor-dom/lib/utils/toArray.js");
var unwrap_1 = __webpack_require__(/*! ../utils/unwrap */ "./node_modules/roosterjs-editor-dom/lib/utils/unwrap.js");
var wrap_1 = __webpack_require__(/*! ../utils/wrap */ "./node_modules/roosterjs-editor-dom/lib/utils/wrap.js");
var orderListStyles = [null, 'lower-alpha', 'lower-roman'];
/**
 * @internal
 * !!! Never directly create instance of this class. It should be created within VList class !!!
 *
 * Represent a list item.
 *
 * A list item is normally wrapped using a LI tag. But this class is only a logical item,
 * it can be a LI tag, or another other type of node which means it is actually not a list item.
 * That can happen after we do "outdent" on a 1-level list item, then it becomes not a list item.
 * @internal
 */
var VListItem = /** @class */ (function () {
    /**
     * Construct a new instance of VListItem class
     * @param node The DOM node for this item
     * @param listTypes An array represnets list types of all parent and current level.
     * Skip this parameter for a non-list item.
     */
    function VListItem(node) {
        var listTypes = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            listTypes[_i - 1] = arguments[_i];
        }
        this.node = node;
        if (!node) {
            throw new Error('node must not be null');
        }
        // Always add a None list type in front of all other types to represent non-list scenario.
        this.listTypes = __spreadArrays([0 /* None */], listTypes);
    }
    /**
     * Get type of current list item
     */
    VListItem.prototype.getListType = function () {
        return this.listTypes[this.listTypes.length - 1];
    };
    /**
     * Get DOM node of this list item
     */
    VListItem.prototype.getNode = function () {
        return this.node;
    };
    /**
     * Check if a given node is contained by this list item
     * @param node The node to check
     */
    VListItem.prototype.contains = function (node) {
        return contains_1.default(this.node, node, true /*treateSameNodeAsContain*/);
    };
    /**
     * Check if this item is an orphan item.
     *
     * Orphan item is not a normal case but could happen. It represents the DOM nodes directly under OL/UL tag
     * and are in front of all other LI tags so that they cannot be merged into any existing LI tags.
     *
     * For example:
     * ```html
     * <ol>
     *   <div>Orphan node</div>
     *   <li>first item</li>
     * </ol>
     * ```
     * Here the first DIV tag is an orphan item.
     *
     * There can also be nodes directly under OL/UL but between other LI tags in source HTML which should not be
     * treated as orphan item because they can be merged into their previous LI tag. But when we build VList,
     * those nodes will be merged into LI, so that ideally here they should not exist.
     */
    VListItem.prototype.isOrphanItem = function () {
        return getTagOfNode_1.default(this.node) != 'LI';
    };
    /**
     * Check if the given item can be merged into this item.
     * An item can be merged when it is an orphan item and its list type stack is exactly the same with current one.
     * @param item The item to check
     */
    VListItem.prototype.canMerge = function (item) {
        if (!(item === null || item === void 0 ? void 0 : item.isOrphanItem()) || this.listTypes.length != item.listTypes.length) {
            return false;
        }
        return this.listTypes.every(function (type, index) { return item.listTypes[index] == type; });
    };
    /**
     * Merge items into this item.
     * @example Before merge:
     * ```html
     * <ol>
     *   <li>Current item</li>
     *   <div>line 1</div>
     *   <div>line 2</div>
     * </ol>
     * ```
     * After merge then two DIVs into LI:
     * ```html
     * <ol>
     *   <li>Current item
     *     <div>line 1</div>
     *     <div>line 2</div>
     *   </li>
     * </ol>
     * ```
     * @param items The items to merge
     */
    VListItem.prototype.mergeItems = function (items) {
        var _this = this;
        var nodesToWrap = (items === null || items === void 0 ? void 0 : items.map(function (item) { return item.node; })) || [];
        var targetNodes = wrapIfNotBlockNode(nodesToWrap, true /*checkFirst*/, false /*checkLast*/);
        targetNodes.forEach(function (node) { return _this.node.appendChild(node); });
    };
    /**
     * Indent this item
     * If this is not an list item, it will be no op
     */
    VListItem.prototype.indent = function () {
        var listType = this.getListType();
        if (listType != 0 /* None */) {
            this.listTypes.push(listType);
        }
    };
    /**
     * Outdent this item
     * If this item is already not an list item, it will be no op
     */
    VListItem.prototype.outdent = function () {
        if (this.listTypes.length > 1) {
            this.listTypes.pop();
        }
    };
    /**
     * Change list type of this item
     * @param targetType The target list type to change to
     */
    VListItem.prototype.changeListType = function (targetType) {
        if (targetType == 0 /* None */) {
            this.listTypes = [targetType];
        }
        else {
            this.outdent();
            this.listTypes.push(targetType);
        }
    };
    /**
     * Write the change result back into DOM
     * @param listStack current stack of list elements
     */
    VListItem.prototype.writeBack = function (listStack) {
        var doc = this.node.ownerDocument;
        var nextLevel = 1;
        // 1. Determine list elements that we can reuse
        // e.g.:
        //    passed in listStack: Fragment > OL > UL > OL
        //    local listTypes:     null     > OL > UL > UL > OL
        //    then Fragment > OL > UL can be reused
        for (; nextLevel < listStack.length; nextLevel++) {
            if (getListTypeFromNode_1.default(listStack[nextLevel]) !== this.listTypes[nextLevel]) {
                listStack.splice(nextLevel);
                break;
            }
        }
        // 2. Add new list elements
        // e.g.:
        //    passed in listStack: Fragment > OL > UL
        //    local listTypes:     null     > OL > UL > UL > OL
        //    then we need to create a UL and a OL tag
        for (; nextLevel < this.listTypes.length; nextLevel++) {
            var listType = this.listTypes[nextLevel];
            var newList = doc.createElement(listType == 1 /* Ordered */ ? 'ol' : 'ul');
            if (listType == 1 /* Ordered */) {
                newList.style.listStyleType =
                    orderListStyles[(nextLevel - 1) % orderListStyles.length];
            }
            listStack[listStack.length - 1].appendChild(newList);
            listStack.push(newList);
        }
        // 3. Add current node into deepest list element
        listStack[listStack.length - 1].appendChild(this.node);
        // 4. If this is not a list item now, need to unwrap the LI node and do proper handling
        if (this.listTypes.length <= 1) {
            wrapIfNotBlockNode(getTagOfNode_1.default(this.node) == 'LI' ? getChildrenAndUnwrap(this.node) : [this.node], true /*checkFirst*/, true /*checkLast*/);
        }
    };
    return VListItem;
}());
exports.default = VListItem;
function wrapIfNotBlockNode(nodes, checkFirst, checkLast) {
    if (nodes.length > 0 &&
        (!checkFirst || !isBlockElement_1.default(nodes[0])) &&
        (!checkLast || !isBlockElement_1.default(nodes[nodes.length]))) {
        nodes = [wrap_1.default(nodes)];
    }
    return nodes;
}
function getChildrenAndUnwrap(node) {
    var result = toArray_1.default(node.childNodes);
    unwrap_1.default(node);
    return result;
}
//# sourceMappingURL=VListItem.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/list/createVListFromRegion.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/list/createVListFromRegion.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var findClosestElementAncestor_1 = __webpack_require__(/*! ../utils/findClosestElementAncestor */ "./node_modules/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.js");
var getSelectedBlockElementsInRegion_1 = __webpack_require__(/*! ../region/getSelectedBlockElementsInRegion */ "./node_modules/roosterjs-editor-dom/lib/region/getSelectedBlockElementsInRegion.js");
var isNodeInRegion_1 = __webpack_require__(/*! ../region/isNodeInRegion */ "./node_modules/roosterjs-editor-dom/lib/region/isNodeInRegion.js");
var shouldSkipNode_1 = __webpack_require__(/*! ../utils/shouldSkipNode */ "./node_modules/roosterjs-editor-dom/lib/utils/shouldSkipNode.js");
var VList_1 = __webpack_require__(/*! ./VList */ "./node_modules/roosterjs-editor-dom/lib/list/VList.js");
var getLeafSibling_1 = __webpack_require__(/*! ../utils/getLeafSibling */ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafSibling.js");
var getListTypeFromNode_1 = __webpack_require__(/*! ./getListTypeFromNode */ "./node_modules/roosterjs-editor-dom/lib/list/getListTypeFromNode.js");
var ListSelector = 'ol,ul';
/**
 * @internal
 * @param region The region to get VList from
 * @param includeSiblingLists True to also try get lists before and after the selection and merge them together,
 * false to only include the list for the selected blocks
 * @param startNode (Optional) When specified, try get VList which will contain this node.
 * If not specified, get VList from selection of this region
 */
function createVListFromRegion(region, includeSiblingLists, startNode) {
    if (!region) {
        return null;
    }
    var nodes = [];
    if (startNode) {
        var list = getRootListNode(region, startNode);
        if (list) {
            nodes.push(list);
        }
    }
    else {
        var blocks = getSelectedBlockElementsInRegion_1.default(region);
        blocks.forEach(function (block) {
            var list = getRootListNode(region, block.getStartNode());
            if (list) {
                if (nodes[nodes.length - 1] != list) {
                    nodes.push(list);
                }
            }
            else {
                nodes.push(block.collapseToSingleElement());
            }
        });
        if (includeSiblingLists) {
            tryIncludeSiblingNode(region, nodes, false /*isNext*/);
            tryIncludeSiblingNode(region, nodes, true /*isNext*/);
        }
        nodes = nodes.filter(function (node) { return !shouldSkipNode_1.default(node, true /*ignoreSpace*/); });
    }
    var vList = null;
    if (nodes.length > 0) {
        var firstNode = nodes.shift();
        vList = getListTypeFromNode_1.isListElement(firstNode)
            ? new VList_1.default(firstNode)
            : createVListFromItemNode(firstNode);
        nodes.forEach(function (node) {
            if (getListTypeFromNode_1.isListElement(node)) {
                vList.mergeVList(new VList_1.default(node));
            }
            else {
                vList.appendItem(node, 0 /* None */);
            }
        });
    }
    return vList;
}
exports.default = createVListFromRegion;
function tryIncludeSiblingNode(region, nodes, isNext) {
    var node = nodes[isNext ? nodes.length - 1 : 0];
    node = getLeafSibling_1.getLeafSibling(region.rootNode, node, isNext, region.skipTags, true /*ignoreSpace*/);
    node = getRootListNode(region, node);
    if (isNodeInRegion_1.default(region, node) && getListTypeFromNode_1.isListElement(node)) {
        if (isNext) {
            nodes.push(node);
        }
        else {
            nodes.unshift(node);
        }
    }
}
function getRootListNode(region, node) {
    var list = findClosestElementAncestor_1.default(node, region.rootNode, ListSelector);
    if (list) {
        var ancestor = void 0;
        while ((ancestor = findClosestElementAncestor_1.default(list.parentNode, region.rootNode, ListSelector))) {
            list = ancestor;
        }
    }
    return list;
}
function createVListFromItemNode(node) {
    var _a;
    // Create a temporary OL root element for this list.
    var listNode = node.ownerDocument.createElement('ol'); // Either OL or UL is ok here
    (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(listNode, node);
    // Create the VList and append items
    var vList = new VList_1.default(listNode);
    vList.appendItem(node, 0 /* None */);
    return vList;
}
//# sourceMappingURL=createVListFromRegion.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/list/getListTypeFromNode.js":
/*!***************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/list/getListTypeFromNode.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getTagOfNode_1 = __webpack_require__(/*! ../utils/getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
function getListTypeFromNode(node) {
    switch (getTagOfNode_1.default(node)) {
        case 'OL':
            return 1 /* Ordered */;
        case 'UL':
            return 2 /* Unordered */;
        default:
            return 0 /* None */;
    }
}
exports.default = getListTypeFromNode;
/**
 * @internal
 * Check if the given DOM node is a list element (OL or UL)
 * @param node The node to check
 */
function isListElement(node) {
    return getListTypeFromNode(node) != 0 /* None */;
}
exports.isListElement = isListElement;
//# sourceMappingURL=getListTypeFromNode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/region/collapseNodesInRegion.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/region/collapseNodesInRegion.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var collapseNodes_1 = __webpack_require__(/*! ../utils/collapseNodes */ "./node_modules/roosterjs-editor-dom/lib/utils/collapseNodes.js");
var isNodeInRegion_1 = __webpack_require__(/*! ./isNodeInRegion */ "./node_modules/roosterjs-editor-dom/lib/region/isNodeInRegion.js");
/**
 * Collapse nodes within this region to their common ascenstor node under this region
 * @param region The region to collapse nodes in.
 * @param nodes Nodes to collapse. All nodes not contained by the given region will be ignored.
 */
function collapseNodesInRegion(region, nodes) {
    nodes = nodes && nodes.filter(function (node) { return isNodeInRegion_1.default(region, node); });
    if (!nodes || nodes.length == 0) {
        return [];
    }
    var firstNode = nodes[0];
    var lastNode = nodes[nodes.length - 1];
    if (isNodeInRegion_1.default(region, firstNode) && isNodeInRegion_1.default(region, lastNode)) {
        return collapseNodes_1.default(region.rootNode, firstNode, lastNode, true /*canSplitParent*/);
    }
    else {
        return [];
    }
}
exports.default = collapseNodesInRegion;
//# sourceMappingURL=collapseNodesInRegion.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/region/getRegionsFromRange.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/region/getRegionsFromRange.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = __webpack_require__(/*! ../utils/contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
var findClosestElementAncestor_1 = __webpack_require__(/*! ../utils/findClosestElementAncestor */ "./node_modules/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.js");
var Position_1 = __webpack_require__(/*! ../selection/Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
var queryElements_1 = __webpack_require__(/*! ../utils/queryElements */ "./node_modules/roosterjs-editor-dom/lib/utils/queryElements.js");
var regionTypeData_1 = __webpack_require__(/*! ./regionTypeData */ "./node_modules/roosterjs-editor-dom/lib/region/regionTypeData.js");
var getLeafSibling_1 = __webpack_require__(/*! ../utils/getLeafSibling */ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafSibling.js");
/**
 * Get regions impacted by the given range under the root node
 * @param root Root node to get regions from
 * @param range A selection range. Regions will be created acording to this range. Each region will be
 * fully or partially covered by this range.
 * @param type Type of region. Currently we only support TABLE region.
 */
function getRegionsFromRange(root, range, type) {
    var regions = [];
    if (root && range) {
        var _a = regionTypeData_1.default[type], innerSelector = _a.innerSelector, skipTags = _a.skipTags;
        var boundaryTree = buildBoundaryTree(root, range, type);
        var start = findClosestElementAncestor_1.default(range.startContainer, root, innerSelector) || root;
        var end = findClosestElementAncestor_1.default(range.endContainer, root, innerSelector) || root;
        var creator = getRegionCreator(range, skipTags);
        regions = iterateNodes(creator, boundaryTree, start, end)[0];
    }
    return regions.filter(function (r) { return !!r; });
}
exports.default = getRegionsFromRange;
/**
 * @internal export for test only
 */
function getRegionCreator(fullRange, skipTags) {
    var fullSelectionStart = Position_1.default.getStart(fullRange).normalize();
    var fullSelectionEnd = Position_1.default.getEnd(fullRange).normalize();
    return function (rootNode, nodeBefore, nodeAfter) {
        return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)
            ? {
                rootNode: rootNode,
                nodeBefore: nodeBefore,
                nodeAfter: nodeAfter,
                skipTags: skipTags,
                fullSelectionStart: fullSelectionStart,
                fullSelectionEnd: fullSelectionEnd,
            }
            : null;
    };
}
exports.getRegionCreator = getRegionCreator;
/**
 * Step 1: Build boundary tree
 * @param root Root node of the whole scope, normally this will be the root of editable scope
 * @param range Existing selected full range
 * @param type Type of region to create
 */
function buildBoundaryTree(root, range, type) {
    var allBoundaries = [{ innerNode: root, children: [] }];
    var _a = regionTypeData_1.default[type], outerSelector = _a.outerSelector, innerSelector = _a.innerSelector;
    var inSelectionOuterNode = queryElements_1.default(root, outerSelector, null /*callback*/, 2 /* InSelection */, range);
    // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll
    // is in document order, which is what we expect. So we don't need to sort the result here.
    queryElements_1.default(root, innerSelector, function (thisInnerNode) {
        var thisOuterNode = findClosestElementAncestor_1.default(thisInnerNode, root, outerSelector);
        if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {
            var boundary = { innerNode: thisInnerNode, children: [] };
            for (var i = allBoundaries.length - 1; i >= 0; i--) {
                var _a = allBoundaries[i], innerNode = _a.innerNode, children = _a.children;
                if (contains_1.default(innerNode, thisOuterNode)) {
                    var child = children.filter(function (c) { return c.outerNode == thisOuterNode; })[0];
                    if (!child) {
                        child = { outerNode: thisOuterNode, boundaries: [] };
                        children.push(child);
                    }
                    child.boundaries.push(boundary);
                    break;
                }
            }
            allBoundaries.push(boundary);
        }
    }, 1 /* OnSelection */, range);
    return allBoundaries[0];
}
/**
 * Step 2: Recursively iterate all boundaries and create regions
 * @param creator A region creator function to help create region
 * @param boundary Current root boundary
 * @param start A node where full range start from. This may not be the direct node container of range.startContenter.
 * It is the nearest ancestor which satisfies the InnerSelector of the given region type
 * @param end A node where full range end from. This may not be the direct node container of range.endContenter.
 * It is the nearest ancestor which satisfies the InnerSelector of the given region type
 * @param started Whether we have already hit the start node
 */
function iterateNodes(creator, boundary, start, end, started) {
    var _a;
    started = started || boundary.innerNode == start;
    var ended = false;
    var children = boundary.children, innerNode = boundary.innerNode;
    var regions = [];
    if (children.length == 0) {
        regions.push(creator(innerNode));
    }
    else {
        // Need to run one more time to add region after all children
        for (var i = 0; i <= children.length && !ended; i++) {
            var _b = children[i] || {}, outerNode = _b.outerNode, boundaries = _b.boundaries;
            var previousOuterNode = (_a = children[i - 1]) === null || _a === void 0 ? void 0 : _a.outerNode;
            if (started) {
                regions.push(creator(innerNode, previousOuterNode, outerNode));
            }
            boundaries === null || boundaries === void 0 ? void 0 : boundaries.forEach(function (child) {
                var _a;
                var newRegions;
                _a = iterateNodes(creator, child, start, end, started), newRegions = _a[0], started = _a[1], ended = _a[2];
                regions = regions.concat(newRegions);
            });
        }
    }
    return [regions, started, ended || innerNode == end];
}
/**
 * Check if the given nodes combination is valid to create a region.
 * A combination is valid when:
 * 1. Root node is not null and is not empty. And
 * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And
 * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be
 * node between them.
 * @param root Root node of region
 * @param nodeBefore The boundary node before the region under root
 * @param nodeAfter The boundary node after the region under root
 * @param skipTags Tags to skip
 */
function areNodesValid(root, nodeBefore, nodeAfter, skipTags) {
    if (!root || !root.firstChild) {
        return false;
    }
    else {
        var firstNodeOfRegion = nodeBefore && getLeafSibling_1.getNextLeafSibling(root, nodeBefore, skipTags);
        var lastNodeOfRegion = nodeAfter && getLeafSibling_1.getPreviousLeafSibling(root, nodeAfter, skipTags);
        var firstNodeValid = !nodeBefore || (contains_1.default(root, nodeBefore) && contains_1.default(root, firstNodeOfRegion));
        var lastNodeValid = !nodeAfter || (contains_1.default(root, nodeAfter) && contains_1.default(root, lastNodeOfRegion));
        var bothValid = !nodeBefore ||
            !nodeAfter ||
            (!contains_1.default(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&
                !contains_1.default(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&
                !contains_1.default(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&
                !contains_1.default(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));
        return firstNodeValid && lastNodeValid && bothValid;
    }
}
//# sourceMappingURL=getRegionsFromRange.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/region/getSelectedBlockElementsInRegion.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/region/getSelectedBlockElementsInRegion.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ContentTraverser_1 = __webpack_require__(/*! ../contentTraverser/ContentTraverser */ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.js");
var createRange_1 = __webpack_require__(/*! ../selection/createRange */ "./node_modules/roosterjs-editor-dom/lib/selection/createRange.js");
var Position_1 = __webpack_require__(/*! ../selection/Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
var getLeafSibling_1 = __webpack_require__(/*! ../utils/getLeafSibling */ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafSibling.js");
/**
 * Get all block elements covered by the selection under this region
 */
function getSelectedBlockElementsInRegion(region) {
    if (!region) {
        return [];
    }
    var nodeBefore = region.nodeBefore, nodeAfter = region.nodeAfter, rootNode = region.rootNode, skipTags = region.skipTags, fullSelectionEnd = region.fullSelectionEnd, fullSelectionStart = region.fullSelectionStart;
    var startNode = nodeBefore
        ? getLeafSibling_1.getNextLeafSibling(region.rootNode, nodeBefore, region.skipTags)
        : rootNode.firstChild;
    var endNode = nodeAfter
        ? getLeafSibling_1.getPreviousLeafSibling(rootNode, nodeAfter, skipTags)
        : rootNode.lastChild;
    var blocks = [];
    if (startNode && endNode) {
        var regionRange = createRange_1.default(startNode, endNode);
        var regionStart = Position_1.default.getStart(regionRange).normalize();
        var regionEnd = Position_1.default.getEnd(regionRange).normalize();
        if (!fullSelectionStart.isAfter(regionEnd) && !regionStart.isAfter(fullSelectionEnd)) {
            var start = fullSelectionStart.isAfter(regionStart)
                ? fullSelectionStart
                : regionStart;
            var end = fullSelectionEnd.isAfter(regionEnd) ? regionEnd : fullSelectionEnd;
            var range = createRange_1.default(start, end);
            var traverser = ContentTraverser_1.default.createSelectionTraverser(rootNode, range, skipTags);
            for (var block = traverser === null || traverser === void 0 ? void 0 : traverser.currentBlockElement; !!block; block = traverser.getNextBlockElement()) {
                blocks.push(block);
            }
        }
    }
    return blocks;
}
exports.default = getSelectedBlockElementsInRegion;
//# sourceMappingURL=getSelectedBlockElementsInRegion.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/region/isNodeInRegion.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/region/isNodeInRegion.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = __webpack_require__(/*! ../utils/contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
/**
 * Check if a given node is contained by the given region
 * @param region The region to check from
 * @param node The node or block element to check
 */
function isNodeInRegion(region, node) {
    return !!(region &&
        contains_1.default(region.rootNode, node) &&
        (!region.nodeBefore ||
            region.nodeBefore.compareDocumentPosition(node) == 4 /* Following */) &&
        (!region.nodeAfter ||
            region.nodeAfter.compareDocumentPosition(node) == 2 /* Preceding */));
}
exports.default = isNodeInRegion;
//# sourceMappingURL=isNodeInRegion.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/region/regionTypeData.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/region/regionTypeData.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var regionTypeData = (_a = {},
    _a[0 /* Table */] = {
        skipTags: ['TABLE'],
        outerSelector: 'table',
        innerSelector: 'td,th',
    },
    _a);
/**
 * @internal
 */
exports.default = regionTypeData;
//# sourceMappingURL=regionTypeData.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js":
/*!*********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/selection/Position.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var findClosestElementAncestor_1 = __webpack_require__(/*! ../utils/findClosestElementAncestor */ "./node_modules/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.js");
var isNodeAfter_1 = __webpack_require__(/*! ../utils/isNodeAfter */ "./node_modules/roosterjs-editor-dom/lib/utils/isNodeAfter.js");
/**
 * Represent a position in DOM tree by the node and its offset index
 */
var Position = /** @class */ (function () {
    function Position(nodeOrPosition, offsetOrPosType, isFromEndOfRange) {
        this.isFromEndOfRange = isFromEndOfRange;
        if (nodeOrPosition.node) {
            this.node = nodeOrPosition.node;
            offsetOrPosType = nodeOrPosition.offset;
        }
        else {
            this.node = nodeOrPosition;
        }
        switch (offsetOrPosType) {
            case -2 /* Before */:
                this.offset = getIndexOfNode(this.node);
                this.node = this.node.parentNode;
                this.isAtEnd = false;
                break;
            case -3 /* After */:
                this.offset = getIndexOfNode(this.node) + 1;
                this.isAtEnd = !this.node.nextSibling;
                this.node = this.node.parentNode;
                break;
            case -1 /* End */:
                this.offset = getEndOffset(this.node);
                this.isAtEnd = true;
                break;
            default:
                var endOffset = getEndOffset(this.node);
                this.offset = Math.max(0, Math.min(offsetOrPosType, endOffset));
                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;
                break;
        }
        this.element = findClosestElementAncestor_1.default(this.node);
    }
    /**
     * Normalize this position to the leaf node, return the normalize result.
     * If current position is already using leaf node, return this position object itself
     */
    Position.prototype.normalize = function () {
        if (this.node.nodeType == 3 /* Text */ || !this.node.firstChild) {
            return this;
        }
        var node = this.node;
        var newOffset = this.isAtEnd
            ? -1 /* End */
            : this.offset;
        while (node.nodeType == 1 /* Element */) {
            var nextNode = this.isFromEndOfRange
                ? newOffset == -1 /* End */
                    ? node.lastChild
                    : node.childNodes[newOffset - 1]
                : newOffset == 0 /* Begin */
                    ? node.firstChild
                    : newOffset == -1 /* End */
                        ? node.lastChild
                        : node.childNodes[newOffset];
            if (nextNode) {
                node = nextNode;
                newOffset =
                    this.isAtEnd || this.isFromEndOfRange ? -1 /* End */ : 0 /* Begin */;
            }
            else {
                break;
            }
        }
        return new Position(node, newOffset, this.isFromEndOfRange);
    };
    /**
     * Check if this position is equal to the given position
     * @param position The position to check
     */
    Position.prototype.equalTo = function (position) {
        return (position &&
            (this == position ||
                (this.node == position.node &&
                    this.offset == position.offset &&
                    this.isAtEnd == position.isAtEnd)));
    };
    /**
     * Checks if this position is after the given position
     */
    Position.prototype.isAfter = function (position) {
        return this.node == position.node
            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset
            : isNodeAfter_1.default(this.node, position.node);
    };
    /**
     * Move this position with offset, returns a new position with a valid offset in the same node
     * @param offset Offset to move with
     */
    Position.prototype.move = function (offset) {
        return new Position(this.node, Math.max(this.offset + offset, 0));
    };
    /**
     * Get start position of the given Range
     * @param range The range to get position from
     */
    Position.getStart = function (range) {
        return new Position(range.startContainer, range.startOffset);
    };
    /**
     * Get end position of the given Range
     * @param range The range to get position from
     */
    Position.getEnd = function (range) {
        // For collapsed range, always return the same value of start container to make sure
        // end position is not before start position
        return range.collapsed
            ? Position.getStart(range)
            : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);
    };
    return Position;
}());
exports.default = Position;
function getIndexOfNode(node) {
    var i = 0;
    while ((node = node.previousSibling)) {
        i++;
    }
    return i;
}
function getEndOffset(node) {
    if (node.nodeType == 3 /* Text */) {
        return node.nodeValue.length;
    }
    else if (node.nodeType == 1 /* Element */) {
        return node.childNodes.length;
    }
    else {
        return 1;
    }
}
//# sourceMappingURL=Position.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/selection/createRange.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/selection/createRange.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isNode_1 = __webpack_require__(/*! ../typeUtils/isNode */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isNode.js");
var isVoidHtmlElement_1 = __webpack_require__(/*! ../utils/isVoidHtmlElement */ "./node_modules/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.js");
var Position_1 = __webpack_require__(/*! ./Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
function createRange(arg1, arg2, arg3, arg4) {
    var start;
    var end;
    if (isNodePosition(arg1)) {
        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;
        start = arg1;
        end = isNodePosition(arg2) ? arg2 : null;
    }
    else if (isNode_1.default(arg1)) {
        if (Array.isArray(arg2)) {
            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;
            start = getPositionFromPath(arg1, arg2);
            end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;
        }
        else if (typeof arg2 == 'number') {
            // function createRange(node: Node, offset: number | PositionType): Range;
            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;
            start = new Position_1.default(arg1, arg2);
            end = isNode_1.default(arg3) ? new Position_1.default(arg3, arg4) : null;
        }
        else if (isNode_1.default(arg2) || !arg2) {
            // function createRange(startNode: Node, endNode?: Node): Range;
            start = new Position_1.default(arg1, -2 /* Before */);
            end = new Position_1.default(arg2 || arg1, -3 /* After */);
        }
    }
    if (start && start.node) {
        var range = start.node.ownerDocument.createRange();
        start = getFocusablePosition(start);
        end = getFocusablePosition(end || start);
        range.setStart(start.node, start.offset);
        range.setEnd(end.node, end.offset);
        return range;
    }
    else {
        return null;
    }
}
exports.default = createRange;
/**
 * Convert to focusable position
 * If current node is a void element, we need to move up one level to put cursor outside void element
 */
function getFocusablePosition(position) {
    return position.node.nodeType == 1 /* Element */ && isVoidHtmlElement_1.default(position.node)
        ? new Position_1.default(position.node, position.isAtEnd ? -3 /* After */ : -2 /* Before */)
        : position;
}
function isNodePosition(arg) {
    return arg && arg.node;
}
function getPositionFromPath(node, path) {
    if (!node || !path) {
        return null;
    }
    // Iterate with a for loop to avoid mutating the passed in element path stack
    // or needing to copy it.
    var offset;
    for (var i = 0; i < path.length; i++) {
        offset = path[i];
        if (i < path.length - 1 &&
            node &&
            node.nodeType == 1 /* Element */ &&
            node.childNodes.length > offset) {
            node = node.childNodes[offset];
        }
        else {
            break;
        }
    }
    return new Position_1.default(node, offset);
}
/**
 * @deprecated Use createRange instead
 * Get range from the given selection path
 * @param rootNode Root node of the selection path
 * @param path The selection path which contains start and end position path
 */
function getRangeFromSelectionPath(rootNode, path) {
    return createRange(rootNode, path.start, path.end);
}
exports.getRangeFromSelectionPath = getRangeFromSelectionPath;
//# sourceMappingURL=createRange.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/selection/getHtmlWithSelectionPath.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/selection/getHtmlWithSelectionPath.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getSelectionPath_1 = __webpack_require__(/*! ./getSelectionPath */ "./node_modules/roosterjs-editor-dom/lib/selection/getSelectionPath.js");
/**
 * Get inner Html of a root node with a selection path which can be used for restore selection.
 * The result string can be used by setHtmlWithSelectionPath() to restore the HTML and selection.
 * @param rootNode Root node to get inner Html from
 * @param range The range of selection. If pass null, no selection path will be added
 * @returns Inner HTML of the root node, followed by HTML comment contains selection path if the given range is valid
 */
function getHtmlWithSelectionPath(rootNode, range) {
    if (!rootNode) {
        return '';
    }
    var content = rootNode.innerHTML;
    var selectionPath = range && getSelectionPath_1.default(rootNode, range);
    return selectionPath ? content + "<!--" + JSON.stringify(selectionPath) + "-->" : content;
}
exports.default = getHtmlWithSelectionPath;
//# sourceMappingURL=getHtmlWithSelectionPath.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/selection/getPositionRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/selection/getPositionRect.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var createRange_1 = __webpack_require__(/*! ./createRange */ "./node_modules/roosterjs-editor-dom/lib/selection/createRange.js");
var normalizeRect_1 = __webpack_require__(/*! ../utils/normalizeRect */ "./node_modules/roosterjs-editor-dom/lib/utils/normalizeRect.js");
/**
 * Get bounding rect of this position
 * @param position The positioin to get rect from
 */
function getPositionRect(position) {
    if (!position) {
        return null;
    }
    var range = createRange_1.default(position);
    // 1) try to get rect using range.getBoundingClientRect()
    var rect = range.getBoundingClientRect && normalizeRect_1.default(range.getBoundingClientRect());
    if (rect) {
        return rect;
    }
    // 2) try to get rect using range.getClientRects
    position = position.normalize();
    var rects = range.getClientRects && range.getClientRects();
    rect = rects && rects.length == 1 && normalizeRect_1.default(rects[0]);
    if (rect) {
        return rect;
    }
    // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others
    if (position.node.nodeType == 3 /* Text */) {
        var document_1 = position.node.ownerDocument;
        var span = document_1.createElement('SPAN');
        span.innerHTML = '\u200b';
        range = createRange_1.default(position);
        range.insertNode(span);
        rect = span.getBoundingClientRect && normalizeRect_1.default(span.getBoundingClientRect());
        span.parentNode.removeChild(span);
        if (rect) {
            return rect;
        }
    }
    // 4) try getBoundingClientRect on element
    var element = position.element;
    if (element && element.getBoundingClientRect) {
        rect = normalizeRect_1.default(element.getBoundingClientRect());
        if (rect) {
            return rect;
        }
    }
    return null;
}
exports.default = getPositionRect;
//# sourceMappingURL=getPositionRect.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/selection/getSelectionPath.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/selection/getSelectionPath.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = __webpack_require__(/*! ../utils/contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
var Position_1 = __webpack_require__(/*! ./Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
/**
 * Get path of the given selection range related to the given rootNode
 * @param rootNode The root node where the path start from
 * @param range The range of selection
 */
function getSelectionPath(rootNode, range) {
    if (!range) {
        return null;
    }
    var selectionPath = {
        start: getPositionPath(Position_1.default.getStart(range), rootNode),
        end: getPositionPath(Position_1.default.getEnd(range), rootNode),
    };
    return selectionPath;
}
exports.default = getSelectionPath;
/**
 * Get the path of the node relative to rootNode.
 * The path of the node is an array of integer indecies into the childNodes of the given node.
 *
 * The node path will be what the node path will be on a _normalized_ dom
 * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)
 *
 * @param rootNode the node the path will be relative to
 * @param position the position to get indexes from. Follows the same semantics
 * as selectionRange (if node is of type Text, it is an offset into the text of that node.
 * If node is of type Element, it is the index of a child in that Element node.)
 */
function getPositionPath(position, rootNode) {
    if (!position || !rootNode) {
        return [];
    }
    var node = position.node, offset = position.offset;
    var result = [];
    var parent;
    if (!contains_1.default(rootNode, node, true)) {
        return [];
    }
    if (node.nodeType == 3 /* Text */) {
        parent = node.parentNode;
        while (node.previousSibling && node.previousSibling.nodeType == 3 /* Text */) {
            offset += node.previousSibling.nodeValue.length;
            node = node.previousSibling;
        }
        result.unshift(offset);
    }
    else {
        parent = node;
        node = node.childNodes[offset];
    }
    do {
        offset = 0;
        var isPreviousText = false;
        for (var c = parent.firstChild; c && c != node; c = c.nextSibling) {
            if (c.nodeType == 3 /* Text */) {
                if (c.nodeValue.length == 0 || isPreviousText) {
                    continue;
                }
                isPreviousText = true;
            }
            else {
                isPreviousText = false;
            }
            offset++;
        }
        result.unshift(offset);
        node = parent;
        parent = parent.parentNode;
    } while (node && node != rootNode);
    return result;
}
//# sourceMappingURL=getSelectionPath.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.js":
/*!************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = __webpack_require__(/*! ../utils/contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
var getTagOfNode_1 = __webpack_require__(/*! ../utils/getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var isNodeEmpty_1 = __webpack_require__(/*! ../utils/isNodeEmpty */ "./node_modules/roosterjs-editor-dom/lib/utils/isNodeEmpty.js");
/**
 * Check if this position is at beginning of the given node.
 * This will return true if all nodes between the beginning of target node and the position are empty.
 * @param position The position to check
 * @param targetNode The node to check
 * @returns True if position is at beginning of the node, otherwise false
 */
function isPositionAtBeginningOf(position, targetNode) {
    if (position) {
        var _a = position.normalize(), node = _a.node, offset = _a.offset;
        if (offset == 0) {
            while (contains_1.default(targetNode, node) && areAllPrevousNodesEmpty(node)) {
                node = node.parentNode;
            }
            return node == targetNode;
        }
    }
    return false;
}
exports.default = isPositionAtBeginningOf;
function areAllPrevousNodesEmpty(node) {
    while (node.previousSibling) {
        node = node.previousSibling;
        if (getTagOfNode_1.default(node) == 'BR' || !isNodeEmpty_1.default(node)) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=isPositionAtBeginningOf.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/selection/setHtmlWithSelectionPath.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/selection/setHtmlWithSelectionPath.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var createRange_1 = __webpack_require__(/*! ./createRange */ "./node_modules/roosterjs-editor-dom/lib/selection/createRange.js");
/**
 * Restore inner Html of a root element from given html string. If the string contains selection path,
 * remove the selection path and return a range represented by the path
 * @param root The root element
 * @param html The html to restore
 * @returns A selection range if the html contains a valid selection path, otherwise null
 */
function setHtmlWithSelectionPath(rootNode, html) {
    rootNode.innerHTML = html || '';
    var path = null;
    var pathComment = rootNode.lastChild;
    try {
        path =
            pathComment &&
                pathComment.nodeType == 8 /* Comment */ &&
                JSON.parse(pathComment.nodeValue);
        if (path && path.end && path.end.length > 0 && path.start && path.start.length > 0) {
            rootNode.removeChild(pathComment);
        }
        else {
            path = null;
        }
    }
    catch (_a) { }
    return path && createRange_1.default(rootNode, path.start, path.end);
}
exports.default = setHtmlWithSelectionPath;
//# sourceMappingURL=setHtmlWithSelectionPath.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/snapshots/addSnapshot.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/snapshots/addSnapshot.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var clearProceedingSnapshots_1 = __webpack_require__(/*! ./clearProceedingSnapshots */ "./node_modules/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.js");
/**
 * Add a new snapshot to the given snapshots data structure
 * @param snapshots The snapshots data structure to add new snapshot into
 * @param snapshot The snapshot to add
 */
function addSnapshot(snapshots, snapshot) {
    if (snapshots.currentIndex < 0 || snapshot != snapshots.snapshots[snapshots.currentIndex]) {
        clearProceedingSnapshots_1.default(snapshots);
        snapshots.snapshots.push(snapshot);
        snapshots.currentIndex++;
        snapshots.totalSize += snapshot.length;
        var removeCount = 0;
        while (removeCount < snapshots.snapshots.length &&
            snapshots.totalSize > snapshots.maxSize) {
            snapshots.totalSize -= snapshots.snapshots[removeCount].length;
            removeCount++;
        }
        if (removeCount > 0) {
            snapshots.snapshots.splice(0, removeCount);
            snapshots.currentIndex -= removeCount;
        }
    }
}
exports.default = addSnapshot;
//# sourceMappingURL=addSnapshot.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Check whether can move current snapshot with the given step
 * @param snapshots The snapshots data structure to check
 * @param step The step to check, can be positive, negative or 0
 * @returns True if can move current snapshot with the given step, otherwise false
 */
function canMoveCurrentSnapshot(snapshots, step) {
    var newIndex = snapshots.currentIndex + step;
    return newIndex >= 0 && newIndex < snapshots.snapshots.length;
}
exports.default = canMoveCurrentSnapshot;
//# sourceMappingURL=canMoveCurrentSnapshot.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var canMoveCurrentSnapshot_1 = __webpack_require__(/*! ./canMoveCurrentSnapshot */ "./node_modules/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.js");
/**
 * Clear all snapshots after the current one
 * @param snapshots The snapshots data structure to clear
 */
function clearProceedingSnapshots(snapshots) {
    if (canMoveCurrentSnapshot_1.default(snapshots, 1)) {
        var removedSize = 0;
        for (var i = snapshots.currentIndex + 1; i < snapshots.snapshots.length; i++) {
            removedSize += snapshots.snapshots[i].length;
        }
        snapshots.snapshots.splice(snapshots.currentIndex + 1);
        snapshots.totalSize -= removedSize;
    }
}
exports.default = clearProceedingSnapshots;
//# sourceMappingURL=clearProceedingSnapshots.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/snapshots/createSnapshots.js":
/*!****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/snapshots/createSnapshots.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Create initial snapshots
 * @param maxSize max size of all snapshots
 */
function createSnapshots(maxSize) {
    return {
        snapshots: [],
        totalSize: 0,
        currentIndex: -1,
        maxSize: maxSize,
    };
}
exports.default = createSnapshots;
//# sourceMappingURL=createSnapshots.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapsnot.js":
/*!********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapsnot.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var canMoveCurrentSnapshot_1 = __webpack_require__(/*! ./canMoveCurrentSnapshot */ "./node_modules/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.js");
/**
 * Move current snapshot with the given step if can move this step. Otherwise no action and return null
 * @param snapshots The snapshots data structure to move
 * @param step The step to move
 * @returns If can move with the given step, returns the snapshot after move, otherwise null
 */
function moveCurrentSnapsnot(snapshots, step) {
    if (canMoveCurrentSnapshot_1.default(snapshots, step)) {
        snapshots.currentIndex += step;
        return snapshots.snapshots[snapshots.currentIndex];
    }
    else {
        return null;
    }
}
exports.default = moveCurrentSnapsnot;
//# sourceMappingURL=moveCurrentSnapsnot.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/table/VTable.js":
/*!***************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/table/VTable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isHTMLTableCellElement_1 = __webpack_require__(/*! ../typeUtils/isHTMLTableCellElement */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLTableCellElement.js");
var isHTMLTableElement_1 = __webpack_require__(/*! ../typeUtils/isHTMLTableElement */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLTableElement.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells
 */
var VTable = /** @class */ (function () {
    /**
     * Create a new instance of VTable object using HTML TABLE or TD node
     * @param node The HTML Table or TD node
     */
    function VTable(node) {
        var _this = this;
        this.trs = [];
        this.table = isHTMLTableElement_1.default(node) ? node : getTableFromTd(node);
        if (this.table) {
            var currentTd_1 = isHTMLTableElement_1.default(node) ? null : node;
            var trs = roosterjs_editor_dom_1.toArray(this.table.rows);
            this.cells = trs.map(function (row) { return []; });
            trs.forEach(function (tr, rowIndex) {
                _this.trs[rowIndex % 2] = tr;
                for (var sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {
                    // Skip the cells which already initialized
                    for (; _this.cells[rowIndex][targetCol]; targetCol++) { }
                    var td = tr.cells[sourceCol];
                    if (td == currentTd_1) {
                        _this.col = targetCol;
                        _this.row = rowIndex;
                    }
                    for (var colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {
                        for (var rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {
                            _this.cells[rowIndex + rowSpan][targetCol] = {
                                td: colSpan + rowSpan == 0 ? td : null,
                                spanLeft: colSpan > 0,
                                spanAbove: rowSpan > 0,
                            };
                        }
                    }
                }
            });
        }
    }
    /**
     * Write the virtual table back to DOM tree to represent the change of VTable
     */
    VTable.prototype.writeBack = function () {
        var _this = this;
        if (this.cells) {
            moveChildren(this.table);
            this.cells.forEach(function (row, r) {
                var tr = cloneNode(_this.trs[r % 2] || _this.trs[0]);
                _this.table.appendChild(tr);
                row.forEach(function (cell, c) {
                    if (cell.td) {
                        _this.recalcSpans(r, c);
                        tr.appendChild(cell.td);
                    }
                });
            });
        }
        else if (this.table) {
            this.table.parentNode.removeChild(this.table);
        }
    };
    /**
     * Apply the given table format to this virtual table
     * @param format Table format to apply
     */
    VTable.prototype.applyFormat = function (format) {
        if (!format || !this.table) {
            return;
        }
        this.table.style.borderCollapse = 'collapse';
        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';
        if (this.trs[1]) {
            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';
        }
        this.cells.forEach(function (row) {
            return row
                .filter(function (cell) { return cell.td; })
                .forEach(function (cell) {
                cell.td.style.borderTop = getBorderStyle(format.topBorderColor);
                cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);
                cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);
                cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);
            });
        });
    };
    /**
     * Edit table with given operation.
     * @param operation Table operation
     */
    VTable.prototype.edit = function (operation) {
        var _this = this;
        if (!this.table) {
            return;
        }
        var currentRow = this.cells[this.row];
        var currentCell = currentRow[this.col];
        switch (operation) {
            case 0 /* InsertAbove */:
                this.cells.splice(this.row, 0, currentRow.map(cloneCell));
                break;
            case 1 /* InsertBelow */:
                var newRow_1 = this.row + this.countSpanAbove(this.row, this.col);
                this.cells.splice(newRow_1, 0, this.cells[newRow_1 - 1].map(function (cell, colIndex) {
                    var nextCell = _this.getCell(newRow_1, colIndex);
                    if (nextCell.spanAbove) {
                        return cloneCell(nextCell);
                    }
                    else if (cell.spanLeft) {
                        var newCell = cloneCell(cell);
                        newCell.spanAbove = false;
                        return newCell;
                    }
                    else {
                        return {
                            td: cloneNode(_this.getTd(_this.row, colIndex)),
                        };
                    }
                }));
                break;
            case 2 /* InsertLeft */:
                this.forEachCellOfCurrentColumn(function (cell, row) {
                    row.splice(_this.col, 0, cloneCell(cell));
                });
                break;
            case 3 /* InsertRight */:
                var newCol_1 = this.col + this.countSpanLeft(this.row, this.col);
                this.forEachCellOfColumn(newCol_1 - 1, function (cell, row, i) {
                    var nextCell = _this.getCell(i, newCol_1);
                    var newCell;
                    if (nextCell.spanLeft) {
                        newCell = cloneCell(nextCell);
                    }
                    else if (cell.spanAbove) {
                        newCell = cloneCell(cell);
                        newCell.spanLeft = false;
                    }
                    else {
                        newCell = {
                            td: cloneNode(_this.getTd(i, _this.col)),
                        };
                    }
                    row.splice(newCol_1, 0, newCell);
                });
                break;
            case 6 /* DeleteRow */:
                this.forEachCellOfCurrentRow(function (cell, i) {
                    var nextCell = _this.getCell(_this.row + 1, i);
                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {
                        nextCell.td = cell.td;
                    }
                });
                this.cells.splice(this.row, 1);
                break;
            case 5 /* DeleteColumn */:
                this.forEachCellOfCurrentColumn(function (cell, row, i) {
                    var nextCell = _this.getCell(i, _this.col + 1);
                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {
                        nextCell.td = cell.td;
                    }
                    row.splice(_this.col, 1);
                });
                break;
            case 7 /* MergeAbove */:
            case 8 /* MergeBelow */:
                var rowStep = operation == 7 /* MergeAbove */ ? -1 : 1;
                for (var rowIndex = this.row + rowStep; rowIndex >= 0 && rowIndex < this.cells.length; rowIndex += rowStep) {
                    var cell = this.getCell(rowIndex, this.col);
                    if (cell.td && !cell.spanAbove) {
                        var aboveCell = rowIndex < this.row ? cell : currentCell;
                        var belowCell = rowIndex < this.row ? currentCell : cell;
                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {
                            moveChildren(belowCell.td, aboveCell.td);
                            belowCell.td = null;
                            belowCell.spanAbove = true;
                        }
                        break;
                    }
                }
                break;
            case 9 /* MergeLeft */:
            case 10 /* MergeRight */:
                var colStep = operation == 9 /* MergeLeft */ ? -1 : 1;
                for (var colIndex = this.col + colStep; colIndex >= 0 && colIndex < this.cells[this.row].length; colIndex += colStep) {
                    var cell = this.getCell(this.row, colIndex);
                    if (cell.td && !cell.spanLeft) {
                        var leftCell = colIndex < this.col ? cell : currentCell;
                        var rightCell = colIndex < this.col ? currentCell : cell;
                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {
                            moveChildren(rightCell.td, leftCell.td);
                            rightCell.td = null;
                            rightCell.spanLeft = true;
                        }
                        break;
                    }
                }
                break;
            case 4 /* DeleteTable */:
                this.cells = null;
                break;
            case 12 /* SplitVertically */:
                if (currentCell.td.rowSpan > 1) {
                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);
                }
                else {
                    var splitRow = currentRow.map(function (cell) {
                        return {
                            td: cell == currentCell ? cloneNode(cell.td) : null,
                            spanAbove: cell != currentCell,
                            spanLeft: cell.spanLeft,
                        };
                    });
                    this.cells.splice(this.row + 1, 0, splitRow);
                }
                break;
            case 11 /* SplitHorizontally */:
                if (currentCell.td.colSpan > 1) {
                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);
                }
                else {
                    this.forEachCellOfCurrentColumn(function (cell, row) {
                        row.splice(_this.col + 1, 0, {
                            td: row == currentRow ? cloneNode(cell.td) : null,
                            spanAbove: cell.spanAbove,
                            spanLeft: row != currentRow,
                        });
                    });
                }
                break;
        }
    };
    /**
     * Loop each cell of current column and invoke a callback function
     * @param callback The callback function to invoke
     */
    VTable.prototype.forEachCellOfCurrentColumn = function (callback) {
        this.forEachCellOfColumn(this.col, callback);
    };
    /**
     * Loop each cell of current row and invoke a callback function
     * @param callback The callback function to invoke
     */
    VTable.prototype.forEachCellOfCurrentRow = function (callback) {
        this.forEachCellOfRow(this.row, callback);
    };
    /**
     * Get a table cell using its row and column index. This function will always return an object
     * even if the given indexes don't exist in table.
     * @param row The row index
     * @param col The column index
     */
    VTable.prototype.getCell = function (row, col) {
        return (this.cells && this.cells[row] && this.cells[row][col]) || {};
    };
    /**
     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell
     */
    VTable.prototype.getCurrentTd = function () {
        return this.getTd(this.row, this.col);
    };
    VTable.prototype.getTd = function (row, col) {
        if (this.cells) {
            row = Math.min(this.cells.length - 1, row);
            col = this.cells[row] ? Math.min(this.cells[row].length - 1, col) : col;
            if (!isNaN(row) && !isNaN(col)) {
                while (row >= 0 && col >= 0) {
                    var cell = this.getCell(row, col);
                    if (cell.td) {
                        return cell.td;
                    }
                    else if (cell.spanLeft) {
                        col--;
                    }
                    else if (cell.spanAbove) {
                        row--;
                    }
                    else {
                        break;
                    }
                }
            }
        }
        return null;
    };
    VTable.prototype.forEachCellOfColumn = function (col, callback) {
        for (var i = 0; i < this.cells.length; i++) {
            callback(this.getCell(i, col), this.cells[i], i);
        }
    };
    VTable.prototype.forEachCellOfRow = function (row, callback) {
        for (var i = 0; i < this.cells[row].length; i++) {
            callback(this.getCell(row, i), i);
        }
    };
    VTable.prototype.recalcSpans = function (row, col) {
        var td = this.getCell(row, col).td;
        if (td) {
            td.colSpan = this.countSpanLeft(row, col);
            td.rowSpan = this.countSpanAbove(row, col);
            if (td.colSpan == 1) {
                td.removeAttribute('colSpan');
            }
            if (td.rowSpan == 1) {
                td.removeAttribute('rowSpan');
            }
        }
    };
    VTable.prototype.countSpanLeft = function (row, col) {
        var result = 1;
        for (var i = col + 1; i < this.cells[row].length; i++) {
            var cell = this.getCell(row, i);
            if (cell.td || !cell.spanLeft) {
                break;
            }
            result++;
        }
        return result;
    };
    VTable.prototype.countSpanAbove = function (row, col) {
        var result = 1;
        for (var i = row + 1; i < this.cells.length; i++) {
            var cell = this.getCell(i, col);
            if (cell.td || !cell.spanAbove) {
                break;
            }
            result++;
        }
        return result;
    };
    return VTable;
}());
exports.default = VTable;
function getTableFromTd(td) {
    var result = td;
    for (; result && result.tagName != 'TABLE'; result = result.parentElement) { }
    return result;
}
function getBorderStyle(style) {
    return 'solid 1px ' + (style || 'transparent');
}
/**
 * Clone a table cell
 * @param cell The cell to clone
 */
function cloneCell(cell) {
    return {
        td: cloneNode(cell.td),
        spanAbove: cell.spanAbove,
        spanLeft: cell.spanLeft,
    };
}
/**
 * Clone a node without its children.
 * @param node The node to clone
 */
function cloneNode(node) {
    var newNode = node ? node.cloneNode(false /*deep*/) : null;
    if (isHTMLTableCellElement_1.default(newNode)) {
        newNode.removeAttribute('id');
        if (!newNode.firstChild) {
            newNode.appendChild(node.ownerDocument.createElement('br'));
        }
    }
    return newNode;
}
/**
 * Move all children from one node to another
 * @param fromNode The source node to move children from
 * @param toNode Target node. If not passed, children nodes of source node will be removed
 */
function moveChildren(fromNode, toNode) {
    while (fromNode.firstChild) {
        if (toNode) {
            toNode.appendChild(fromNode.firstChild);
        }
        else {
            fromNode.removeChild(fromNode.firstChild);
        }
    }
}
//# sourceMappingURL=VTable.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isDocumentFragment.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/typeUtils/isDocumentFragment.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var safeInstanceOf_1 = __webpack_require__(/*! ./safeInstanceOf */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/safeInstanceOf.js");
/**
 * Check if the given object is DocumentFragment
 * @param obj The object to check
 */
function isDocumentFragment(obj) {
    return safeInstanceOf_1.default(obj, 'DocumentFragment');
}
exports.default = isDocumentFragment;
//# sourceMappingURL=isDocumentFragment.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLElement.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLElement.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var safeInstanceOf_1 = __webpack_require__(/*! ./safeInstanceOf */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/safeInstanceOf.js");
/**
 * Check if the given object is HTMLElement
 * @param obj The object to check
 */
function isHTMLElement(obj) {
    return safeInstanceOf_1.default(obj, 'HTMLElement');
}
exports.default = isHTMLElement;
//# sourceMappingURL=isHTMLElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLOListElement.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLOListElement.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var safeInstanceOf_1 = __webpack_require__(/*! ./safeInstanceOf */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/safeInstanceOf.js");
/**
 * Check if the given object is HTMLOListElement
 * @param obj The object to check
 */
function isHTMLOListElement(obj) {
    return safeInstanceOf_1.default(obj, 'HTMLOListElement');
}
exports.default = isHTMLOListElement;
//# sourceMappingURL=isHTMLOListElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLTableCellElement.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLTableCellElement.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var safeInstanceOf_1 = __webpack_require__(/*! ./safeInstanceOf */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/safeInstanceOf.js");
/**
 * Check if the given object is HTMLTableCellElement
 * @param obj The object to check
 */
function isHTMLTableCellElement(obj) {
    return safeInstanceOf_1.default(obj, 'HTMLTableCellElement');
}
exports.default = isHTMLTableCellElement;
//# sourceMappingURL=isHTMLTableCellElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLTableElement.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLTableElement.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var safeInstanceOf_1 = __webpack_require__(/*! ./safeInstanceOf */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/safeInstanceOf.js");
/**
 * Check if the given object is HTMLTableElement
 * @param obj The object to check
 */
function isHTMLTableElement(obj) {
    return safeInstanceOf_1.default(obj, 'HTMLTableElement');
}
exports.default = isHTMLTableElement;
//# sourceMappingURL=isHTMLTableElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isNode.js":
/*!*******************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/typeUtils/isNode.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var safeInstanceOf_1 = __webpack_require__(/*! ./safeInstanceOf */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/safeInstanceOf.js");
/**
 * Check if the given object is Node
 * @param obj The object to check
 */
function isNode(obj) {
    return safeInstanceOf_1.default(obj, 'Node');
}
exports.default = isNode;
//# sourceMappingURL=isNode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isRange.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/typeUtils/isRange.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var safeInstanceOf_1 = __webpack_require__(/*! ./safeInstanceOf */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/safeInstanceOf.js");
/**
 * Check if the given object is Range
 * @param obj The object to check
 */
function isRange(obj) {
    return safeInstanceOf_1.default(obj, 'Range');
}
exports.default = isRange;
//# sourceMappingURL=isRange.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/typeUtils/safeInstanceOf.js":
/*!***************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/typeUtils/safeInstanceOf.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// NOTE: Type TargetWindow is an auto-generated type.
// Run node ./tools/generateTargetWindow.js to generate it.
/**
 * Try get window from the given node or range
 * @param source Source node or range
 */
function getTargetWindow(source) {
    var node = source && (source.commonAncestorContainer || source);
    var document = node &&
        (node.ownerDocument ||
            (Object.prototype.toString.apply(node) == '[object HTMLDocument]'
                ? node
                : null));
    // If document exists but document.defaultView doesn't exist, it is a detached object, just use current window instead
    var targetWindow = document && (document.defaultView || window);
    return targetWindow;
}
exports.getTargetWindow = getTargetWindow;
/**
 * Check if the given object is instance of the target type
 * @param obj Object to check
 * @param typeName Target type name
 */
function safeInstanceOf(obj, typeName) {
    var targetWindow = getTargetWindow(obj);
    var targetType = targetWindow && targetWindow[typeName];
    var mainWindow = window;
    var mainWindowType = mainWindow && mainWindow[typeName];
    return ((mainWindowType && obj instanceof mainWindowType) ||
        (targetType && obj instanceof targetType));
}
exports.default = safeInstanceOf;
//# sourceMappingURL=safeInstanceOf.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/Browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/Browser.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Get current browser information from user agent string
 * @param userAgent The userAgent string of a browser
 * @param appVersion The appVersion string of a browser
 * @returns The BrowserInfo object calculated from the given userAgent and appVersion
 */
function getBrowserInfo(userAgent, appVersion) {
    // checks whether the browser is running in IE
    // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for "Trident" to confirm this.
    // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)
    // therefore we should check that the Trident/rv combo is not just from an older IE browser
    var isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;
    var isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;
    // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well
    var isChrome = false;
    var isFirefox = false;
    var isSafari = false;
    var isEdge = false;
    var isWebKit = userAgent.indexOf('WebKit') != -1;
    if (!isIE) {
        isChrome = userAgent.indexOf('Chrome') != -1;
        isFirefox = userAgent.indexOf('Firefox') != -1;
        if (userAgent.indexOf('Safari') != -1) {
            // Android and Chrome have Safari in the user string
            isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;
        }
        // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121
        isEdge = userAgent.indexOf('Edge') != -1;
        // When it is edge, it should not be chrome or firefox. and it is also not webkit
        if (isEdge) {
            isWebKit = isChrome = isFirefox = false;
        }
    }
    var isMac = appVersion.indexOf('Mac') != -1;
    var isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;
    return {
        isMac: isMac,
        isWin: isWin,
        isWebKit: isWebKit,
        isIE: isIE,
        isIE11OrGreater: isIE11OrGreater,
        isSafari: isSafari,
        isChrome: isChrome,
        isFirefox: isFirefox,
        isEdge: isEdge,
        isIEOrEdge: isIE || isEdge,
    };
}
exports.getBrowserInfo = getBrowserInfo;
/**
 * Browser object contains browser and operating system informations of current environment
 */
exports.Browser = window
    ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion)
    : {};
//# sourceMappingURL=Browser.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/adjustNodeInsertPosition.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/adjustNodeInsertPosition.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var changeElementTag_1 = __webpack_require__(/*! ./changeElementTag */ "./node_modules/roosterjs-editor-dom/lib/utils/changeElementTag.js");
var contains_1 = __webpack_require__(/*! ./contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
var createRange_1 = __webpack_require__(/*! ../selection/createRange */ "./node_modules/roosterjs-editor-dom/lib/selection/createRange.js");
var findClosestElementAncestor_1 = __webpack_require__(/*! ./findClosestElementAncestor */ "./node_modules/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.js");
var getBlockElementAtNode_1 = __webpack_require__(/*! ../blockElements/getBlockElementAtNode */ "./node_modules/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.js");
var getTagOfNode_1 = __webpack_require__(/*! ./getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var isNodeEmpty_1 = __webpack_require__(/*! ./isNodeEmpty */ "./node_modules/roosterjs-editor-dom/lib/utils/isNodeEmpty.js");
var isPositionAtBeginningOf_1 = __webpack_require__(/*! ../selection/isPositionAtBeginningOf */ "./node_modules/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.js");
var isVoidHtmlElement_1 = __webpack_require__(/*! ./isVoidHtmlElement */ "./node_modules/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.js");
var Position_1 = __webpack_require__(/*! ../selection/Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
var queryElements_1 = __webpack_require__(/*! ./queryElements */ "./node_modules/roosterjs-editor-dom/lib/utils/queryElements.js");
var splitTextNode_1 = __webpack_require__(/*! ./splitTextNode */ "./node_modules/roosterjs-editor-dom/lib/utils/splitTextNode.js");
var toArray_1 = __webpack_require__(/*! ./toArray */ "./node_modules/roosterjs-editor-dom/lib/utils/toArray.js");
var unwrap_1 = __webpack_require__(/*! ./unwrap */ "./node_modules/roosterjs-editor-dom/lib/utils/unwrap.js");
var VTable_1 = __webpack_require__(/*! ../table/VTable */ "./node_modules/roosterjs-editor-dom/lib/table/VTable.js");
var wrap_1 = __webpack_require__(/*! ./wrap */ "./node_modules/roosterjs-editor-dom/lib/utils/wrap.js");
var splitParentNode_1 = __webpack_require__(/*! ./splitParentNode */ "./node_modules/roosterjs-editor-dom/lib/utils/splitParentNode.js");
var adjustSteps = [handleHyperLink, handleStructuredNode, handleParagraph, handleVoidElement];
/**
 * Adjust the given position and return a better position (if any) or the given position
 * which will be the best one for inserting the given node.
 * @param root Root node of the scope
 * @param nodeToInsert The node about to be inserted
 * @param position The original position to insert the node
 */
function adjustNodeInsertPosition(root, nodeToInsert, position) {
    adjustSteps.forEach(function (handler) {
        position = handler(root, nodeToInsert, position);
    });
    return position;
}
exports.default = adjustNodeInsertPosition;
function handleHyperLink(root, nodeToInsert, position) {
    var blockElement = getBlockElementAtNode_1.default(root, position.node);
    if (blockElement) {
        // Find the first <A> tag within current block which covers current selection
        // If there are more than one nested, let's handle the first one only since that is not a common scenario.
        var anchor = queryElements_1.default(root, 'a[href]', null /*forEachCallback*/, 1 /* OnSelection */, createRange_1.default(position)).filter(function (a) { return blockElement.contains(a); })[0];
        // If this is about to insert node to an empty A tag, clear the A tag and reset position
        if (anchor && isNodeEmpty_1.default(anchor)) {
            position = new Position_1.default(anchor, -2 /* Before */);
            safeRemove(anchor);
            anchor = null;
        }
        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag
        // otherwise we will have nested A tags which is a wrong HTML structure
        if (anchor &&
            nodeToInsert.querySelector &&
            nodeToInsert.querySelector('a[href]')) {
            var normalizedPosition = position.normalize();
            var parentNode = normalizedPosition.node.parentNode;
            var nextNode = normalizedPosition.node.nodeType == 3 /* Text */
                ? splitTextNode_1.default(normalizedPosition.node, normalizedPosition.offset, false /*returnFirstPart*/)
                : normalizedPosition.isAtEnd
                    ? normalizedPosition.node.nextSibling
                    : normalizedPosition.node;
            var splitter = root.ownerDocument.createTextNode('');
            parentNode.insertBefore(splitter, nextNode);
            while (contains_1.default(anchor, splitter)) {
                splitter = splitParentNode_1.splitBalancedNodeRange(splitter);
            }
            position = new Position_1.default(splitter, -2 /* Before */);
            safeRemove(splitter);
        }
    }
    return position;
}
function handleStructuredNode(root, nodeToInsert, position) {
    var rootNodeToInsert = nodeToInsert;
    if (rootNodeToInsert.nodeType == 11 /* DocumentFragment */) {
        var rootNodes = toArray_1.default(rootNodeToInsert.childNodes).filter(function (n) { return getTagOfNode_1.default(n) != 'BR'; });
        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;
    }
    var tag = getTagOfNode_1.default(rootNodeToInsert);
    var hasBrNextToRoot = tag && getTagOfNode_1.default(rootNodeToInsert.nextSibling) == 'BR';
    var listItem = findClosestElementAncestor_1.default(position.node, root, 'LI');
    var listNode = listItem && findClosestElementAncestor_1.default(listItem, root, 'OL,UL');
    var tdNode = findClosestElementAncestor_1.default(position.node, root, 'TD,TH');
    var trNode = tdNode && findClosestElementAncestor_1.default(tdNode, root, 'TR');
    if (tag == 'LI') {
        tag = listNode ? getTagOfNode_1.default(listNode) : 'UL';
        rootNodeToInsert = wrap_1.default(rootNodeToInsert, tag);
    }
    if ((tag == 'OL' || tag == 'UL') && getTagOfNode_1.default(rootNodeToInsert.firstChild) == 'LI') {
        var shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;
        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {
            safeRemove(rootNodeToInsert.nextSibling);
        }
        if (shouldInsertListAsText) {
            unwrap_1.default(rootNodeToInsert.firstChild);
            unwrap_1.default(rootNodeToInsert);
        }
        else if (getTagOfNode_1.default(listNode) == tag) {
            unwrap_1.default(rootNodeToInsert);
            position = new Position_1.default(listItem, isPositionAtBeginningOf_1.default(position, listItem)
                ? -2 /* Before */
                : -3 /* After */);
        }
    }
    else if (tag == 'TABLE' && trNode) {
        // When inserting a table into a table, if these tables have the same column count, and
        // current position is at beginning of a row, then merge these two tables
        var newTable = new VTable_1.default(rootNodeToInsert);
        var currentTable = new VTable_1.default(tdNode);
        if (currentTable.col == 0 &&
            tdNode == currentTable.getCell(currentTable.row, 0).td &&
            newTable.cells[0] &&
            newTable.cells[0].length == currentTable.cells[0].length &&
            isPositionAtBeginningOf_1.default(position, tdNode)) {
            if (getTagOfNode_1.default(rootNodeToInsert.firstChild) == 'TBODY' &&
                !rootNodeToInsert.firstChild.nextSibling) {
                unwrap_1.default(rootNodeToInsert.firstChild);
            }
            unwrap_1.default(rootNodeToInsert);
            position = new Position_1.default(trNode, -3 /* After */);
        }
    }
    return position;
}
function handleParagraph(root, nodeToInsert, position) {
    if (getTagOfNode_1.default(position.node) == 'P') {
        // Insert into a P tag may cause issues when the inserted content contains any block element.
        // Change P tag to DIV to make sure it works well
        var pos = position.normalize();
        var div = changeElementTag_1.default(position.node, 'div');
        if (pos.node != div) {
            position = pos;
        }
    }
    return position;
}
function handleVoidElement(root, nodeToInsert, position) {
    if (isVoidHtmlElement_1.default(position.node)) {
        position = new Position_1.default(position.node, position.isAtEnd ? -3 /* After */ : -2 /* Before */);
    }
    return position;
}
function safeRemove(node) {
    if (node && node.parentNode) {
        node.parentNode.removeChild(node);
    }
}
//# sourceMappingURL=adjustNodeInsertPosition.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/applyFormat.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/applyFormat.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Apply format to an HTML element
 * @param element The HTML element to apply format to
 * @param format The format to apply
 */
function applyFormat(element, format, isDarkMode) {
    if (format) {
        var elementStyle = element.style;
        var fontFamily = format.fontFamily, fontSize = format.fontSize, textColor = format.textColor, textColors = format.textColors, backgroundColor = format.backgroundColor, backgroundColors = format.backgroundColors, bold = format.bold, italic = format.italic, underline = format.underline;
        if (fontFamily) {
            elementStyle.fontFamily = fontFamily;
        }
        if (fontSize) {
            elementStyle.fontSize = fontSize;
        }
        if (textColor || textColors) {
            if (textColors && isDarkMode) {
                element.dataset.ogsc = textColors.lightModeColor;
            }
            elementStyle.color = textColor;
        }
        if (backgroundColor || backgroundColors) {
            if (backgroundColors && isDarkMode) {
                element.dataset.ogsb = backgroundColors.lightModeColor;
            }
            elementStyle.backgroundColor = backgroundColor;
        }
        if (bold) {
            elementStyle.fontWeight = 'bold';
        }
        if (italic) {
            elementStyle.fontStyle = 'italic';
        }
        if (underline) {
            elementStyle.textDecoration = 'underline';
        }
    }
}
exports.default = applyFormat;
//# sourceMappingURL=applyFormat.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/applyTextStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/applyTextStyle.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getTagOfNode_1 = __webpack_require__(/*! ./getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var Position_1 = __webpack_require__(/*! ../selection/Position */ "./node_modules/roosterjs-editor-dom/lib/selection/Position.js");
var splitTextNode_1 = __webpack_require__(/*! ./splitTextNode */ "./node_modules/roosterjs-editor-dom/lib/utils/splitTextNode.js");
var wrap_1 = __webpack_require__(/*! ./wrap */ "./node_modules/roosterjs-editor-dom/lib/utils/wrap.js");
var getLeafSibling_1 = __webpack_require__(/*! ./getLeafSibling */ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafSibling.js");
var splitParentNode_1 = __webpack_require__(/*! ./splitParentNode */ "./node_modules/roosterjs-editor-dom/lib/utils/splitParentNode.js");
var STYLETAGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');
/**
 * Apply style using a styler function to the given container node in the given range
 * @param container The container node to apply style to
 * @param styler The styler function
 * @param from From position
 * @param to To position
 */
function applyTextStyle(container, styler, from, to) {
    if (from === void 0) { from = new Position_1.default(container, 0 /* Begin */).normalize(); }
    if (to === void 0) { to = new Position_1.default(container, -1 /* End */).normalize(); }
    var formatNodes = [];
    while (from && to && to.isAfter(from)) {
        var formatNode = from.node;
        var parentTag = getTagOfNode_1.default(formatNode.parentNode);
        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node
        var nextNode = getLeafSibling_1.getNextLeafSibling(container, formatNode);
        if (formatNode.nodeType == 3 /* Text */ && ['TR', 'TABLE'].indexOf(parentTag) < 0) {
            if (formatNode == to.node && !to.isAtEnd) {
                formatNode = splitTextNode_1.default(formatNode, to.offset, true /*returnFirstPart*/);
            }
            if (from.offset > 0) {
                formatNode = splitTextNode_1.default(formatNode, from.offset, false /*returnFirstPart*/);
            }
            formatNodes.push(formatNode);
        }
        from = nextNode && new Position_1.default(nextNode, 0 /* Begin */);
    }
    if (formatNodes.length > 0) {
        if (formatNodes.every(function (node) { return node.parentNode == formatNodes[0].parentNode; })) {
            var newNode_1 = formatNodes.shift();
            formatNodes.forEach(function (node) {
                newNode_1.nodeValue += node.nodeValue;
                node.parentNode.removeChild(node);
            });
            formatNodes = [newNode_1];
        }
        formatNodes.forEach(function (node) {
            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them
            // So that the inner style tag such as U, STRIKE can inherit the style we added
            while (getTagOfNode_1.default(node) != 'SPAN' &&
                STYLETAGS.indexOf(getTagOfNode_1.default(node.parentNode)) >= 0) {
                callStylerWithInnerNode(node, styler);
                node = splitParentNode_1.splitBalancedNodeRange(node);
            }
            if (getTagOfNode_1.default(node) != 'SPAN') {
                callStylerWithInnerNode(node, styler);
                node = wrap_1.default(node, 'SPAN');
            }
            styler(node);
        });
    }
}
exports.default = applyTextStyle;
function callStylerWithInnerNode(node, styler) {
    if (node && node.nodeType == 1 /* Element */) {
        styler(node, true /*isInnerNode*/);
    }
}
//# sourceMappingURL=applyTextStyle.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/changeElementTag.js":
/*!*************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/changeElementTag.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getComputedStyles_1 = __webpack_require__(/*! ./getComputedStyles */ "./node_modules/roosterjs-editor-dom/lib/utils/getComputedStyles.js");
var getTagOfNode_1 = __webpack_require__(/*! ./getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
function changeElementTag(element, newTag) {
    var _a;
    if (!element || !newTag) {
        return null;
    }
    var newElement = element.ownerDocument.createElement(newTag);
    for (var i = 0; i < element.attributes.length; i++) {
        var attr = element.attributes[i];
        newElement.setAttribute(attr.name, attr.value);
    }
    while (element.firstChild) {
        newElement.appendChild(element.firstChild);
    }
    if (getTagOfNode_1.default(element) == 'P' || getTagOfNode_1.default(newElement) == 'P') {
        _a = getComputedStyles_1.default(element, [
            'margin-top',
            'margin-bottom',
        ]), newElement.style.marginTop = _a[0], newElement.style.marginBottom = _a[1];
    }
    if (element.parentNode) {
        element.parentNode.replaceChild(newElement, element);
    }
    return newElement;
}
exports.default = changeElementTag;
//# sourceMappingURL=changeElementTag.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/collapseNodes.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/collapseNodes.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = __webpack_require__(/*! ./contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
var splitParentNode_1 = __webpack_require__(/*! ./splitParentNode */ "./node_modules/roosterjs-editor-dom/lib/utils/splitParentNode.js");
var toArray_1 = __webpack_require__(/*! ./toArray */ "./node_modules/roosterjs-editor-dom/lib/utils/toArray.js");
/**
 * Collapse nodes within the given start and end nodes to their common ascenstor node,
 * split parent nodes if necessary
 * @param root The root node of the scope
 * @param start The start node
 * @param end The end node
 * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent
 * and the returned nodes will be all nodes from start trhough end after splitting
 * False to disallow split parent
 * @returns When cansplitParent is true, returns all node from start through end after splitting,
 * otherwise just return start and end
 */
function collapseNodes(root, start, end, canSplitParent) {
    if (!contains_1.default(root, start) || !contains_1.default(root, end)) {
        return [];
    }
    start = collapse(root, start, end, true /*isStart*/, canSplitParent);
    end = collapse(root, end, start, false /*isStart*/, canSplitParent);
    if (contains_1.default(start, end, true /*treateSameNodeAsContain*/)) {
        return [start];
    }
    else if (contains_1.default(end, start)) {
        return [end];
    }
    else if (start.parentNode == end.parentNode) {
        var nodes = toArray_1.default(start.parentNode.childNodes);
        var startIndex = nodes.indexOf(start);
        var endIndex = nodes.indexOf(end);
        return nodes.slice(startIndex, endIndex + 1);
    }
    else {
        return [start, end];
    }
}
exports.default = collapseNodes;
function collapse(root, node, ref, isStart, canSplitParent) {
    while (node.parentNode != root && !contains_1.default(node.parentNode, ref)) {
        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {
            if (!canSplitParent) {
                break;
            }
            splitParentNode_1.default(node, isStart);
        }
        node = node.parentNode;
    }
    return node;
}
//# sourceMappingURL=collapseNodes.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js":
/*!*****************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/contains.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isRange_1 = __webpack_require__(/*! ../typeUtils/isRange */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isRange.js");
function contains(container, contained, treatSameNodeAsContain) {
    if (!container || !contained) {
        return false;
    }
    if (treatSameNodeAsContain && container == contained) {
        return true;
    }
    if (isRange_1.default(contained)) {
        contained = contained && contained.commonAncestorContainer;
        treatSameNodeAsContain = true;
    }
    if (contained && contained.nodeType == 3 /* Text */) {
        contained = contained.parentNode;
        treatSameNodeAsContain = true;
    }
    if (container.nodeType != 1 /* Element */ && container.nodeType != 11 /* DocumentFragment */) {
        return !!treatSameNodeAsContain && container == contained;
    }
    return !!(treatSameNodeAsContain || container != contained) && container.contains(contained);
}
exports.default = contains;
//# sourceMappingURL=contains.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/extractClipboardEvent.js":
/*!******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/extractClipboardEvent.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var toArray_1 = __webpack_require__(/*! ./toArray */ "./node_modules/roosterjs-editor-dom/lib/utils/toArray.js");
var Browser_1 = __webpack_require__(/*! ./Browser */ "./node_modules/roosterjs-editor-dom/lib/utils/Browser.js");
// HTML header to indicate where is the HTML content started from.
// Sample header:
// Version:0.9
// StartHTML:71
// EndHTML:170
// StartFragment:140
// EndFragment:160
// StartSelection:140
// EndSelection:160
var CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\.]+\s+StartHTML:\s*([0-9]+)\s+EndHTML:\s*([0-9]+)\s+/i;
/**
 * Extract a Clipboard event
 * @param event The paste event
 * @param callback Callback function when data is ready
 * @param fallbackHtmlRetriever If direct HTML retriving is not support (e.g. Internet Explorer), as a fallback,
 * using this helper function to retrieve HTML content
 * @returns An object with the following properties:
 *  types: Available types from the clipboard event
 *  text: Plain text from the clipboard event
 *  image: Image file from the clipboard event
 *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.
 *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is
 *   not supported by browser.
 */
function extractClipboardEvent(event, callback) {
    var dataTransfer = event.clipboardData ||
        event.target.ownerDocument.defaultView.clipboardData;
    var result = {
        types: dataTransfer.types ? toArray_1.default(dataTransfer.types) : [],
        text: dataTransfer.getData('text'),
        image: getImage(dataTransfer),
        html: undefined,
    };
    if (event.clipboardData && event.clipboardData.items) {
        event.preventDefault();
        var items = event.clipboardData.items;
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (item.type && item.type.indexOf('text/html') == 0) {
                item.getAsString(function (html) {
                    result.html = Browser_1.Browser.isEdge ? workaroundForEdge(html) : html;
                    callback(result);
                });
                return;
            }
        }
        // No HTML content found, set html to null
        result.html = null;
    }
    callback(result);
}
exports.default = extractClipboardEvent;
function getImage(dataTransfer) {
    // Chrome, Firefox, Edge support dataTransfer.items
    var fileCount = dataTransfer.items ? dataTransfer.items.length : 0;
    for (var i = 0; i < fileCount; i++) {
        var item = dataTransfer.items[i];
        if (item.type && item.type.indexOf('image/') == 0) {
            return item.getAsFile();
        }
    }
    // IE, Safari support dataTransfer.files
    fileCount = dataTransfer.files ? dataTransfer.files.length : 0;
    for (var i = 0; i < fileCount; i++) {
        var file = dataTransfer.files.item(i);
        if (file.type && file.type.indexOf('image/') == 0) {
            return file;
        }
    }
    return null;
}
/**
 * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.
 * So we need to remove it in our code
 * @param html The HTML string got from clipboard
 */
function workaroundForEdge(html) {
    var headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);
    if (headerValues && headerValues.length == 3) {
        var start = parseInt(headerValues[1]);
        var end = parseInt(headerValues[2]);
        if (start > 0 && end > start) {
            html = html.substring(start, end);
        }
    }
    return html;
}
//# sourceMappingURL=extractClipboardEvent.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = __webpack_require__(/*! ./contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
/**
 * Find closest element ancestor start from the given node which matches the given selector
 * @param node Find ancestor start from this node
 * @param root Root node where the search should stop at. The return value can never be this node
 * @param selector The expected selector. If null, return the first HTML Element found from start node
 * @returns An HTML element which matches the given selector. If the given start node matches the selector,
 * returns the given node
 */
function findClosestElementAncestor(node, root, selector) {
    node = !node ? null : node.nodeType == 1 /* Element */ ? node : node.parentNode;
    var element = node && node.nodeType == 1 /* Element */ ? node : null;
    if (element && selector) {
        if (element.closest) {
            element = element.closest(selector);
        }
        else {
            while (element &&
                element != root &&
                !(element.matches || element.msMatchesSelector).call(element, selector)) {
                element = element.parentElement;
            }
        }
    }
    return !root || contains_1.default(root, element) ? element : null;
}
exports.default = findClosestElementAncestor;
//# sourceMappingURL=findClosestElementAncestor.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/fromHtml.js":
/*!*****************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/fromHtml.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var toArray_1 = __webpack_require__(/*! ./toArray */ "./node_modules/roosterjs-editor-dom/lib/utils/toArray.js");
/**
 * Creates an HTML node array from html
 * @param html the html string to create HTML elements from
 * @param ownerDocument Owner document of the result HTML elements
 * @returns An HTML node array to represent the given html string
 */
function fromHtml(html, ownerDocument) {
    var element = ownerDocument.createElement('DIV');
    element.innerHTML = html;
    return toArray_1.default(element.childNodes);
}
exports.default = fromHtml;
//# sourceMappingURL=fromHtml.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/getComputedStyles.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/getComputedStyles.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var findClosestElementAncestor_1 = __webpack_require__(/*! ./findClosestElementAncestor */ "./node_modules/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.js");
/**
 * Get computed styles of a node
 * @param node The node to get computed styles from
 * @param styleNames Names of style to get, can be a single name or an array.
 * Default value is font-family, font-size, color, background-color
 * @returns An array of the computed styles
 */
function getComputedStyles(node, styleNames) {
    if (styleNames === void 0) { styleNames = ['font-family', 'font-size', 'color', 'background-color']; }
    var element = findClosestElementAncestor_1.default(node);
    var result = [];
    styleNames = Array.isArray(styleNames) ? styleNames : [styleNames];
    if (element) {
        var win = element.ownerDocument.defaultView || window;
        var styles = win.getComputedStyle(element);
        if (styles) {
            for (var _i = 0, styleNames_1 = styleNames; _i < styleNames_1.length; _i++) {
                var style = styleNames_1[_i];
                var value = (styles.getPropertyValue(style) || '').toLowerCase();
                value = style == 'font-size' ? px2Pt(value) : value;
                result.push(value);
            }
        }
    }
    return result;
}
exports.default = getComputedStyles;
/**
 * A shortcut for getComputedStyles() when only one style is to be retrieved
 * @param node The node to get style from
 * @param styleName The style name
 * @returns The style value
 */
function getComputedStyle(node, styleName) {
    return getComputedStyles(node, styleName)[0] || '';
}
exports.getComputedStyle = getComputedStyle;
function px2Pt(px) {
    if (px && px.indexOf('px') == px.length - 2) {
        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value
        // So add 0.05 to fix it
        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';
    }
    return px;
}
//# sourceMappingURL=getComputedStyles.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/getLeafNode.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var shouldSkipNode_1 = __webpack_require__(/*! ./shouldSkipNode */ "./node_modules/roosterjs-editor-dom/lib/utils/shouldSkipNode.js");
var getLeafSibling_1 = __webpack_require__(/*! ./getLeafSibling */ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafSibling.js");
/**
 * Get first/last leaf node of the given root node.
 * @param rootNode Root node to get leaf node from
 * @param isFirst True to get first leaf node, false to get last leaf node
 */
function getLeafNode(rootNode, isFirst) {
    var getChild = function (node) { return (isFirst ? node.firstChild : node.lastChild); };
    var result = getChild(rootNode);
    while (result && getChild(result)) {
        result = getChild(result);
    }
    if (result && shouldSkipNode_1.default(result)) {
        result = getLeafSibling_1.getLeafSibling(rootNode, result, isFirst);
    }
    return result;
}
/**
 * Get the first meaningful leaf node
 * @param rootNode Root node to get leaf node from
 */
function getFirstLeafNode(rootNode) {
    return getLeafNode(rootNode, true /*isFirst*/);
}
exports.getFirstLeafNode = getFirstLeafNode;
/**
 * Get the last meaningful leaf node
 * @param rootNode Root node to get leaf node from
 */
function getLastLeafNode(rootNode) {
    return getLeafNode(rootNode, false /*isFirst*/);
}
exports.getLastLeafNode = getLastLeafNode;
//# sourceMappingURL=getLeafNode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/getLeafSibling.js":
/*!***********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/getLeafSibling.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var contains_1 = __webpack_require__(/*! ./contains */ "./node_modules/roosterjs-editor-dom/lib/utils/contains.js");
var getTagOfNode_1 = __webpack_require__(/*! ./getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var shouldSkipNode_1 = __webpack_require__(/*! ./shouldSkipNode */ "./node_modules/roosterjs-editor-dom/lib/utils/shouldSkipNode.js");
/**
 * This walks forwards/backwards DOM tree to get next meaningful node
 * @param rootNode Root node to scope the leaf sibling node
 * @param startNode current node to get sibling node from
 * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node
 * @param skipTags (Optional) tags that child elements will be skipped
 * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped
 */
function getLeafSibling(rootNode, startNode, isNext, skipTags, ignoreSpace) {
    var result = null;
    var getSibling = isNext
        ? function (node) { return node.nextSibling; }
        : function (node) { return node.previousSibling; };
    var getChild = isNext ? function (node) { return node.firstChild; } : function (node) { return node.lastChild; };
    if (contains_1.default(rootNode, startNode)) {
        var curNode = startNode;
        var shouldContinue = true;
        while (shouldContinue) {
            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent
            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)
            var parentNode = curNode.parentNode;
            curNode = getSibling(curNode);
            while (!curNode && parentNode != rootNode) {
                curNode = getSibling(parentNode);
                parentNode = parentNode.parentNode;
            }
            // Now traverse down to get first/last child
            while (curNode &&
                (!skipTags || skipTags.indexOf(getTagOfNode_1.default(curNode)) < 0) &&
                getChild(curNode)) {
                curNode = getChild(curNode);
            }
            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so
            shouldContinue = curNode && shouldSkipNode_1.default(curNode, ignoreSpace);
            if (!shouldContinue) {
                // Found a good leaf node, assign and exit
                result = curNode;
                break;
            }
        }
    }
    return result;
}
exports.getLeafSibling = getLeafSibling;
/**
 * This walks forwards DOM tree to get next meaningful node
 * @param rootNode Root node to scope the leaf sibling node
 * @param startNode current node to get sibling node from
 * @param skipTags (Optional) tags that child elements will be skipped
 */
function getNextLeafSibling(rootNode, startNode, skipTags) {
    return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);
}
exports.getNextLeafSibling = getNextLeafSibling;
/**
 * This walks backwards DOM tree to get next meaningful node
 * @param rootNode Root node to scope the leaf sibling node
 * @param startNode current node to get sibling node from
 * @param skipTags (Optional) tags that child elements will be skipped
 */
function getPreviousLeafSibling(rootNode, startNode, skipTags) {
    return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);
}
exports.getPreviousLeafSibling = getPreviousLeafSibling;
//# sourceMappingURL=getLeafSibling.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/getPendableFormatState.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/getPendableFormatState.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A map from pendable format name to document command
 */
exports.PendableFormatCommandMap = {
    /**
     * Bold
     */
    isBold: "bold" /* Bold */,
    /**
     * Italic
     */
    isItalic: "italic" /* Italic */,
    /**
     * Underline
     */
    isUnderline: "underline" /* Underline */,
    /**
     * StrikeThrough
     */
    isStrikeThrough: "strikeThrough" /* StrikeThrough */,
    /**
     * Subscript
     */
    isSubscript: "subscript" /* Subscript */,
    /**
     * Superscript
     */
    isSuperscript: "superscript" /* Superscript */,
};
/**
 * Get Pendable Format State at cursor.
 * @param document The HTML Document to get format state from
 * @returns A PendableFormatState object which contains the values of pendable format states
 */
function getPendableFormatState(document) {
    var keys = Object.keys(exports.PendableFormatCommandMap);
    return keys.reduce(function (state, key) {
        state[key] = document.queryCommandState(exports.PendableFormatCommandMap[key]);
        return state;
    }, {});
}
exports.default = getPendableFormatState;
//# sourceMappingURL=getPendableFormatState.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js":
/*!*********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Get the html tag of a node, or empty if it is not an element
 * @param node The node to get tag of
 * @returns Tag name in upper case if the given node is an Element, or empty string otherwise
 */
function getTagOfNode(node) {
    return node && node.nodeType == 1 /* Element */ ? node.tagName.toUpperCase() : '';
}
exports.default = getTagOfNode;
//# sourceMappingURL=getTagOfNode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/getTextContent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/getTextContent.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ContentTraverser_1 = __webpack_require__(/*! ../contentTraverser/ContentTraverser */ "./node_modules/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.js");
/**
 * get block element's text content.
 * @param rootNode Root node that the get the textContent of.
 * @returns text content of given text content.
 */
function getTextContent(rootNode) {
    var traverser = ContentTraverser_1.default.createBodyTraverser(rootNode);
    var block = traverser && traverser.currentBlockElement;
    var textContent = [];
    while (block) {
        textContent.push(block.getTextContent());
        block = traverser.getNextBlockElement();
    }
    return textContent.join('\n');
}
exports.default = getTextContent;
//# sourceMappingURL=getTextContent.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/isBlockElement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/isBlockElement.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getTagOfNode_1 = __webpack_require__(/*! ./getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(',');
var BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];
/**
 * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.
 * @param node The node to check
 * @returns True if the node is a block element, otherwise false
 */
function isBlockElement(node) {
    var tag = getTagOfNode_1.default(node);
    return !!(tag &&
        (BLOCK_DISPLAY_STYLES.indexOf(node.style.display) >= 0 ||
            BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0));
}
exports.default = isBlockElement;
//# sourceMappingURL=isBlockElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/isNodeAfter.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/isNodeAfter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Checks if node1 is after node2
 * @param node1 The node to check if it is after another node
 * @param node2 The node to check if another node is after this one
 * @returns True if node1 is after node2, otherwise false
 */
function isNodeAfter(node1, node2) {
    return !!(node1 &&
        node2 &&
        (node2.compareDocumentPosition(node1) & 4 /* Following */) ==
            4 /* Following */);
}
exports.default = isNodeAfter;
//# sourceMappingURL=isNodeAfter.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/isNodeEmpty.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/isNodeEmpty.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getTagOfNode_1 = __webpack_require__(/*! ./getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var VISIBLE_ELEMENT_TAGS = ['IMG'];
var VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');
var ZERO_WIDTH_SPACE = /\u200b/g;
/**
 * Check if a given node has no visible content
 * @param node The node to check
 * @param trimContent Whether trim the text content so that spaces will be treated as empty.
 * Default value is false
 * @returns True if there isn't any visible element inside node, otherwise false
 */
function isNodeEmpty(node, trimContent) {
    if (!node) {
        return false;
    }
    else if (node.nodeType == 3 /* Text */) {
        return trim(node.nodeValue, trimContent) == '';
    }
    else if (node.nodeType == 1 /* Element */) {
        var element = node;
        var textContent = trim(element.textContent, trimContent);
        if (textContent != '' ||
            VISIBLE_ELEMENT_TAGS.indexOf(getTagOfNode_1.default(element)) >= 0 ||
            element.querySelectorAll(VISIBLE_CHILD_ELEMENT_SELECTOR)[0]) {
            return false;
        }
    }
    return true;
}
exports.default = isNodeEmpty;
function trim(s, trim) {
    s = s.replace(ZERO_WIDTH_SPACE, '');
    return trim ? s.trim() : s;
}
//# sourceMappingURL=isNodeEmpty.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/isRtl.js":
/*!**************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/isRtl.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getComputedStyles_1 = __webpack_require__(/*! ./getComputedStyles */ "./node_modules/roosterjs-editor-dom/lib/utils/getComputedStyles.js");
/**
 * Check if the given element is using right-to-left layout
 * @param element An HTML element to check
 * @returns True if the given element is using right-to-left layout, otherwise false
 */
function isRtl(element) {
    return getComputedStyles_1.getComputedStyle(element, 'direction') == 'rtl';
}
exports.default = isRtl;
//# sourceMappingURL=isRtl.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getTagOfNode_1 = __webpack_require__(/*! ./getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
/**
 * HTML void elements
 * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes
 * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside
 * void elements so users don't accidently create child nodes in them
 */
var HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(',');
/**
 * Check if the given node is html void element. Void element cannot have childen
 * @param node The node to check
 */
function isVoidHtmlElement(node) {
    return !!node && HTML_VOID_ELEMENTS.indexOf(getTagOfNode_1.default(node)) >= 0;
}
exports.default = isVoidHtmlElement;
//# sourceMappingURL=isVoidHtmlElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/matchLink.js":
/*!******************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/matchLink.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// http exclude matching regex
// invalid URL example (in paricular on IE and Edge):
// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception
// - http://www.bing.com%1, %1 is invalid
// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)
// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)
// All above % cases if they're after ? (question mark) is then considered valid again
// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception
// - http://www.bing.com@name, @name before ? (question mark) is considered invalid
// - http://www.bing.com/@name, is valid sine it is after / (forward slash)
// - http://www.bing.com?@name, is also valid sinve it is after ? (question mark)
// The regex below is essentially a break down of:
// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%
// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1
// ^[^?]+%00 => to exclude URL like www.bing.com%00
// ^[^?]+%$ => to exclude URL like www.bing.com%
// ^https?:\/\/[^?\/]+@ => to exclude URL like http://www.bing.com@name
// ^www\.[^?\/]+@ => to exclude URL like www.bing.com@name
// , => to exclude url like www.bing,,com
var httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\/\/[^?\/]+@|^www\.[^?\/]+@/i;
// via https://tools.ietf.org/html/rfc1035 Page 7
var labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexes below so don't bother including A-Z
var domainNameRegEx = "(?:" + labelRegEx + "\\.)*" + labelRegEx;
var domainPortRegEx = domainNameRegEx + "(?:\\:[0-9]+)?";
var domainPortWithUrlRegEx = domainPortRegEx + "(?:[\\/\\?]\\S*)?";
var linkMatchRules = {
    http: {
        match: new RegExp("^(?:microsoft-edge:)?http:\\/\\/" + domainPortWithUrlRegEx + "|www\\." + domainPortWithUrlRegEx, 'i'),
        except: httpExcludeRegEx,
        normalizeUrl: function (url) {
            return new RegExp('^(?:microsoft-edge:)?http:\\/\\/', 'i').test(url) ? url : 'http://' + url;
        },
    },
    https: {
        match: new RegExp("^(?:microsoft-edge:)?https:\\/\\/" + domainPortWithUrlRegEx, 'i'),
        except: httpExcludeRegEx,
    },
    mailto: { match: new RegExp('^mailto:\\S+@\\S+\\.\\S+', 'i') },
    notes: { match: new RegExp('^notes:\\/\\/\\S+', 'i') },
    file: { match: new RegExp('^file:\\/\\/\\/?\\S+', 'i') },
    unc: { match: new RegExp('^\\\\\\\\\\S+', 'i') },
    ftp: {
        match: new RegExp("^ftp:\\/\\/" + domainPortWithUrlRegEx + "|ftp\\." + domainPortWithUrlRegEx, 'i'),
        normalizeUrl: function (url) { return (new RegExp('^ftp:\\/\\/', 'i').test(url) ? url : 'ftp://' + url); },
    },
    news: { match: new RegExp("^news:(\\/\\/)?" + domainPortWithUrlRegEx, 'i') },
    telnet: { match: new RegExp("^telnet:(\\/\\/)?" + domainPortWithUrlRegEx, 'i') },
    gopher: { match: new RegExp("^gopher:\\/\\/" + domainPortWithUrlRegEx, 'i') },
    wais: { match: new RegExp("^wais:(\\/\\/)?" + domainPortWithUrlRegEx, 'i') },
};
/**
 * Try to match a given string with link match rules, return matched link
 * @param url Input url to match
 * @param option Link match option, exact or partial. If it is exact match, we need
 * to check the length of matched link and url
 * @param rules Optional link match rules, if not passed, only the default link match
 * rules will be applied
 * @returns The matched link data, or null if no match found.
 * The link data includes an original url and a normalized url
 */
function matchLink(url) {
    if (url) {
        for (var _i = 0, _a = Object.keys(linkMatchRules); _i < _a.length; _i++) {
            var schema = _a[_i];
            var rule = linkMatchRules[schema];
            var matches = url.match(rule.match);
            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {
                return {
                    scheme: schema,
                    originalUrl: url,
                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,
                };
            }
        }
    }
    return null;
}
exports.default = matchLink;
//# sourceMappingURL=matchLink.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/normalizeRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/normalizeRect.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p
 * We validate that and only return a rect when the passed in ClientRect is valid
 */
function normalizeRect(clientRect) {
    var _a = clientRect || { left: 0, right: 0, top: 0, bottom: 0 }, left = _a.left, right = _a.right, top = _a.top, bottom = _a.bottom;
    return left + right + top + bottom > 0
        ? {
            left: Math.round(left),
            right: Math.round(right),
            top: Math.round(top),
            bottom: Math.round(bottom),
        }
        : null;
}
exports.default = normalizeRect;
//# sourceMappingURL=normalizeRect.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/queryElements.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/queryElements.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var toArray_1 = __webpack_require__(/*! ./toArray */ "./node_modules/roosterjs-editor-dom/lib/utils/toArray.js");
/**
 * Query HTML elements in the container by a selector string
 * @param container Container element to query from
 * @param selector Selector string to query
 * @param forEachCallback An optional callback to be invoked on each node in query result
 * @param scope The scope of the query, default value is QueryScope.Body
 * @param range The selection range to query with. This is required when scope is not Body
 * @returns HTML Element array of the query result
 */
function queryElements(container, selector, forEachCallback, scope, range) {
    if (scope === void 0) { scope = 0 /* Body */; }
    if (!container || !selector) {
        return [];
    }
    var elements = toArray_1.default(container.querySelectorAll(selector));
    if (scope != 0 /* Body */ && range) {
        var startContainer_1 = range.startContainer, startOffset = range.startOffset, endContainer_1 = range.endContainer, endOffset = range.endOffset;
        if (startContainer_1.nodeType == 1 /* Element */ && startContainer_1.firstChild) {
            var child = startContainer_1.childNodes[startOffset];
            // range.startOffset can give a value of child.length+1 when selection is after the last child
            // In that case we will use the last child instead
            startContainer_1 = child || startContainer_1.lastChild;
        }
        endContainer_1 =
            endContainer_1.nodeType == 1 /* Element */ && endContainer_1.firstChild && endOffset > 0
                ? endContainer_1.childNodes[endOffset - 1]
                : endContainer_1;
        elements = elements.filter(function (element) {
            return isIntersectWithNodeRange(element, startContainer_1, endContainer_1, scope == 2 /* InSelection */);
        });
    }
    if (forEachCallback) {
        elements.forEach(forEachCallback);
    }
    return elements;
}
exports.default = queryElements;
function isIntersectWithNodeRange(node, startNode, endNode, nodeContainedByRangeOnly) {
    var startPosition = node.compareDocumentPosition(startNode);
    var endPosition = node.compareDocumentPosition(endNode);
    var targetPositions = [0 /* Same */, 8 /* Contains */];
    if (!nodeContainedByRangeOnly) {
        targetPositions.push(16 /* ContainedBy */);
    }
    return (checkPosition(startPosition, targetPositions) || // intersectStart
        checkPosition(endPosition, targetPositions) || // intersectEnd
        (checkPosition(startPosition, [2 /* Preceding */]) && // Contains
            checkPosition(endPosition, [4 /* Following */]) &&
            !checkPosition(endPosition, [16 /* ContainedBy */])));
}
function checkPosition(position, targets) {
    return targets.some(function (target) {
        return target == 0 /* Same */
            ? position == 0 /* Same */
            : (position & target) == target;
    });
}
//# sourceMappingURL=queryElements.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/shouldSkipNode.js":
/*!***********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/shouldSkipNode.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getTagOfNode_1 = __webpack_require__(/*! ./getTagOfNode */ "./node_modules/roosterjs-editor-dom/lib/utils/getTagOfNode.js");
var getComputedStyles_1 = __webpack_require__(/*! ./getComputedStyles */ "./node_modules/roosterjs-editor-dom/lib/utils/getComputedStyles.js");
var CRLF = /^[\r\n]+$/gm;
var CRLFSPACE = /[\t\r\n\u0020\u200B]/gm; // We should only find new line, real space or ZeroWidthSpace (TAB, %20, but not &nbsp;)
/**
 * Skip a node when any of following conditions are true
 * - it is neither Element nor Text
 * - it is a text node but is empty
 * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)
 * - has a display:none
 * - it is just <div></div>
 * @param node The node to check
 * @param ignoreSpace (Optional) True to ignore pure space text node of the node when check.
 * If the value of a node value is only space, set this to true will treat this node as skippable.
 * Default value is false
 */
function shouldSkipNode(node, ignoreSpace) {
    if (node.nodeType == 3 /* Text */) {
        if (!node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue)) {
            return true;
        }
        else if (ignoreSpace && node.nodeValue.replace(CRLFSPACE, '') == '') {
            return true;
        }
        else {
            return false;
        }
    }
    else if (node.nodeType == 1 /* Element */) {
        if (getComputedStyles_1.getComputedStyle(node, 'display') == 'none') {
            return true;
        }
        var tag = getTagOfNode_1.default(node);
        if (tag == 'DIV' || tag == 'SPAN') {
            // Empty SPAN/DIV or SPAN/DIV with only unmeaningful children is unmeaningful,
            // because it can render nothing. If we keep them here, there may be unexpected
            // LI elements added for those unmeaningful nodes.
            for (var child = node.firstChild; !!child; child = child.nextSibling) {
                if (!shouldSkipNode(child, ignoreSpace)) {
                    return false;
                }
            }
            return true;
        }
        else {
            // There may still be other cases that the node is not meaningful.
            // We can add those cases here once we hit them.
            return false;
        }
    }
    else {
        return true;
    }
}
exports.default = shouldSkipNode;
//# sourceMappingURL=shouldSkipNode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/splitParentNode.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/splitParentNode.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var isNodeAfter_1 = __webpack_require__(/*! ./isNodeAfter */ "./node_modules/roosterjs-editor-dom/lib/utils/isNodeAfter.js");
/**
 * Split parent node of the given node before/after the given node.
 * When a parent node contains [A,B,C] and pass B as the given node,
 * If split before, the new nodes will be [A][B,C] and returns [A];
 * otherwise, it will be [A,B][C] and returns [C].
 * @param node The node to split before/after
 * @param splitBefore Whether split before or after
 * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),
 * we remove it. @default false
 * @returns The new parent node
 */
function splitParentNode(node, splitBefore) {
    if (!node || !node.parentNode) {
        return null;
    }
    var parentNode = node.parentNode;
    var newParent = parentNode.cloneNode(false /*deep*/);
    newParent.removeAttribute('id');
    if (splitBefore) {
        while (parentNode.firstChild && parentNode.firstChild != node) {
            newParent.appendChild(parentNode.firstChild);
        }
    }
    else {
        while (node.nextSibling) {
            newParent.appendChild(node.nextSibling);
        }
    }
    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true
    if (newParent.firstChild && newParent.innerHTML != '') {
        parentNode.parentNode.insertBefore(newParent, splitBefore ? parentNode : parentNode.nextSibling);
    }
    else {
        newParent = null;
    }
    return newParent;
}
exports.default = splitParentNode;
/**
 * Split parent node by a balanced node range
 * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.
 * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored
 * @returns The parent node of the given node range if the given nodes are balanced, otherwise null
 */
function splitBalancedNodeRange(nodes) {
    var start = Array.isArray(nodes) ? nodes[0] : nodes;
    var end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;
    var parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;
    if (parentNode) {
        if (isNodeAfter_1.default(start, end)) {
            var temp = end;
            end = start;
            start = temp;
        }
        splitParentNode(start, true /*splitBefore*/);
        splitParentNode(end, false /*splitBefore*/);
    }
    return parentNode;
}
exports.splitBalancedNodeRange = splitBalancedNodeRange;
//# sourceMappingURL=splitParentNode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/splitTextNode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/splitTextNode.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Split a text node into two parts by an offset number, and return one of them
 * @param textNode The text node to split
 * @param offset The offset number to split at
 * @param returnFirstPart True to return the first part, then the passed in textNode will become the second part.
 * Otherwise return the second part, and the passed in textNode will become the first part
 */
function splitTextNode(textNode, offset, returnFirstPart) {
    var firstPart = textNode.nodeValue.substr(0, offset);
    var secondPart = textNode.nodeValue.substr(offset);
    var newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);
    textNode.nodeValue = returnFirstPart ? secondPart : firstPart;
    textNode.parentNode.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);
    return newNode;
}
exports.default = splitTextNode;
//# sourceMappingURL=splitTextNode.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/toArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/toArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function toArray(collection) {
    return [].slice.call(collection);
}
exports.default = toArray;
//# sourceMappingURL=toArray.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/unwrap.js":
/*!***************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/unwrap.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Removes the node and keep all children in place, return the parentNode where the children are attached
 * @param node the node to remove
 */
function unwrap(node) {
    // Unwrap requires a parentNode
    var parentNode = node ? node.parentNode : null;
    if (!parentNode) {
        return null;
    }
    while (node.firstChild) {
        parentNode.insertBefore(node.firstChild, node);
    }
    parentNode.removeChild(node);
    return parentNode;
}
exports.default = unwrap;
//# sourceMappingURL=unwrap.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-dom/lib/utils/wrap.js":
/*!*************************************************************!*\
  !*** ./node_modules/roosterjs-editor-dom/lib/utils/wrap.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fromHtml_1 = __webpack_require__(/*! ./fromHtml */ "./node_modules/roosterjs-editor-dom/lib/utils/fromHtml.js");
var isHTMLElement_1 = __webpack_require__(/*! ../typeUtils/isHTMLElement */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isHTMLElement.js");
var isNode_1 = __webpack_require__(/*! ../typeUtils/isNode */ "./node_modules/roosterjs-editor-dom/lib/typeUtils/isNode.js");
function wrap(nodes, wrapper) {
    nodes = !nodes ? [] : isNode_1.default(nodes) ? [nodes] : nodes;
    if (nodes.length == 0 || !nodes[0]) {
        return null;
    }
    if (!isHTMLElement_1.default(wrapper)) {
        var document_1 = nodes[0].ownerDocument;
        wrapper = wrapper || 'div';
        wrapper = /^\w+$/.test(wrapper)
            ? document_1.createElement(wrapper)
            : fromHtml_1.default(wrapper, document_1)[0];
    }
    var parentNode = nodes[0].parentNode;
    if (parentNode) {
        parentNode.insertBefore(wrapper, nodes[0]);
    }
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var node = nodes_1[_i];
        wrapper.appendChild(node);
    }
    return wrapper;
}
exports.default = wrap;
//# sourceMappingURL=wrap.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/ContentEdit.js":
/*!******************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/ContentEdit.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./plugins/ContentEdit/index */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/index.js"));
//# sourceMappingURL=ContentEdit.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/CustomReplace.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/CustomReplace.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./plugins/CustomReplace/index */ "./node_modules/roosterjs-editor-plugins/lib/plugins/CustomReplace/index.js"));
//# sourceMappingURL=CustomReplace.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/Entity.js":
/*!*************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/Entity.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./plugins/Entity/index */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/index.js"));
//# sourceMappingURL=Entity.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/HyperLink.js":
/*!****************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/HyperLink.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./plugins/HyperLink/index */ "./node_modules/roosterjs-editor-plugins/lib/plugins/HyperLink/index.js"));
//# sourceMappingURL=HyperLink.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/ImageResize.js":
/*!******************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/ImageResize.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./plugins/ImageResize/index */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ImageResize/index.js"));
//# sourceMappingURL=ImageResize.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/Paste.js":
/*!************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/Paste.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./plugins/Paste/index */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/index.js"));
//# sourceMappingURL=Paste.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/Picker.js":
/*!*************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/Picker.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./plugins/Picker/index */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Picker/index.js"));
//# sourceMappingURL=Picker.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/TableResize.js":
/*!******************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/TableResize.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./plugins/TableResize/index */ "./node_modules/roosterjs-editor-plugins/lib/plugins/TableResize/index.js"));
//# sourceMappingURL=TableResize.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/Watermark.js":
/*!****************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/Watermark.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./plugins/Watermark/index */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Watermark/index.js"));
//# sourceMappingURL=Watermark.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ContentEdit */ "./node_modules/roosterjs-editor-plugins/lib/ContentEdit.js"));
__export(__webpack_require__(/*! ./CustomReplace */ "./node_modules/roosterjs-editor-plugins/lib/CustomReplace.js"));
__export(__webpack_require__(/*! ./HyperLink */ "./node_modules/roosterjs-editor-plugins/lib/HyperLink.js"));
__export(__webpack_require__(/*! ./ImageResize */ "./node_modules/roosterjs-editor-plugins/lib/ImageResize.js"));
__export(__webpack_require__(/*! ./Paste */ "./node_modules/roosterjs-editor-plugins/lib/Paste.js"));
__export(__webpack_require__(/*! ./Picker */ "./node_modules/roosterjs-editor-plugins/lib/Picker.js"));
__export(__webpack_require__(/*! ./TableResize */ "./node_modules/roosterjs-editor-plugins/lib/TableResize.js"));
__export(__webpack_require__(/*! ./Watermark */ "./node_modules/roosterjs-editor-plugins/lib/Watermark.js"));
__export(__webpack_require__(/*! ./Entity */ "./node_modules/roosterjs-editor-plugins/lib/Entity.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEdit.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEdit.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ContentEditFeatures_1 = __webpack_require__(/*! ./ContentEditFeatures */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEditFeatures.js");
var autoLinkFeatures_1 = __webpack_require__(/*! ./features/autoLinkFeatures */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/autoLinkFeatures.js");
var shortcutFeatures_1 = __webpack_require__(/*! ./features/shortcutFeatures */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/shortcutFeatures.js");
var insertLineBeforeStructuredNodeFeature_1 = __webpack_require__(/*! ./features/insertLineBeforeStructuredNodeFeature */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/insertLineBeforeStructuredNodeFeature.js");
var noCycleCursorMove_1 = __webpack_require__(/*! ./features/noCycleCursorMove */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/noCycleCursorMove.js");
var tableFeatures_1 = __webpack_require__(/*! ./features/tableFeatures */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/tableFeatures.js");
var markdownFeatures_1 = __webpack_require__(/*! ./features/markdownFeatures */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.js");
var listFeatures_1 = __webpack_require__(/*! ./features/listFeatures */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/listFeatures.js");
var quoteFeatures_1 = __webpack_require__(/*! ./features/quoteFeatures */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/quoteFeatures.js");
/**
 * An editor plugin to handle content edit event.
 * The following cases are included:
 * 1. Auto increase/decrease indentation on Tab, Shift+tab
 * 2. Enter, Backspace on empty list item
 * 3. Enter, Backspace on empty blockquote line
 * 4. Auto bullet/numbering
 * 5. Auto link
 * 6. Tab in table
 * 7. Up/Down in table
 * 8. Manage list style
 */
var ContentEdit = /** @class */ (function () {
    /**
     * Create instance of ContentEdit plugin
     * @param features An optional feature set to determine which features the plugin should provide
     */
    function ContentEdit(featureSet) {
        this.featureSet = featureSet;
    }
    /**
     * Get a friendly name of  this plugin
     */
    ContentEdit.prototype.getName = function () {
        return 'ContentEdit';
    };
    /**
     * Initialize this plugin
     * @param editor The editor instance
     */
    ContentEdit.prototype.initialize = function (editor) {
        var _this = this;
        this.editor = editor;
        this.getFilteredFeatures().forEach(function (feature) { return _this.editor.addContentEditFeature(feature); });
    };
    /**
     * Dispose this plugin
     */
    ContentEdit.prototype.dispose = function () {
        this.editor = null;
    };
    ContentEdit.prototype.getFilteredFeatures = function () {
        var featureSet = this.featureSet || ContentEditFeatures_1.getDefaultContentEditFeatures();
        var allFeatures = {
            indentWhenTab: listFeatures_1.IndentWhenTab,
            outdentWhenShiftTab: listFeatures_1.OutdentWhenShiftTab,
            outdentWhenBackspaceOnEmptyFirstLine: listFeatures_1.OutdentWhenBackOn1stEmptyLine,
            outdentWhenEnterOnEmptyLine: listFeatures_1.OutdentWhenEnterOnEmptyLine,
            mergeInNewLineWhenBackspaceOnFirstChar: listFeatures_1.MergeInNewLine,
            unquoteWhenBackspaceOnEmptyFirstLine: quoteFeatures_1.UnquoteWhenBackOnEmpty1stLine,
            unquoteWhenEnterOnEmptyLine: quoteFeatures_1.UnquoteWhenEnterOnEmptyLine,
            tabInTable: tableFeatures_1.TabInTable,
            upDownInTable: tableFeatures_1.UpDownInTable,
            insertLineBeforeStructuredNodeFeature: insertLineBeforeStructuredNodeFeature_1.InsertLineBeforeStructuredNodeFeature,
            autoBullet: listFeatures_1.AutoBullet,
            autoLink: autoLinkFeatures_1.AutoLink,
            unlinkWhenBackspaceAfterLink: autoLinkFeatures_1.UnlinkWhenBackspaceAfterLink,
            defaultShortcut: shortcutFeatures_1.DefaultShortcut,
            noCycleCursorMove: noCycleCursorMove_1.NoCycleCursorMove,
            smartOrderedList: listFeatures_1.getSmartOrderedList(featureSet.smartOrderedListStyles),
            markdownBold: markdownFeatures_1.MarkdownBold,
            markdownItalic: markdownFeatures_1.MarkdownItalic,
            markdownStrikethru: markdownFeatures_1.MarkdownStrikethru,
            markdownInlineCode: markdownFeatures_1.MarkdownInlineCode,
        };
        var keys = Object.keys(allFeatures);
        return keys.filter(function (key) { return featureSet[key]; }).map(function (key) { return allFeatures[key]; });
    };
    return ContentEdit;
}());
exports.default = ContentEdit;
//# sourceMappingURL=ContentEdit.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEditFeatures.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEditFeatures.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Get default feature set of ContentEdit plugin
 */
function getDefaultContentEditFeatures() {
    return {
        autoLink: true,
        indentWhenTab: true,
        outdentWhenShiftTab: true,
        outdentWhenBackspaceOnEmptyFirstLine: true,
        outdentWhenEnterOnEmptyLine: roosterjs_editor_dom_1.Browser.isIE || roosterjs_editor_dom_1.Browser.isChrome,
        mergeInNewLineWhenBackspaceOnFirstChar: false,
        unquoteWhenBackspaceOnEmptyFirstLine: true,
        unquoteWhenEnterOnEmptyLine: true,
        autoBullet: true,
        tabInTable: true,
        upDownInTable: roosterjs_editor_dom_1.Browser.isChrome || roosterjs_editor_dom_1.Browser.isSafari,
        insertLineBeforeStructuredNodeFeature: false,
        defaultShortcut: true,
        unlinkWhenBackspaceAfterLink: false,
        noCycleCursorMove: roosterjs_editor_dom_1.Browser.isChrome,
        smartOrderedList: false,
        smartOrderedListStyles: ['lower-alpha', 'lower-roman', 'decimal'],
        markdownBold: true,
        markdownItalic: true,
        markdownStrikethru: true,
        markdownInlineCode: true,
    };
}
exports.getDefaultContentEditFeatures = getDefaultContentEditFeatures;
//# sourceMappingURL=ContentEditFeatures.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/autoLinkFeatures.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/autoLinkFeatures.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_editor_api_1 = __webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js");
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
/**
 * When user type, they may end a link with a puncatuation, i.e. www.bing.com;
 * we need to trim off the trailing puncatuation before turning it to link match
 */
var TRAILING_PUNCTUATION_REGEX = /[.+=\s:;"',>]+$/i;
var MINIMUM_LENGTH = 5;
/**
 * AutoLink edit feature, provides the ability to automatically convert text user typed or pasted
 * in hyperlink format into a real hyperlink
 */
exports.AutoLink = {
    keys: [13 /* ENTER */, 32 /* SPACE */, 2048 /* CONTENTCHANGED */],
    shouldHandleEvent: cacheGetLinkData,
    handleEvent: autoLink,
};
/**
 * UnlinkWhenBackspaceAfterLink edit feature, provides the ability to convert a hyperlink back into text
 * if user presses BACKSPACE right after a hyperlink
 */
exports.UnlinkWhenBackspaceAfterLink = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: hasLinkBeforeCursor,
    handleEvent: function (event, editor) {
        event.rawEvent.preventDefault();
        roosterjs_editor_api_1.removeLink(editor);
    },
};
function cacheGetLinkData(event, editor) {
    return event.eventType == 0 /* KeyDown */ ||
        (event.eventType == 6 /* ContentChanged */ && event.source == "Paste" /* Paste */)
        ? roosterjs_editor_core_1.cacheGetEventData(event, 'LINK_DATA', function () {
            // First try to match link from the whole paste string from the plain text in clipboard.
            // This helps when we paste a link next to some existing character, and the text we got
            // from clipboard will only contain what we pasted, any existing characters will not
            // be included.
            var clipboardData = event.eventType == 6 /* ContentChanged */ &&
                event.source == "Paste" /* Paste */ &&
                event.data;
            var link = roosterjs_editor_dom_1.matchLink((clipboardData.text || '').trim());
            var searcher = roosterjs_editor_core_1.cacheGetContentSearcher(event, editor);
            // In case the matched link is already inside a <A> tag, we do a range search.
            // getRangeFromText will return null if the given text is already in a LinkInlineElement
            if (link && searcher.getRangeFromText(link.originalUrl, false /*exactMatch*/)) {
                return link;
            }
            var word = searcher && searcher.getWordBefore();
            if (word && word.length > MINIMUM_LENGTH) {
                // Check for trailing punctuation
                var trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);
                var trailingPunctuation = (trailingPunctuations || [])[0] || '';
                var candidate_1 = word.substring(0, word.length - trailingPunctuation.length);
                // Do special handling for ')', '}', ']'
                ['()', '{}', '[]'].forEach(function (str) {
                    if (candidate_1[candidate_1.length - 1] == str[1] &&
                        candidate_1.indexOf(str[0]) < 0) {
                        candidate_1 = candidate_1.substr(0, candidate_1.length - 1);
                    }
                });
                // Match and replace in editor
                return roosterjs_editor_dom_1.matchLink(candidate_1);
            }
            return null;
        })
        : null;
}
function hasLinkBeforeCursor(event, editor) {
    var contentSearcher = roosterjs_editor_core_1.cacheGetContentSearcher(event, editor);
    var inline = contentSearcher.getInlineElementBefore();
    return inline instanceof roosterjs_editor_dom_1.LinkInlineElement;
}
function autoLink(event, editor) {
    var anchor = editor.getDocument().createElement('a');
    var linkData = cacheGetLinkData(event, editor);
    // Need to get searcher before we enter the async callback since the callback can happen when cursor is moved to next line
    // and at that time a new searcher won't be able to find the link text to replace
    var searcher = editor.getContentSearcherOfCursor();
    anchor.textContent = linkData.originalUrl;
    anchor.href = linkData.normalizedUrl;
    editor.runAsync(function () {
        editor.performAutoComplete(function () {
            roosterjs_editor_api_1.replaceWithNode(editor, linkData.originalUrl, anchor, false /* exactMatch */, searcher);
            // The content at cursor has changed. Should also clear the cursor data cache
            roosterjs_editor_core_1.clearContentSearcherCache(event);
            return anchor;
        }, "AutoLink" /* AutoLink */);
    });
}
//# sourceMappingURL=autoLinkFeatures.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/insertLineBeforeStructuredNodeFeature.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/insertLineBeforeStructuredNodeFeature.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
// Edge can sometimes lose current format when Enter to new line.
// So here we add an extra SPAN for Edge to workaround this bug
var NEWLINE_HTML = roosterjs_editor_dom_1.Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>';
var CHILD_PARENT_TAG_MAP = {
    TD: 'TABLE',
    TH: 'TABLE',
    LI: 'OL,UL',
};
var CHILD_SELECTOR = Object.keys(CHILD_PARENT_TAG_MAP).join(',');
/**
 * InsertLineBeforeStructuredNode edit feature, provides the ability to insert an empty line before
 * a structured element (bullet/numbering list, blockquote, table) if the element is at beginning of
 * document
 */
exports.InsertLineBeforeStructuredNodeFeature = {
    keys: [13 /* ENTER */],
    shouldHandleEvent: cacheGetStructuredElement,
    handleEvent: function (event, editor) {
        var element = cacheGetStructuredElement(event, editor);
        var div = roosterjs_editor_dom_1.fromHtml(NEWLINE_HTML, editor.getDocument())[0];
        editor.addUndoSnapshot(function () {
            element.parentNode.insertBefore(div, element);
            // Select the new line when we are in table. This is the same behavior with Word
            if (roosterjs_editor_dom_1.getTagOfNode(element) == 'TABLE') {
                editor.select(new roosterjs_editor_dom_1.Position(div, 0 /* Begin */).normalize());
            }
        });
        event.rawEvent.preventDefault();
    },
};
function cacheGetStructuredElement(event, editor) {
    return roosterjs_editor_core_1.cacheGetEventData(event, 'FIRST_STRUCTURE', function () {
        // Provide a chance to keep browser default behavior by pressing SHIFT
        var element = event.rawEvent.shiftKey ? null : editor.getElementAtCursor(CHILD_SELECTOR);
        if (element) {
            var range = editor.getSelectionRange();
            if (range &&
                range.collapsed &&
                roosterjs_editor_dom_1.isPositionAtBeginningOf(roosterjs_editor_dom_1.Position.getStart(range), element) &&
                !editor.getBodyTraverser(element).getPreviousBlockElement()) {
                return editor.getElementAtCursor(CHILD_PARENT_TAG_MAP[roosterjs_editor_dom_1.getTagOfNode(element)]);
            }
        }
        return null;
    });
}
//# sourceMappingURL=insertLineBeforeStructuredNodeFeature.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/listFeatures.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/listFeatures.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_api_1 = __webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
/**
 * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB
 */
exports.IndentWhenTab = {
    keys: [9 /* TAB */],
    shouldHandleEvent: function (event, editor) {
        return !event.rawEvent.shiftKey && cacheGetListElement(event, editor);
    },
    handleEvent: function (event, editor) {
        roosterjs_editor_api_1.setIndentation(editor, 0 /* Increase */);
        event.rawEvent.preventDefault();
    },
};
/**
 * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB
 */
exports.OutdentWhenShiftTab = {
    keys: [9 /* TAB */],
    shouldHandleEvent: function (event, editor) {
        return event.rawEvent.shiftKey && cacheGetListElement(event, editor);
    },
    handleEvent: function (event, editor) {
        roosterjs_editor_api_1.setIndentation(editor, 1 /* Decrease */);
        event.rawEvent.preventDefault();
    },
};
/**
 * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press
 * BACKSPACE at beginning of a list item
 */
exports.MergeInNewLine = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: function (event, editor) {
        var li = roosterjs_editor_core_1.cacheGetElementAtCursor(editor, event, 'LI');
        var range = editor.getSelectionRange();
        return li && range && roosterjs_editor_dom_1.isPositionAtBeginningOf(roosterjs_editor_dom_1.Position.getStart(range), li);
    },
    handleEvent: function (event, editor) {
        var li = roosterjs_editor_core_1.cacheGetElementAtCursor(editor, event, 'LI');
        if (li.previousSibling) {
            editor.runAsync(function () {
                var br = editor.getDocument().createElement('BR');
                editor.insertNode(br);
                editor.select(br, -3 /* After */);
            });
        }
        else {
            toggleListAndPreventDefault(event, editor);
        }
    },
};
/**
 * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press
 * BACKSPACE at the first and empty line of a list
 */
exports.OutdentWhenBackOn1stEmptyLine = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: function (event, editor) {
        var li = roosterjs_editor_core_1.cacheGetElementAtCursor(editor, event, 'LI');
        return li && roosterjs_editor_dom_1.isNodeEmpty(li) && !li.previousSibling;
    },
    handleEvent: toggleListAndPreventDefault,
};
/**
 * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press
 * ENTER at the beginning of an empty line of a list
 */
exports.OutdentWhenEnterOnEmptyLine = {
    keys: [13 /* ENTER */],
    shouldHandleEvent: function (event, editor) {
        var li = roosterjs_editor_core_1.cacheGetElementAtCursor(editor, event, 'LI');
        return !event.rawEvent.shiftKey && li && roosterjs_editor_dom_1.isNodeEmpty(li);
    },
    handleEvent: function (event, editor) {
        editor.performAutoComplete(function () { return toggleListAndPreventDefault(event, editor); });
    },
};
/**
 * AutoBullet edit feature, provides the ablility to automatically convert current line into a list.
 * When user input "1. ", convert into a numbering list
 * When user input "- " or "* ", convert into a bullet list
 */
exports.AutoBullet = {
    keys: [32 /* SPACE */],
    shouldHandleEvent: function (event, editor) {
        if (!cacheGetListElement(event, editor)) {
            var searcher = roosterjs_editor_core_1.cacheGetContentSearcher(event, editor);
            var textBeforeCursor = searcher.getSubStringBefore(3);
            // Auto list is triggered if:
            // 1. Text before cursor exactly mathces '*', '-' or '1.'
            // 2. There's no non-text inline entities before cursor
            return (['*', '-', '1.'].indexOf(textBeforeCursor) >= 0 &&
                !searcher.getNearestNonTextInlineElement());
        }
        return false;
    },
    handleEvent: function (event, editor) {
        editor.runAsync(function () {
            editor.performAutoComplete(function () {
                var searcher = editor.getContentSearcherOfCursor();
                var textBeforeCursor = searcher.getSubStringBefore(3);
                var rangeToDelete = searcher.getRangeFromText(textBeforeCursor, true /*exactMatch*/);
                if (rangeToDelete) {
                    rangeToDelete.deleteContents();
                    var node = rangeToDelete.startContainer;
                    if ((node === null || node === void 0 ? void 0 : node.nodeType) == 3 /* Text */ &&
                        node.nodeValue == '' &&
                        !node.previousSibling &&
                        !node.nextSibling) {
                        var br = editor.getDocument().createElement('BR');
                        editor.insertNode(br);
                        editor.select(br, -2 /* Before */);
                    }
                }
                if (textBeforeCursor.indexOf('1.') == 0) {
                    roosterjs_editor_api_1.toggleNumbering(editor);
                }
                else {
                    roosterjs_editor_api_1.toggleBullet(editor);
                }
            });
        });
    },
};
/**
 * Get an instance of SmartOrderedList edit feature. This feature provides the ability to use different
 * number style for different level of numbering list.
 * @param styleList The list of number styles used for this feature.
 * See https://www.w3schools.com/cssref/pr_list-style-type.asp for more information
 */
function getSmartOrderedList(styleList) {
    return {
        keys: [2048 /* CONTENTCHANGED */],
        shouldHandleEvent: function (event, editor) { return roosterjs_editor_dom_1.isHTMLOListElement(event.data); },
        handleEvent: function (event, editor) {
            var ol = event.data;
            var parentOl = editor.getElementAtCursor('OL', ol.parentNode);
            if (parentOl) {
                // The style list must has at least one value. If no value is passed in, fallback to decimal
                var styles = styleList && styleList.length > 0 ? styleList : ['decimal'];
                ol.style.listStyle =
                    styles[(styles.indexOf(parentOl.style.listStyle) + 1) % styles.length];
            }
        },
    };
}
exports.getSmartOrderedList = getSmartOrderedList;
function toggleListAndPreventDefault(event, editor) {
    var listInfo = cacheGetListElement(event, editor);
    if (listInfo) {
        var listElement = listInfo[0];
        var tag = roosterjs_editor_dom_1.getTagOfNode(listElement);
        if (tag == 'UL') {
            roosterjs_editor_api_1.toggleBullet(editor);
        }
        else if (tag == 'OL') {
            roosterjs_editor_api_1.toggleNumbering(editor);
        }
        editor.focus();
        event.rawEvent.preventDefault();
    }
}
function cacheGetListElement(event, editor) {
    var li = roosterjs_editor_core_1.cacheGetElementAtCursor(editor, event, 'LI,TABLE');
    var listElement = li && roosterjs_editor_dom_1.getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);
    return listElement ? [listElement, li] : null;
}
//# sourceMappingURL=listFeatures.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var ZERO_WIDTH_SPACE = '\u200B';
function generateBasicMarkdownFeature(key, triggerCharacter, elementTag, useShiftKey) {
    return {
        keys: [key],
        shouldHandleEvent: function (event, editor) {
            return event.rawEvent.shiftKey === useShiftKey &&
                !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);
        },
        handleEvent: function (event, editor) {
            // runAsync is here to allow the event to complete so autocomplete will present the trigger character.
            editor.runAsync(function () {
                handleMarkdownEvent(event, editor, triggerCharacter, elementTag);
            });
        },
    };
}
function cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter) {
    return roosterjs_editor_core_1.cacheGetEventData(event, 'MARKDOWN_RANGE', function () {
        var searcher = roosterjs_editor_core_1.cacheGetContentSearcher(event, editor);
        var startPosition;
        var endPosition;
        searcher.forEachTextInlineElement(function (textInlineElement) {
            if (endPosition && startPosition) {
                return true;
            }
            var inlineTextContent = textInlineElement.getTextContent();
            // special case for immediately preceeding character being whitespace
            if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {
                return false;
            }
            // special case for consecutive trigger characters
            if (inlineTextContent[inlineTextContent.length - 1] === triggerCharacter) {
                return false;
            }
            if (!endPosition) {
                endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);
            }
            if (inlineTextContent[0] == triggerCharacter) {
                startPosition = textInlineElement.getStartPosition();
            }
            else {
                var contentIndex = inlineTextContent.length - 1;
                for (; contentIndex > 0; contentIndex--) {
                    if (startPosition) {
                        return true;
                    }
                    if (inlineTextContent[contentIndex] == triggerCharacter &&
                        inlineTextContent[contentIndex - 1].trim().length == 0) {
                        startPosition = textInlineElement.getStartPosition().move(contentIndex);
                        return true;
                    }
                }
            }
        });
        return !!startPosition && !!endPosition && roosterjs_editor_dom_1.createRange(startPosition, endPosition);
    });
}
function handleMarkdownEvent(event, editor, triggerCharacter, elementTag) {
    editor.performAutoComplete(function () {
        var range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);
        if (!!range) {
            // get the text content range
            var textContentRange = range.cloneRange();
            textContentRange.setStart(textContentRange.startContainer, textContentRange.startOffset + 1);
            // set the removal range to include the typed last character.
            range.setEnd(range.endContainer, range.endOffset + 1);
            // extract content and put it into a new element.
            var elementToWrap = editor.getDocument().createElement(elementTag);
            elementToWrap.appendChild(textContentRange.extractContents());
            range.deleteContents();
            // ZWS here ensures we don't end up inside the newly created node.
            var nonPrintedSpaceTextNode = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);
            range.insertNode(nonPrintedSpaceTextNode);
            range.insertNode(elementToWrap);
            editor.select(nonPrintedSpaceTextNode, -1 /* End */);
        }
    }, "Format" /* Format */);
}
/**
 * Markdown bold feature. Bolds text with markdown shortcuts.
 */
exports.MarkdownBold = generateBasicMarkdownFeature(56 /* EIGHT_ASTIRISK */, '*', 'b', true);
/**
 * Markdown italics feature. Italicises text with markdown shortcuts.
 */
exports.MarkdownItalic = generateBasicMarkdownFeature(189 /* DASH_UNDERSCORE */, '_', 'i', true);
/**
 * Markdown strikethru feature. Strikethrus text with markdown shortcuts.
 */
exports.MarkdownStrikethru = generateBasicMarkdownFeature(192 /* GRAVE_TILDE */, '~', 's', true);
/**
 * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.
 */
exports.MarkdownInlineCode = generateBasicMarkdownFeature(192 /* GRAVE_TILDE */, '`', 'code', false);
//# sourceMappingURL=markdownFeatures.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/noCycleCursorMove.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/noCycleCursorMove.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
exports.NoCycleCursorMove = {
    keys: [37 /* LEFT */, 39 /* RIGHT */],
    allowFunctionKeys: true,
    shouldHandleEvent: function (event, editor, ctrlOrMeta) {
        var range;
        var position;
        if (!ctrlOrMeta ||
            !(range = editor.getSelectionRange()) ||
            !range.collapsed ||
            !(position = roosterjs_editor_dom_1.Position.getStart(range)) ||
            !editor.isPositionAtBeginning(position)) {
            return false;
        }
        var rtl = roosterjs_editor_dom_1.isRtl(position.element);
        var rawEvent = event.rawEvent;
        return (!rtl && rawEvent.which == 37 /* LEFT */) || (rtl && rawEvent.which == 39 /* RIGHT */);
    },
    handleEvent: function (event) {
        event.rawEvent.preventDefault();
    },
};
//# sourceMappingURL=noCycleCursorMove.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/quoteFeatures.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/quoteFeatures.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var QUOTE_TAG = 'BLOCKQUOTE';
var STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');
/**
 * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when
 * user press BACKSPACE on first and empty line of a BLOCKQUOTE
 */
exports.UnquoteWhenBackOnEmpty1stLine = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: function (event, editor) {
        var childOfQuote = cacheGetQuoteChild(event, editor);
        return childOfQuote && roosterjs_editor_dom_1.isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;
    },
    handleEvent: splitQuote,
};
/**
 * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when
 * user press ENTER on an empty line of a BLOCKQUOTE
 */
exports.UnquoteWhenEnterOnEmptyLine = {
    keys: [13 /* ENTER */],
    shouldHandleEvent: function (event, editor) {
        var childOfQuote = cacheGetQuoteChild(event, editor);
        var shift = event.rawEvent.shiftKey;
        return !shift && childOfQuote && roosterjs_editor_dom_1.isNodeEmpty(childOfQuote);
    },
    handleEvent: function (event, editor) { return editor.performAutoComplete(function () { return splitQuote(event, editor); }); },
};
function cacheGetQuoteChild(event, editor) {
    return roosterjs_editor_core_1.cacheGetEventData(event, 'QUOTE_CHILD', function () {
        var quote = editor.getElementAtCursor(STRUCTURED_TAGS);
        if (quote && roosterjs_editor_dom_1.getTagOfNode(quote) == QUOTE_TAG) {
            var pos = editor.getFocusedPosition();
            var block = pos && editor.getBlockElementAtNode(pos.normalize().node);
            if (block) {
                var node = block.getStartNode() == quote
                    ? block.getStartNode()
                    : block.collapseToSingleElement();
                return roosterjs_editor_dom_1.isNodeEmpty(node) ? node : null;
            }
        }
        return null;
    });
}
function splitQuote(event, editor) {
    editor.addUndoSnapshot(function () {
        var childOfQuote = cacheGetQuoteChild(event, editor);
        var parent;
        if (roosterjs_editor_dom_1.getTagOfNode(childOfQuote) == QUOTE_TAG) {
            childOfQuote = roosterjs_editor_dom_1.wrap(roosterjs_editor_dom_1.toArray(childOfQuote.childNodes));
        }
        parent = roosterjs_editor_dom_1.splitBalancedNodeRange(childOfQuote);
        roosterjs_editor_dom_1.unwrap(parent);
        editor.select(childOfQuote, 0 /* Begin */);
    });
    event.rawEvent.preventDefault();
}
//# sourceMappingURL=quoteFeatures.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/shortcutFeatures.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/shortcutFeatures.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var roosterjs_editor_api_1 = __webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js");
function createCommand(winKey, macKey, action) {
    return {
        winKey: winKey,
        macKey: macKey,
        action: action,
    };
}
var commands = [
    createCommand(256 /* Ctrl */ | 66 /* B */, 512 /* Meta */ | 66 /* B */, roosterjs_editor_api_1.toggleBold),
    createCommand(256 /* Ctrl */ | 73 /* I */, 512 /* Meta */ | 73 /* I */, roosterjs_editor_api_1.toggleItalic),
    createCommand(256 /* Ctrl */ | 85 /* U */, 512 /* Meta */ | 85 /* U */, roosterjs_editor_api_1.toggleUnderline),
    createCommand(256 /* Ctrl */ | 90 /* Z */, 512 /* Meta */ | 90 /* Z */, function (editor) { return editor.undo(); }),
    createCommand(256 /* Ctrl */ | 89 /* Y */, 512 /* Meta */ | 1024 /* Shift */ | 90 /* Z */, function (editor) { return editor.redo(); }),
    createCommand(256 /* Ctrl */ | 190 /* PERIOD */, 512 /* Meta */ | 190 /* PERIOD */, roosterjs_editor_api_1.toggleBullet),
    createCommand(256 /* Ctrl */ | 191 /* FORWARDSLASH */, 512 /* Meta */ | 191 /* FORWARDSLASH */, roosterjs_editor_api_1.toggleNumbering),
    createCommand(256 /* Ctrl */ | 1024 /* Shift */ | 190 /* PERIOD */, 512 /* Meta */ | 1024 /* Shift */ | 190 /* PERIOD */, function (editor) { return roosterjs_editor_api_1.changeFontSize(editor, 0 /* Increase */); }),
    createCommand(256 /* Ctrl */ | 1024 /* Shift */ | 188 /* COMMA */, 512 /* Meta */ | 1024 /* Shift */ | 188 /* COMMA */, function (editor) { return roosterjs_editor_api_1.changeFontSize(editor, 1 /* Decrease */); }),
];
/**
 * DefaultShortcut edit feature, provides shortcuts for the following features:
 * Ctrl/Meta+B: toggle bold style
 * Ctrl/Meta+I: toggle italic style
 * Ctrl/Meta+U: toggle underline style
 * Ctrl/Meta+Z: undo
 * Ctrl+Y/Meta+Shift+Z: redo
 * Ctrl/Meta+PERIOD: toggle bullet list
 * Ctrl/Meta+/: toggle numbering list
 * Ctrl/Meta+Shift+>: increase font size
 * Ctrl/Meta+Shift+<: decrease font size
 */
exports.DefaultShortcut = {
    allowFunctionKeys: true,
    keys: [66 /* B */, 73 /* I */, 85 /* U */, 89 /* Y */, 90 /* Z */, 188 /* COMMA */, 190 /* PERIOD */, 191 /* FORWARDSLASH */],
    shouldHandleEvent: cacheGetCommand,
    handleEvent: function (event, editor) {
        var command = cacheGetCommand(event);
        if (command) {
            command.action(editor);
            event.rawEvent.preventDefault();
            event.rawEvent.stopPropagation();
        }
    },
};
function cacheGetCommand(event) {
    return roosterjs_editor_core_1.cacheGetEventData(event, 'DEFAULT_SHORT_COMMAND', function () {
        var e = event.rawEvent;
        var key = 
        // Need to check ALT key to be false since in some language (e.g. Polski) uses AltGr to input some special charactors
        // In that case, ctrlKey and altKey are both true in Edge, but we should not trigger any shortcut function here
        event.eventType == 0 /* KeyDown */ && !e.altKey
            ? e.which |
                (e.metaKey && 512 /* Meta */) |
                (e.shiftKey && 1024 /* Shift */) |
                (e.ctrlKey && 256 /* Ctrl */)
            : 0;
        return key && commands.filter(function (cmd) { return (roosterjs_editor_dom_1.Browser.isMac ? cmd.macKey : cmd.winKey) == key; })[0];
    });
}
//# sourceMappingURL=shortcutFeatures.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/tableFeatures.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/tableFeatures.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_editor_api_1 = __webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js");
/**
 * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table
 */
exports.TabInTable = {
    keys: [9 /* TAB */],
    shouldHandleEvent: cacheGetTableCell,
    handleEvent: function (event, editor) {
        var shift = event.rawEvent.shiftKey;
        var td = cacheGetTableCell(event, editor);
        for (var vtable = new roosterjs_editor_dom_1.VTable(td), step = shift ? -1 : 1, row = vtable.row, col = vtable.col + step;; col += step) {
            if (col < 0 || col >= vtable.cells[row].length) {
                row += step;
                if (row < 0) {
                    editor.select(vtable.table, -2 /* Before */);
                    break;
                }
                else if (row >= vtable.cells.length) {
                    roosterjs_editor_api_1.editTable(editor, 1 /* InsertBelow */);
                    break;
                }
                col = shift ? vtable.cells[row].length - 1 : 0;
            }
            var cell = vtable.getCell(row, col);
            if (cell.td) {
                editor.select(cell.td, 0 /* Begin */);
                break;
            }
        }
        event.rawEvent.preventDefault();
    },
};
/**
 * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN
 * in table
 */
exports.UpDownInTable = {
    keys: [38 /* UP */, 40 /* DOWN */],
    shouldHandleEvent: cacheGetTableCell,
    handleEvent: function (event, editor) {
        var td = cacheGetTableCell(event, editor);
        var vtable = new roosterjs_editor_dom_1.VTable(td);
        var isUp = event.rawEvent.which == 38 /* UP */;
        var step = isUp ? -1 : 1;
        var targetTd = null;
        var hasShiftKey = event.rawEvent.shiftKey;
        var _a = editor.getSelection(), anchorNode = _a.anchorNode, anchorOffset = _a.anchorOffset;
        for (var row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {
            var cell = vtable.getCell(row, vtable.col);
            if (cell.td && cell.td != td) {
                targetTd = cell.td;
                break;
            }
        }
        editor.runAsync(function () {
            var newContainer = editor.getElementAtCursor();
            if (roosterjs_editor_dom_1.contains(vtable.table, newContainer) &&
                !roosterjs_editor_dom_1.contains(td, newContainer, true /*treatSameNodeAsContain*/)) {
                var newPos = targetTd
                    ? new roosterjs_editor_dom_1.Position(targetTd, 0 /* Begin */)
                    : new roosterjs_editor_dom_1.Position(vtable.table, isUp ? -2 /* Before */ : -3 /* After */);
                if (hasShiftKey) {
                    newPos =
                        newPos.node.nodeType == 1 /* Element */ && roosterjs_editor_dom_1.isVoidHtmlElement(newPos.node)
                            ? new roosterjs_editor_dom_1.Position(newPos.node, newPos.isAtEnd ? -3 /* After */ : -2 /* Before */)
                            : newPos;
                    editor
                        .getSelection()
                        .setBaseAndExtent(anchorNode, anchorOffset, newPos.node, newPos.offset);
                }
                else {
                    editor.select(newPos);
                }
            }
        });
    },
};
function cacheGetTableCell(event, editor) {
    return roosterjs_editor_core_1.cacheGetEventData(event, 'TABLECELL_FOR_TABLE_FEATURES', function () {
        var pos = editor.getFocusedPosition();
        var firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);
        return (firstTd && (roosterjs_editor_dom_1.getTagOfNode(firstTd) == 'LI' ? null : firstTd));
    });
}
//# sourceMappingURL=tableFeatures.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ContentEdit_1 = __webpack_require__(/*! ./ContentEdit */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEdit.js");
exports.ContentEdit = ContentEdit_1.default;
var ContentEditFeatures_1 = __webpack_require__(/*! ./ContentEditFeatures */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEditFeatures.js");
exports.getDefaultContentEditFeatures = ContentEditFeatures_1.getDefaultContentEditFeatures;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/CustomReplace/CustomReplace.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/CustomReplace/CustomReplace.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var makeReplacement = function (sourceString, replacementHTML, matchSourceCaseSensitive) { return ({ sourceString: sourceString, replacementHTML: replacementHTML, matchSourceCaseSensitive: matchSourceCaseSensitive }); };
var defaultReplacements = [
    makeReplacement(':)', '', true),
    makeReplacement(';)', '', true),
    makeReplacement(':O', '', true),
    makeReplacement(':o', '', true),
    makeReplacement('<3', '', true),
];
/**
 * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the
 * content edit feature
 */
var CustomReplacePlugin = /** @class */ (function () {
    /**
     * Create instance of CustomReplace plugin
     * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied
     */
    function CustomReplacePlugin(replacements) {
        if (replacements === void 0) { replacements = defaultReplacements; }
        this.updateReplacements(replacements);
    }
    /**
     * Set the replacements that this plugin is looking for.
     * @param newReplacements new set of replacements for this plugin
     */
    CustomReplacePlugin.prototype.updateReplacements = function (newReplacements) {
        this.replacements = newReplacements;
        this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);
        this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);
    };
    /**
     * Get a friendly name of  this plugin
     */
    CustomReplacePlugin.prototype.getName = function () {
        return 'CustomReplace';
    };
    /**
     * Initialize this plugin
     * @param editor The editor instance
     */
    CustomReplacePlugin.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    /**
     * Dispose this plugin
     */
    CustomReplacePlugin.prototype.dispose = function () {
        this.editor = null;
    };
    CustomReplacePlugin.prototype.onPluginEvent = function (event) {
        var _this = this;
        if (this.editor.isInIME() || event.eventType != 12 /* Input */) {
            return;
        }
        // Exit early on input events that do not insert a replacement's final character.
        if (!event.rawEvent.data || !this.replacementEndCharacters.has(event.rawEvent.data)) {
            return;
        }
        // Get the matching replacement
        var range = this.editor.getSelectionRange();
        if (range == null) {
            return;
        }
        var searcher = roosterjs_editor_core_1.cacheGetContentSearcher(event, this.editor);
        var stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);
        var replacement = this.getMatchingReplacement(stringToSearch);
        if (replacement == null) {
            return;
        }
        // Reconstruct a selection of the text on the document that matches the
        // replacement we selected.
        var matchingText = searcher.getSubStringBefore(replacement.sourceString.length);
        var matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);
        // parse the html string off the dom and inline the resulting element.
        var document = this.editor.getDocument();
        var parsingSpan = document.createElement('span');
        parsingSpan.innerHTML = replacement.replacementHTML;
        var nodeToInsert = parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;
        // Switch the node for the selection range
        this.editor.performAutoComplete(function () {
            matchingRange.deleteContents();
            matchingRange.insertNode(nodeToInsert);
            _this.editor.select(nodeToInsert, -1 /* End */);
        });
    };
    CustomReplacePlugin.prototype.getMatchingReplacement = function (stringToSearch) {
        if (stringToSearch.length == 0) {
            return null;
        }
        var lowerCaseStringToSearch = stringToSearch.toLocaleLowerCase();
        for (var _i = 0, _a = this.replacements; _i < _a.length; _i++) {
            var replacement = _a[_i];
            var _b = replacement.matchSourceCaseSensitive
                ? [stringToSearch, replacement.sourceString]
                : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()], sourceMatch = _b[0], replacementMatch = _b[1];
            if (sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==
                replacementMatch) {
                return replacement;
            }
        }
        return null;
    };
    return CustomReplacePlugin;
}());
exports.default = CustomReplacePlugin;
function getLongestReplacementSourceLength(replacements) {
    return Math.max.apply(null, replacements.map(function (replacement) { return replacement.sourceString.length; }));
}
function getReplacementEndCharacters(replacements) {
    var endChars = new Set();
    for (var _i = 0, replacements_1 = replacements; _i < replacements_1.length; _i++) {
        var replacement = replacements_1[_i];
        var sourceString = replacement.sourceString;
        if (sourceString.length == 0) {
            continue;
        }
        var lastChar = sourceString[sourceString.length - 1];
        if (!replacement.matchSourceCaseSensitive) {
            endChars.add(lastChar.toLocaleLowerCase());
            endChars.add(lastChar.toLocaleUpperCase());
        }
        else {
            endChars.add(lastChar);
        }
    }
    return endChars;
}
//# sourceMappingURL=CustomReplace.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/CustomReplace/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/CustomReplace/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CustomReplace_1 = __webpack_require__(/*! ./CustomReplace */ "./node_modules/roosterjs-editor-plugins/lib/plugins/CustomReplace/CustomReplace.js");
exports.CustomReplace = CustomReplace_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityFeatures.js":
/*!************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityFeatures.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getEntityElement_1 = __webpack_require__(/*! ./getEntityElement */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityElement.js");
var tryTriggerEntityEvent_1 = __webpack_require__(/*! ./tryTriggerEntityEvent */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/tryTriggerEntityEvent.js");
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * @internal
 * A content edit feature to trigger EntityOperation event with operation "Click" when user
 * clicks on a readonly entity.
 */
exports.ClickOnEntityFeature = {
    keys: [13 /* ENTER */],
    shouldHandleEvent: cacheGetReadonlyEntityElement,
    handleEvent: function (event, editor) {
        var entityElement = cacheGetReadonlyEntityElement(event, editor);
        tryTriggerEntityEvent_1.default(editor, entityElement, 1 /* Click */, event.rawEvent);
    },
};
/**
 * @internal
 * A content edit feature to trigger EntityOperation event with operation "Escape" when user
 * presses ESC on a readonly entity.
 */
exports.EscapeFromEntityFeature = {
    keys: [27 /* ESCAPE */],
    shouldHandleEvent: cacheGetReadonlyEntityElement,
    handleEvent: function (event, editor) {
        var entityElement = cacheGetReadonlyEntityElement(event, editor);
        tryTriggerEntityEvent_1.default(editor, entityElement, 3 /* Escape */, event.rawEvent);
    },
};
/**
 * @internal
 * A content edit feature to split current line into two lines at the cursor when user presses
 * ENTER right before a readonly entity.
 * Browser's default behavior will insert an extra BR tag before the entity which causes an extra
 * empty line. So we override the default behavior here.
 */
exports.EnterBeforeReadonlyEntityFeature = {
    keys: [13 /* ENTER */],
    shouldHandleEvent: function (event, editor) {
        return cacheGetNeighborEntityElement(event, editor, true /*isNext*/, false /*collapseOnly*/, true /*checkForSameLine*/);
    },
    handleEvent: function (event, editor) {
        var _a;
        event.rawEvent.preventDefault();
        var range = editor.getSelectionRange();
        var node = roosterjs_editor_dom_1.Position.getEnd(range).normalize().node;
        var br = editor.getDocument().createElement('BR');
        node.parentNode.insertBefore(br, node.nextSibling);
        var block = editor.getBlockElementAtNode(node);
        var newContainer;
        if (block) {
            newContainer = block.collapseToSingleElement();
            (_a = br.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(br);
        }
        editor.getSelectionRange().deleteContents();
        if (newContainer.nextSibling) {
            editor.select(newContainer.nextSibling, 0 /* Begin */);
        }
    },
};
/**
 * @internal
 * A content edit feature to trigger EntityOperation event with operation "RemoveFromEnd" when user
 * press BACKSPACE right after an entity
 */
exports.BackspaceAfterEntityFeature = {
    keys: [8 /* BACKSPACE */],
    shouldHandleEvent: function (event, editor) {
        return cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/);
    },
    handleEvent: function (event, editor) {
        var element = cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/);
        tryTriggerEntityEvent_1.default(editor, element, 5 /* RemoveFromEnd */, event.rawEvent);
    },
};
/**
 * @internal
 * A content edit feature to trigger EntityOperation event with operation "RemoveFromStart" when user
 * press DELETE right after an entity
 */
exports.DeleteBeforeEntityFeature = {
    keys: [46 /* DELETE */],
    shouldHandleEvent: function (event, editor) {
        return cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/);
    },
    handleEvent: function (event, editor) {
        var element = cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/);
        tryTriggerEntityEvent_1.default(editor, element, 4 /* RemoveFromStart */, event.rawEvent);
    },
};
function cacheGetReadonlyEntityElement(event, editor) {
    return roosterjs_editor_core_1.cacheGetEventData(event, 'READONLY_ENTITY_ELEMENT', function () {
        var entityElement = getEntityElement_1.default(editor, event.rawEvent.target);
        return entityElement && !entityElement.isContentEditable ? entityElement : null;
    });
}
function cacheGetNeighborEntityElement(event, editor, isNext, collapseOnly, checkForSameLine) {
    return roosterjs_editor_core_1.cacheGetEventData(event, 'NEIGHBOR_ENTITY_ELEMENT_' + isNext + '_' + collapseOnly + '_' + !!checkForSameLine, function () {
        var range = editor.getSelectionRange();
        if (collapseOnly && !range.collapsed) {
            return null;
        }
        var pos = roosterjs_editor_dom_1.Position.getEnd(range);
        var lookForPrev = !isNext && (pos.node.nodeType != 3 /* Text */ || pos.offset == 0);
        var lookForNext = isNext && (pos.node.nodeType != 3 /* Text */ || pos.isAtEnd);
        var entityNode = null;
        if (lookForNext || lookForPrev) {
            var traverser = editor.getBodyTraverser(pos.node);
            var sibling = lookForPrev
                ? traverser.getPreviousInlineElement()
                : traverser.getNextInlineElement();
            var node = sibling && sibling.getContainerNode();
            if (checkForSameLine) {
                var block = editor.getBlockElementAtNode(pos.node);
                if (!block || !block.contains(node)) {
                    node = null;
                }
            }
            entityNode = getEntityElement_1.default(editor, node);
        }
        return entityNode;
    });
}
//# sourceMappingURL=EntityFeatures.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityInfo.js":
/*!********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityInfo.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getEntities_1 = __webpack_require__(/*! ./getEntities */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntities.js");
var ENTITY_ID_REGEX = /_\d{1,8}$/;
var ENTITY_INFO_NAME = '_Entity';
var ENTITY_TYPE_PREFIX = '_EType_';
var ENTITY_ID_PREFIX = '_EId_';
var ENTITY_READONLY_PREFIX = '_EReadonly_';
var ENTITY_CSS_REGEX = '^' + ENTITY_INFO_NAME + '$';
var ENTITY_ID_CSS_REGEX = '^' + ENTITY_ID_PREFIX;
var ENTITY_TYPE_CSS_REGEX = '^' + ENTITY_TYPE_PREFIX;
var ENTITY_READONLY_CSS_REGEX = '^' + ENTITY_READONLY_PREFIX;
exports.ALLOWED_CSS_CLASSES = [
    ENTITY_CSS_REGEX,
    ENTITY_ID_CSS_REGEX,
    ENTITY_TYPE_CSS_REGEX,
    ENTITY_READONLY_CSS_REGEX,
];
/**
 * @internal Serialize entity info into a CSS class list string
 * @param editor The editor which contains the entity
 * @param type Type of the entity
 * @param isReadonly Whether the entity is readonly
 * @param originalId (Optional) Existing id of the entity. If this id already exists in the editor, it will be replaced
 * by a new one
 * @param knownIds (Optional) All known entity ids inside this editor. This is a performance optimization when this function
 * will be called multiple times
 */
function serializeEntityInfo(editor, type, isReadonly, originalId, knownIds) {
    if (knownIds === void 0) { knownIds = getAllEntityIds(editor); }
    var id = createEntityId(originalId || type, knownIds);
    return ENTITY_INFO_NAME + " " + ENTITY_TYPE_PREFIX + type + " " + ENTITY_ID_PREFIX + id + " " + ENTITY_READONLY_PREFIX + (isReadonly ? '1' : '0');
}
exports.serializeEntityInfo = serializeEntityInfo;
/**
 * @internal Deserialze entity info string to entity info (type, id, isReadonly)
 * @param entityInfo The entity info string generated from serializeEntityInfo()
 */
function deserialzeEntityInfo(entityInfo) {
    var isEntity = false;
    var type;
    var id = '';
    var isReadonly = false;
    if (entityInfo) {
        entityInfo.split(' ').forEach(function (name) {
            if (name == ENTITY_INFO_NAME) {
                isEntity = true;
            }
            else if (name.indexOf(ENTITY_TYPE_PREFIX) == 0) {
                type = name.substr(ENTITY_TYPE_PREFIX.length);
            }
            else if (name.indexOf(ENTITY_ID_PREFIX) == 0) {
                id = name.substr(ENTITY_ID_PREFIX.length);
            }
            else if (name.indexOf(ENTITY_READONLY_PREFIX) == 0) {
                isReadonly = name.substr(ENTITY_READONLY_PREFIX.length) == '1';
            }
        });
    }
    return isEntity && type
        ? {
            type: type,
            id: id,
            isReadonly: isReadonly,
        }
        : null;
}
exports.deserialzeEntityInfo = deserialzeEntityInfo;
/**
 * @internal Get all known entity ids from an editor
 * @param editor The editor to get entity ids from
 */
function getAllEntityIds(editor) {
    return getEntities_1.default(editor).map(function (e) { return e.id; });
}
exports.getAllEntityIds = getAllEntityIds;
/**
 * @internal Get a selector string for specified entity type and id
 * @param type (Optional) Type of entity
 * @param id (Optional) Id of entity
 */
function getEntitySelector(type, id) {
    var typeSelector = type ? "." + ENTITY_TYPE_PREFIX + type : '';
    var idSelector = id ? "." + ENTITY_ID_PREFIX + id : '';
    return '.' + ENTITY_INFO_NAME + typeSelector + idSelector;
}
exports.getEntitySelector = getEntitySelector;
function createEntityId(existingIdOrType, knownIds) {
    var match = ENTITY_ID_REGEX.exec(existingIdOrType);
    var baseId = match
        ? existingIdOrType.substr(0, existingIdOrType.length - match[0].length)
        : existingIdOrType;
    var newId = '';
    for (var num = (match && parseInt(match[1])) || 0;; num++) {
        newId = baseId + "_" + num;
        if (knownIds.indexOf(newId) < 0) {
            knownIds.push(newId);
            break;
        }
    }
    return newId;
}
//# sourceMappingURL=EntityInfo.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityPlugin.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityPlugin.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getEntityElement_1 = __webpack_require__(/*! ./getEntityElement */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityElement.js");
var getEntityFromElement_1 = __webpack_require__(/*! ./getEntityFromElement */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityFromElement.js");
var tryTriggerEntityEvent_1 = __webpack_require__(/*! ./tryTriggerEntityEvent */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/tryTriggerEntityEvent.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var EntityInfo_1 = __webpack_require__(/*! ./EntityInfo */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityInfo.js");
var EntityFeatures_1 = __webpack_require__(/*! ./EntityFeatures */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityFeatures.js");
/**
 * Entity Plugin helps handle all operations related to an entity and generate entity specified events
 */
var EntityPlugin = /** @class */ (function () {
    function EntityPlugin() {
        var _this = this;
        this.handleContextMenuEvent = function (event) {
            var target = event.target;
            var entityElement = getEntityElement_1.default(_this.editor, target);
            if (entityElement) {
                event.preventDefault();
                tryTriggerEntityEvent_1.default(_this.editor, entityElement, 2 /* ContextMenu */, event);
            }
        };
        this.handleCutEvent = function (event) {
            var range = _this.editor.getSelectionRange();
            if (!range.collapsed) {
                _this.checkRemoveEntityForRange(event);
            }
        };
    }
    EntityPlugin.prototype.getName = function () {
        return 'Entity';
    };
    EntityPlugin.prototype.initialize = function (editor) {
        var _this = this;
        this.editor = editor;
        this.disposer = this.editor.addDomEventHandler({
            contextmenu: this.handleContextMenuEvent,
            cut: this.handleCutEvent,
        });
        this.knownEntityElements = [];
        [
            EntityFeatures_1.ClickOnEntityFeature,
            EntityFeatures_1.EscapeFromEntityFeature,
            EntityFeatures_1.EnterBeforeReadonlyEntityFeature,
            EntityFeatures_1.BackspaceAfterEntityFeature,
            EntityFeatures_1.DeleteBeforeEntityFeature,
        ].forEach(function (feature) { return _this.editor.addContentEditFeature(feature); });
    };
    EntityPlugin.prototype.dispose = function () {
        this.disposer();
        this.disposer = null;
        this.editor = null;
        this.knownEntityElements = null;
    };
    EntityPlugin.prototype.onPluginEvent = function (event) {
        switch (event.eventType) {
            case 4 /* MouseDown */:
                this.handleMouseDownEvent(event.rawEvent);
                break;
            case 5 /* MouseUp */:
                this.handleMouseUpEvent(event.rawEvent);
                break;
            case 0 /* KeyDown */:
                this.handleKeyDownEvent(event.rawEvent);
                break;
            case 9 /* BeforePaste */:
                this.handleBeforePasteEvent(event.fragment, event.sanitizingOption);
                break;
            case 6 /* ContentChanged */:
                this.handleContentChangedEvent(event.source == "SetContent" /* SetContent */);
                break;
            case 10 /* EditorReady */:
                this.handleContentChangedEvent(true /*resetAll*/);
                break;
            case 8 /* ExtractContentWithDom */:
                this.handleExtractContentWithDomEvent(event.clonedRoot);
                break;
        }
    };
    EntityPlugin.prototype.handleMouseDownEvent = function (event) {
        var target = event.target, pageX = event.pageX, pageY = event.pageY;
        var entityElement = getEntityElement_1.default(this.editor, target);
        if (entityElement && !entityElement.isContentEditable) {
            event.preventDefault();
            this.clickingPoint = { pageX: pageX, pageY: pageY };
        }
    };
    EntityPlugin.prototype.handleMouseUpEvent = function (event) {
        var target = event.target, pageX = event.pageX, pageY = event.pageY;
        var entityElement;
        if (this.clickingPoint &&
            this.clickingPoint.pageX == pageX &&
            this.clickingPoint.pageY == pageY &&
            !!(entityElement = getEntityElement_1.default(this.editor, target))) {
            event.preventDefault();
            tryTriggerEntityEvent_1.default(this.editor, entityElement, 1 /* Click */, event);
            workaroundSelectionIssueForIE(this.editor);
        }
        this.clickingPoint = null;
    };
    EntityPlugin.prototype.handleKeyDownEvent = function (event) {
        if (roosterjs_editor_core_1.isCharacterValue(event) ||
            event.which == 8 /* BACKSPACE */ ||
            event.which == 46 /* DELETE */) {
            var range = this.editor.getSelectionRange();
            if (!range.collapsed) {
                this.checkRemoveEntityForRange(event);
            }
        }
    };
    EntityPlugin.prototype.handleBeforePasteEvent = function (fragment, sanitizingOption) {
        var _this = this;
        var range = this.editor.getSelectionRange();
        if (!range.collapsed) {
            this.checkRemoveEntityForRange(null /*rawEvent*/);
        }
        var entityElements = roosterjs_editor_dom_1.toArray(fragment.querySelectorAll(EntityInfo_1.getEntitySelector()));
        if (entityElements.length > 0) {
            var knownIds_1 = EntityInfo_1.getAllEntityIds(this.editor);
            entityElements.forEach(function (element) {
                var entity = getEntityFromElement_1.default(element);
                if (entity) {
                    element.className = EntityInfo_1.serializeEntityInfo(_this.editor, entity.type, entity.isReadonly, entity.id, knownIds_1);
                }
            });
            Array.prototype.push.apply(sanitizingOption.additionalAllowedCssClasses, EntityInfo_1.ALLOWED_CSS_CLASSES);
        }
    };
    EntityPlugin.prototype.handleContentChangedEvent = function (resetAll) {
        var _this = this;
        this.knownEntityElements = resetAll
            ? []
            : this.knownEntityElements.filter(function (node) { return _this.editor.contains(node); });
        this.editor.queryElements(EntityInfo_1.getEntitySelector(), function (element) {
            if (_this.knownEntityElements.indexOf(element) < 0) {
                _this.knownEntityElements.push(element);
                tryTriggerEntityEvent_1.default(_this.editor, element, 0 /* NewEntity */);
            }
        });
    };
    EntityPlugin.prototype.handleExtractContentWithDomEvent = function (root) {
        var _this = this;
        roosterjs_editor_dom_1.toArray(root.querySelectorAll(EntityInfo_1.getEntitySelector())).forEach(function (element) {
            element.removeAttribute('contentEditable');
            tryTriggerEntityEvent_1.default(_this.editor, element, 8 /* ReplaceTemporaryContent */);
        });
    };
    EntityPlugin.prototype.checkRemoveEntityForRange = function (event) {
        var _this = this;
        var editableEntityElements = [];
        var selector = EntityInfo_1.getEntitySelector();
        this.editor.queryElements(selector, 1 /* OnSelection */, function (element) {
            if (element.isContentEditable) {
                editableEntityElements.push(element);
            }
            else {
                tryTriggerEntityEvent_1.default(_this.editor, element, 6 /* Overwrite */, event);
            }
        });
        // For editable entities, we need to check if it is fully or partially covered by current selection,
        // and trigger different events;
        if (editableEntityElements.length > 0) {
            var inSelectionEntityElements_1 = this.editor.queryElements(selector, 2 /* InSelection */);
            editableEntityElements.forEach(function (element) {
                var isFullyCovered = inSelectionEntityElements_1.indexOf(element) >= 0;
                tryTriggerEntityEvent_1.default(_this.editor, element, isFullyCovered ? 6 /* Overwrite */ : 7 /* PartialOverwrite */, event);
            });
        }
    };
    return EntityPlugin;
}());
exports.default = EntityPlugin;
/**
 * IE will show a resize border around the readonly content within content editable DIV
 * This is a workaround to remove it by temporarily move focus out of editor
 */
var workaroundSelectionIssueForIE = roosterjs_editor_dom_1.Browser.isIE
    ? function (editor) {
        editor.runAsync(function () {
            var workaroundButton = editor.getCustomData('ENTITY_IE_FOCUS_BUTTON', function () {
                var button = editor.getDocument().createElement('button');
                button.style.overflow = 'hidden';
                button.style.position = 'fixed';
                button.style.width = '0';
                button.style.height = '0';
                button.style.left = '0';
                button.style.top = '-1000px';
                button.onblur = function () {
                    button.style.display = 'none';
                };
                editor.insertNode(button, {
                    position: 4 /* Outside */,
                });
                return button;
            });
            workaroundButton.style.display = '';
            var range = editor.getDocument().createRange();
            range.setStart(workaroundButton, 0);
            try {
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(range);
            }
            catch (_a) { }
        });
    }
    : function () { };
//# sourceMappingURL=EntityPlugin.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/createEntityWrapper.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/createEntityWrapper.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EntityInfo_1 = __webpack_require__(/*! ./EntityInfo */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityInfo.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Wrap a node and become an entity element
 * @param editor The editor to insert entity into.
 * @param type Type of the entity
 * @param contentNode Root element of the entity
 * @param isBlock Whether the entity will be shown as a block
 * @param isReadonly Whether the entity will be a readonly entity
 */
function createEntityWrapper(editor, type, contentNode, isBlock, isReadonly) {
    var wrapper = roosterjs_editor_dom_1.wrap(contentNode, isBlock ? 'DIV' : 'SPAN');
    wrapper.className = EntityInfo_1.serializeEntityInfo(editor, type, isReadonly);
    // For inline & readonly entity, we need to set display to "inline-block" otherwise
    // there will be some weird behavior when move cursor around the entity node.
    // And we should only do this for readonly entity since "inline-block" has some side effect
    // in IE that there will be a resize border around the inline-block element. We made some
    // workaround for readonly entity for this issue but for editable entity, keep it as "inline"
    // will just work fine.
    if (!isBlock && isReadonly) {
        wrapper.style.display = 'inline-block';
    }
    return wrapper;
}
exports.default = createEntityWrapper;
//# sourceMappingURL=createEntityWrapper.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntities.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntities.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getEntityFromElement_1 = __webpack_require__(/*! ./getEntityFromElement */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityFromElement.js");
var EntityInfo_1 = __webpack_require__(/*! ./EntityInfo */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityInfo.js");
/**
 * Get all entities with given entity type and id from an editor
 * @param editor The editor to get entity from
 * @param type (Optional) Type of the entity. If not specified, it will return all entities from this editor
 * @param id (Optional) Id of the entity. If not specified, it will return all entities of the given type
 */
function getEntities(editor, type, id) {
    var selector = EntityInfo_1.getEntitySelector(type, id);
    var nodes = editor.queryElements(selector);
    var allEntities = nodes.map(function (node) { return getEntityFromElement_1.default(node); });
    return allEntities.filter(function (e) { return !!e; });
}
exports.default = getEntities;
//# sourceMappingURL=getEntities.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityElement.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityElement.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EntityInfo_1 = __webpack_require__(/*! ./EntityInfo */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityInfo.js");
/**
 * Get the entity element from a child (or the element itself) of an entity.
 * If the given node is not part of an entity, it will return null
 * @param editor The editor to get entity from
 * @param node The child node
 */
function getEntityElement(editor, node) {
    return (node && editor.getElementAtCursor(EntityInfo_1.getEntitySelector(), node)) || null;
}
exports.default = getEntityElement;
//# sourceMappingURL=getEntityElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityFromElement.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityFromElement.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var EntityInfo_1 = __webpack_require__(/*! ./EntityInfo */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityInfo.js");
/**
 * Get Entity object from an entity root element
 * @param element The entity root element. If this element is not an entity root element,
 * it will return null
 */
function getEntityFromElement(element) {
    var entityInfo = EntityInfo_1.deserialzeEntityInfo(element === null || element === void 0 ? void 0 : element.className);
    return entityInfo
        ? __assign({ contentNode: element }, entityInfo) : null;
}
exports.default = getEntityFromElement;
//# sourceMappingURL=getEntityFromElement.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EntityPlugin_1 = __webpack_require__(/*! ./EntityPlugin */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/EntityPlugin.js");
exports.EntityPlugin = EntityPlugin_1.default;
var insertEntity_1 = __webpack_require__(/*! ./insertEntity */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/insertEntity.js");
exports.insertEntity = insertEntity_1.default;
var getEntityFromElement_1 = __webpack_require__(/*! ./getEntityFromElement */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityFromElement.js");
exports.getEntityFromElement = getEntityFromElement_1.default;
var getEntities_1 = __webpack_require__(/*! ./getEntities */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntities.js");
exports.getEntities = getEntities_1.default;
var getEntityElement_1 = __webpack_require__(/*! ./getEntityElement */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityElement.js");
exports.getEntityElement = getEntityElement_1.default;
var createEntityWrapper_1 = __webpack_require__(/*! ./createEntityWrapper */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/createEntityWrapper.js");
exports.createEntityWrapper = createEntityWrapper_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/insertEntity.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/insertEntity.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var createEntityWrapper_1 = __webpack_require__(/*! ./createEntityWrapper */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/createEntityWrapper.js");
var getEntityElement_1 = __webpack_require__(/*! ./getEntityElement */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityElement.js");
var getEntityFromElement_1 = __webpack_require__(/*! ./getEntityFromElement */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityFromElement.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * Insert an entity into editor.
 * @param editor The editor to insert entity into.
 * @param type Type of the entity
 * @param contentNode Root element of the entity
 * @param isBlock Whether the entity will be shown as a block
 * @param isReadonly Whether the entity will be a readonly entity
 * @param position (Optional) The position to insert into. If not specified, current position will be used.
 * If isBlock is true, entity will be insert below this position
 */
function insertEntity(editor, type, contentNode, isBlock, isReadonly, position) {
    var wrapper = createEntityWrapper_1.default(editor, type, contentNode, isBlock, isReadonly);
    var currentRange;
    if (position) {
        currentRange = editor.getSelectionRange();
        var node = position.normalize().node;
        var existingEntity = getEntityElement_1.default(editor, node);
        // Do not insert entity into another entity
        if (existingEntity) {
            position = new roosterjs_editor_dom_1.Position(existingEntity, -3 /* After */);
        }
        editor.select(position);
    }
    editor.insertNode(wrapper, {
        updateCursor: false,
        insertOnNewLine: isBlock,
        replaceSelection: true,
        position: 3 /* SelectionStart */,
    });
    if (isBlock) {
        // Insert an extra empty line for block entity to make sure
        // user can still put cursor below the entity.
        var br = editor.getDocument().createElement('BR');
        wrapper.parentNode.insertBefore(br, wrapper.nextSibling);
    }
    if (currentRange) {
        editor.select(currentRange);
    }
    else if (!isBlock) {
        editor.select(wrapper, -3 /* After */);
    }
    var entity = getEntityFromElement_1.default(wrapper);
    editor.triggerContentChangedEvent("InsertEntity" /* InsertEntity */, entity);
    return entity;
}
exports.default = insertEntity;
//# sourceMappingURL=insertEntity.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/tryTriggerEntityEvent.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/tryTriggerEntityEvent.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var getEntityFromElement_1 = __webpack_require__(/*! ./getEntityFromElement */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Entity/getEntityFromElement.js");
/**
 * @internal
 * Try to trigger an EntityOperation event with a given element. An event will only be
 * triggered when the specified is an element root element.
 * @param editor The editor which contains the entity
 * @param element The root element of the entity
 * @param operation Operation of the EntityOperation event
 * @param rawEvent (Optional) Original UI event which causes this event
 */
function tryTriggerEntityEvent(editor, element, operation, rawEvent) {
    var entity = element && getEntityFromElement_1.default(element);
    if (entity) {
        if (operation == 0 /* NewEntity */ && entity.isReadonly) {
            element.contentEditable = 'false';
        }
        editor.triggerPluginEvent(16 /* EntityOperation */, {
            operation: operation,
            rawEvent: rawEvent,
            entity: entity,
        });
    }
}
exports.default = tryTriggerEntityEvent;
//# sourceMappingURL=tryTriggerEntityEvent.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
/**
 * An editor plugin that show a tooltip for existing link
 */
var HyperLink = /** @class */ (function () {
    /**
     * Create a new instance of HyperLink class
     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.
     * Default value is to return the href itself. If null, there will be no tooltip text.
     * @param target (Optional) Target window name for hyperlink. If null, will use "_blank"
     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)
     */
    function HyperLink(getTooltipCallback, target, onLinkClick) {
        var _this = this;
        if (getTooltipCallback === void 0) { getTooltipCallback = function (href) { return href; }; }
        this.getTooltipCallback = getTooltipCallback;
        this.target = target;
        this.onLinkClick = onLinkClick;
        this.onMouse = function (e) {
            var a = _this.editor.getElementAtCursor('a[href]', e.target);
            var href = _this.tryGetHref(a);
            if (href) {
                _this.editor.setEditorDomAttribute('title', e.type == 'mouseover' ? _this.getTooltipCallback(href, a) : null);
            }
        };
    }
    /**
     * Get a friendly name of  this plugin
     */
    HyperLink.prototype.getName = function () {
        return 'Hyperlink';
    };
    /**
     * Initialize this plugin
     * @param editor The editor instance
     */
    HyperLink.prototype.initialize = function (editor) {
        this.editor = editor;
        this.disposer =
            this.getTooltipCallback &&
                editor.addDomEventHandler({ mouseover: this.onMouse, mouseout: this.onMouse });
    };
    /**
     * Dispose this plugin
     */
    HyperLink.prototype.dispose = function () {
        if (this.disposer) {
            this.disposer();
            this.disposer = null;
        }
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    HyperLink.prototype.onPluginEvent = function (event) {
        if (event.eventType == 5 /* MouseUp */) {
            var anchor = this.editor.getElementAtCursor('A', event.rawEvent.srcElement);
            if (anchor) {
                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {
                    return;
                }
                var href = void 0;
                if (!roosterjs_editor_dom_1.Browser.isFirefox &&
                    (href = this.tryGetHref(anchor)) &&
                    roosterjs_editor_core_1.isCtrlOrMetaPressed(event.rawEvent) &&
                    event.rawEvent.button === 0) {
                    try {
                        var target = this.target || '_blank';
                        var window_1 = this.editor.getDocument().defaultView;
                        window_1.open(href, target);
                    }
                    catch (_a) { }
                }
            }
        }
    };
    /**
     * Try get href from an anchor element
     * The reason this is put in a try-catch is that
     * it has been seen that accessing href may throw an exception, in particular on IE/Edge
     */
    HyperLink.prototype.tryGetHref = function (anchor) {
        try {
            return anchor ? anchor.href : null;
        }
        catch (_a) { }
    };
    return HyperLink;
}());
exports.default = HyperLink;
//# sourceMappingURL=HyperLink.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/HyperLink/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/HyperLink/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var HyperLink_1 = __webpack_require__(/*! ./HyperLink */ "./node_modules/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.js");
exports.HyperLink = HyperLink_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ImageResize/ImageResize.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ImageResize/ImageResize.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var BEGIN_TAG = 'RoosterJsImageResizingBegin';
var END_TAG = 'RoosterJsImageResizingEnd';
var EXTRACT_HTML_REGEX = new RegExp("<!--" + BEGIN_TAG + "-->[\\s\\S]*(<img\\s[^>]+>)[\\s\\S]*<!--" + END_TAG + "-->", 'gim');
var DELETE_KEYCODE = 46;
var BACKSPACE_KEYCODE = 8;
var SHIFT_KEYCODE = 16;
var CTRL_KEYCODE = 17;
var ALT_KEYCODE = 18;
/**
 * ImageResize plugin provides the ability to resize an inline image in editor
 */
var ImageResize = /** @class */ (function () {
    /**
     * Create a new instance of ImageResize
     * @param minWidth Minimum width of image when resize in pixel, default value is 10
     * @param minHeight Minimum height of image when resize in pixel, default value is 10
     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C
     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false
     * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note
     * that the tag must be IMG regardless what the selector is
     */
    function ImageResize(minWidth, minHeight, selectionBorderColor, forcePreserveRatio, resizableImageSelector) {
        var _this = this;
        if (minWidth === void 0) { minWidth = 10; }
        if (minHeight === void 0) { minHeight = 10; }
        if (selectionBorderColor === void 0) { selectionBorderColor = '#DB626C'; }
        if (forcePreserveRatio === void 0) { forcePreserveRatio = false; }
        if (resizableImageSelector === void 0) { resizableImageSelector = 'img'; }
        this.minWidth = minWidth;
        this.minHeight = minHeight;
        this.selectionBorderColor = selectionBorderColor;
        this.forcePreserveRatio = forcePreserveRatio;
        this.resizableImageSelector = resizableImageSelector;
        this.startResize = function (e) {
            var img = _this.getSelectedImage();
            if (_this.editor && img) {
                _this.startPageX = e.pageX;
                _this.startPageY = e.pageY;
                _this.startWidth = img.clientWidth;
                _this.startHeight = img.clientHeight;
                _this.editor.addUndoSnapshot();
                var document_1 = _this.editor.getDocument();
                document_1.addEventListener('mousemove', _this.doResize, true /*useCapture*/);
                document_1.addEventListener('mouseup', _this.finishResize, true /*useCapture*/);
                _this.direction = (e.srcElement || e.target).style.cursor;
            }
            _this.stopEvent(e);
        };
        this.doResize = function (e) {
            var img = _this.getSelectedImage();
            if (_this.editor && img) {
                var widthChange = e.pageX - _this.startPageX;
                var heightChange = e.pageY - _this.startPageY;
                var newWidth = Math.max(_this.startWidth + (_this.isWest(_this.direction) ? -widthChange : widthChange), _this.minWidth);
                var newHeight = Math.max(_this.startHeight + (_this.isNorth(_this.direction) ? -heightChange : heightChange), _this.minHeight);
                if (_this.forcePreserveRatio || e.shiftKey) {
                    var ratio = _this.startWidth > 0 && _this.startHeight > 0
                        ? (_this.startWidth * 1.0) / _this.startHeight
                        : 0;
                    if (ratio > 0) {
                        if (newWidth < newHeight * ratio) {
                            newWidth = newHeight * ratio;
                        }
                        else {
                            newHeight = newWidth / ratio;
                        }
                    }
                }
                img.style.width = newWidth + 'px';
                img.style.height = newHeight + 'px';
                // double check
                if (_this.forcePreserveRatio || e.shiftKey) {
                    var ratio = _this.startWidth > 0 && _this.startHeight > 0
                        ? (_this.startWidth * 1.0) / _this.startHeight
                        : 0;
                    var clientWidth = Math.floor(img.clientWidth);
                    var clientHeight = Math.floor(img.clientHeight);
                    newWidth = Math.floor(newWidth);
                    newHeight = Math.floor(newHeight);
                    if (clientHeight !== newHeight || clientWidth !== newWidth) {
                        if (clientHeight < newHeight) {
                            newWidth = clientHeight * ratio;
                        }
                        else {
                            newHeight = clientWidth / ratio;
                        }
                        img.style.width = newWidth + 'px';
                        img.style.height = newHeight + 'px';
                    }
                }
            }
            _this.stopEvent(e);
        };
        this.finishResize = function (e) {
            var img = _this.getSelectedImage();
            if (_this.editor && img) {
                var document_2 = _this.editor.getDocument();
                document_2.removeEventListener('mousemove', _this.doResize, true /*useCapture*/);
                document_2.removeEventListener('mouseup', _this.finishResize, true /*useCapture*/);
                var width = img.clientWidth;
                var height = img.clientHeight;
                img.style.width = width + 'px';
                img.style.height = height + 'px';
                img.width = width;
                img.height = height;
                _this.resizeDiv.style.width = '';
                _this.resizeDiv.style.height = '';
            }
            _this.direction = null;
            _this.editor.addUndoSnapshot();
            _this.editor.triggerContentChangedEvent("ImageResize" /* ImageResize */);
            _this.stopEvent(e);
        };
        this.stopEvent = function (e) {
            e.stopPropagation();
            e.preventDefault();
        };
        this.removeResizeDivIfAny = function (img) {
            var div = img && img.parentNode;
            var previous = div && div.previousSibling;
            var next = div && div.nextSibling;
            if (previous &&
                previous.nodeType == 8 /* Comment */ &&
                previous.nodeValue == BEGIN_TAG &&
                next &&
                next.nodeType == 8 /* Comment */ &&
                next.nodeValue == END_TAG) {
                div.parentNode.insertBefore(img, div);
                _this.removeResizeDiv(div);
            }
        };
        this.onBlur = function (e) {
            _this.hideResizeHandle();
        };
        this.onDragStart = function (e) {
            if ((e.srcElement || e.target) == _this.getSelectedImage()) {
                _this.hideResizeHandle(true);
            }
        };
    }
    /**
     * Get a friendly name of  this plugin
     */
    ImageResize.prototype.getName = function () {
        return 'ImageResize';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    ImageResize.prototype.initialize = function (editor) {
        this.editor = editor;
        this.disposer = editor.addDomEventHandler({
            dragstart: this.onDragStart,
            blur: this.onBlur,
        });
    };
    /**
     * Dispose this plugin
     */
    ImageResize.prototype.dispose = function () {
        if (this.resizeDiv) {
            this.hideResizeHandle();
        }
        this.disposer();
        this.disposer = null;
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    ImageResize.prototype.onPluginEvent = function (e) {
        var _this = this;
        if (e.eventType == 4 /* MouseDown */) {
            var event_1 = e.rawEvent;
            var target = (event_1.srcElement || event_1.target);
            if (roosterjs_editor_dom_1.getTagOfNode(target) == 'IMG') {
                var parent_1 = target.parentNode;
                var elements = parent_1
                    ? roosterjs_editor_dom_1.toArray(parent_1.querySelectorAll(this.resizableImageSelector))
                    : [];
                if (elements.indexOf(target) < 0) {
                    return;
                }
                target.contentEditable = 'false';
                var currentImg = this.getSelectedImage();
                if (currentImg && currentImg != target) {
                    this.hideResizeHandle();
                }
                if (!this.resizeDiv) {
                    this.showResizeHandle(target);
                }
            }
            else if (this.resizeDiv && !roosterjs_editor_dom_1.contains(this.resizeDiv, target)) {
                this.hideResizeHandle();
            }
        }
        else if (e.eventType == 0 /* KeyDown */ && this.resizeDiv) {
            var event_2 = e.rawEvent;
            if (event_2.which == DELETE_KEYCODE || event_2.which == BACKSPACE_KEYCODE) {
                this.editor.addUndoSnapshot(function () {
                    _this.removeResizeDiv(_this.resizeDiv);
                });
                this.resizeDiv = null;
                event_2.preventDefault();
                this.resizeDiv = null;
            }
            else if (event_2.which != SHIFT_KEYCODE &&
                event_2.which != CTRL_KEYCODE &&
                event_2.which != ALT_KEYCODE) {
                this.hideResizeHandle(true /*selectImage*/);
            }
        }
        else if (e.eventType == 6 /* ContentChanged */ &&
            e.source != "ImageResize" /* ImageResize */) {
            this.editor.queryElements('img', this.removeResizeDivIfAny);
            this.resizeDiv = null;
        }
        else if (e.eventType == 7 /* ExtractContent */) {
            var event_3 = e;
            event_3.content = this.extractHtml(event_3.content);
        }
    };
    /**
     * Select a given IMG element, show the resize handle
     * @param img The IMG element to select
     */
    ImageResize.prototype.showResizeHandle = function (img) {
        this.resizeDiv = this.createResizeDiv(img);
        img.contentEditable = 'false';
        this.editor.select(this.resizeDiv, -3 /* After */);
    };
    /**
     * Hide resize handle of current selected image
     * @param selectImageAfterUnSelect Optional, when set to true, select the image element after hide the resize handle
     */
    ImageResize.prototype.hideResizeHandle = function (selectImageAfterUnSelect) {
        var img = this.getSelectedImage();
        var parent = this.resizeDiv && this.resizeDiv.parentNode;
        if (parent) {
            if (img) {
                // Reset the transform of the image before the container is removed, so the rotation isn't reset
                img.style.transform = this.resizeDiv.style.transform;
                img.removeAttribute('contentEditable');
                var referenceNode = this.resizeDiv.previousSibling &&
                    this.resizeDiv.previousSibling.nodeType == 8 /* Comment */
                    ? this.resizeDiv.previousSibling
                    : this.resizeDiv;
                parent.insertBefore(img, referenceNode);
                if (selectImageAfterUnSelect) {
                    this.editor.select(img);
                }
                else {
                    this.editor.select(img, -3 /* After */);
                }
            }
            this.removeResizeDiv(this.resizeDiv);
            this.resizeDiv = null;
        }
    };
    ImageResize.prototype.createResizeDiv = function (target) {
        var _this = this;
        var document = this.editor.getDocument();
        var resizeDiv = document.createElement('DIV');
        var parent = target.parentNode;
        parent.insertBefore(resizeDiv, target);
        parent.insertBefore(document.createComment(BEGIN_TAG), resizeDiv);
        parent.insertBefore(document.createComment(END_TAG), resizeDiv.nextSibling);
        resizeDiv.style.position = 'relative';
        resizeDiv.style.display = 'inline-flex';
        resizeDiv.contentEditable = 'false';
        resizeDiv.addEventListener('click', this.stopEvent);
        resizeDiv.appendChild(target);
        ['nw', 'ne', 'sw', 'se'].forEach(function (pos) {
            var div = document.createElement('DIV');
            resizeDiv.appendChild(div);
            div.style.position = 'absolute';
            div.style.width = '7px';
            div.style.height = '7px';
            div.style.backgroundColor = _this.selectionBorderColor;
            div.style.cursor = pos + '-resize';
            if (_this.isNorth(pos)) {
                div.style.top = '-3px';
            }
            else {
                div.style.bottom = '-3px';
            }
            if (_this.isWest(pos)) {
                div.style.left = '-3px';
            }
            else {
                div.style.right = '-3px';
            }
            div.addEventListener('mousedown', _this.startResize);
        });
        var div = document.createElement('DIV');
        resizeDiv.appendChild(div);
        div.style.position = 'absolute';
        div.style.top = '0';
        div.style.left = '0';
        div.style.right = '0';
        div.style.bottom = '0';
        div.style.border = 'solid 1px ' + this.selectionBorderColor;
        div.style.pointerEvents = 'none';
        // If the resizeDiv's image has a transform, apply it to the container
        var selectedImage = this.getSelectedImage(resizeDiv);
        if (selectedImage && selectedImage.style && selectedImage.style.transform) {
            resizeDiv.style.transform = selectedImage.style.transform;
            selectedImage.style.transform = '';
        }
        return resizeDiv;
    };
    ImageResize.prototype.removeResizeDiv = function (resizeDiv) {
        var _this = this;
        if (this.editor && this.editor.contains(resizeDiv)) {
            [resizeDiv.previousSibling, resizeDiv.nextSibling].forEach(function (comment) {
                if (comment && comment.nodeType == 8 /* Comment */) {
                    _this.editor.deleteNode(comment);
                }
            });
            this.editor.deleteNode(resizeDiv);
        }
    };
    ImageResize.prototype.extractHtml = function (html) {
        return html.replace(EXTRACT_HTML_REGEX, function () {
            var groups = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                groups[_i] = arguments[_i];
            }
            return groups[1].replace(/(\s*contenteditable="false"(\/?>)|contenteditable="false"\s*)/im, '$2');
        });
    };
    ImageResize.prototype.getSelectedImage = function (div) {
        var divWithImage = div || this.resizeDiv;
        return divWithImage ? divWithImage.getElementsByTagName('IMG')[0] : null;
    };
    ImageResize.prototype.isNorth = function (direction) {
        return direction && direction.substr(0, 1) == 'n';
    };
    ImageResize.prototype.isWest = function (direction) {
        return direction && direction.substr(1, 1) == 'w';
    };
    return ImageResize;
}());
exports.default = ImageResize;
//# sourceMappingURL=ImageResize.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/ImageResize/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/ImageResize/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ImageResize_1 = __webpack_require__(/*! ./ImageResize */ "./node_modules/roosterjs-editor-plugins/lib/plugins/ImageResize/ImageResize.js");
exports.ImageResize = ImageResize_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/Paste.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/Paste.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var convertPastedContentFromExcel_1 = __webpack_require__(/*! ./excelConverter/convertPastedContentFromExcel */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/excelConverter/convertPastedContentFromExcel.js");
var convertPastedContentFromWord_1 = __webpack_require__(/*! ./wordConverter/convertPastedContentFromWord */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/convertPastedContentFromWord.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var constants_1 = __webpack_require__(/*! ./officeOnlineConverter/constants */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/constants.js");
var convertPastedContentFromWordOnline_1 = __webpack_require__(/*! ./officeOnlineConverter/convertPastedContentFromWordOnline */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.js");
var WORD_ATTRIBUTE_NAME = 'xmlns:w';
var WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';
var EXCEL_ATTRIBUTE_NAME = 'xmlns:x';
var EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';
var EXCEL_ONLINE_ATTRIBUTE_NAME = 'ProgId';
var EXCEL_ONLINE_ATTRIBUTE_VALUE = 'Excel.Sheet';
var GOOGLE_SHEET_NODE_NAME = 'google-sheets-html-origin';
/**
 * Paste plugin, handles BeforePaste event and reformat some special content, including:
 * 1. Content copied from Word
 * 2. Content copied from Excel
 * 3. Content copied from Word Online or Onenote Online
 */
var Paste = /** @class */ (function () {
    /**
     * Create an instance of Paste
     * @param preserved @deprecated Not used. Preserved parameter only used for compatibility with old code
     * @param attributeCallbacks @deprecated A set of callbacks to help handle html attribute during sanitization
     */
    function Paste(preserved, attributeCallbacks) {
        this.attributeCallbacks = attributeCallbacks;
    }
    /**
     * Get a friendly name of  this plugin
     */
    Paste.prototype.getName = function () {
        return 'Paste';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    Paste.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    /**
     * Dispose this plugin
     */
    Paste.prototype.dispose = function () {
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    Paste.prototype.onPluginEvent = function (event) {
        var _this = this;
        if (event.eventType == 9 /* BeforePaste */) {
            var htmlAttributes = event.htmlAttributes, fragment = event.fragment, sanitizingOption_1 = event.sanitizingOption;
            var wacListElements = void 0;
            if (htmlAttributes[WORD_ATTRIBUTE_NAME] == WORD_ATTRIBUTE_VALUE) {
                // Handle HTML copied from Word
                convertPastedContentFromWord_1.default(event);
            }
            else if (htmlAttributes[EXCEL_ATTRIBUTE_NAME] == EXCEL_ATTRIBUTE_VALUE ||
                htmlAttributes[EXCEL_ONLINE_ATTRIBUTE_NAME] == EXCEL_ONLINE_ATTRIBUTE_VALUE) {
                // Handle HTML copied from Excel
                convertPastedContentFromExcel_1.default(event);
            }
            else if ((wacListElements = fragment.querySelectorAll(constants_1.WAC_IDENTIFING_SELECTOR))[0]) {
                // Once it is known that the document is from WAC
                // We need to remove the display property and margin from all the list item
                wacListElements.forEach(function (el) {
                    el.style.display = null;
                    el.style.margin = null;
                });
                // call conversion function if the pasted content is from word online and
                // has list element in the pasted content.
                if (convertPastedContentFromWordOnline_1.isWordOnlineWithList(fragment)) {
                    convertPastedContentFromWordOnline_1.default(fragment);
                }
            }
            else if (fragment.querySelector(GOOGLE_SHEET_NODE_NAME)) {
                sanitizingOption_1.additionalAllowedTags.push(GOOGLE_SHEET_NODE_NAME);
            }
            // TODO: Deprecate attributeCallbacks parameter
            if (this.attributeCallbacks) {
                Object.keys(this.attributeCallbacks).forEach(function (name) {
                    roosterjs_editor_dom_1.chainSanitizerCallback(sanitizingOption_1.attributeCallbacks, name, _this.attributeCallbacks[name]);
                });
            }
        }
    };
    /**
     * @deprecated
     * Paste into editor using passed in clipboardData with original format
     * @param clipboardData The clipboardData to paste
     */
    Paste.prototype.pasteOriginal = function (clipboardData) {
        this.editor.paste(clipboardData);
    };
    /**
     * @deprecated
     * Paste plain text into editor using passed in clipboardData
     * @param clipboardData The clipboardData to paste
     */
    Paste.prototype.pasteText = function (clipboardData) {
        this.editor.paste(clipboardData, true /*pasteAsText*/);
    };
    /**
     * @deprecated
     * Paste into editor using passed in clipboardData with curent format
     * @param clipboardData The clipboardData to paste
     */
    Paste.prototype.pasteAndMergeFormat = function (clipboardData) {
        this.editor.paste(clipboardData, false /*pasteAsText*/, true /*applyCurrentFormat*/);
    };
    return Paste;
}());
exports.default = Paste;
//# sourceMappingURL=Paste.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/excelConverter/convertPastedContentFromExcel.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/excelConverter/convertPastedContentFromExcel.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var LAST_TD_END_REGEX = /<\/\s*td\s*>((?!<\/\s*tr\s*>)[\s\S])*$/i;
var LAST_TR_END_REGEX = /<\/\s*tr\s*>((?!<\/\s*table\s*>)[\s\S])*$/i;
var LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;
var LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;
var DEFAULT_BORDER_STYLE = 'solid 1px #d4d4d4';
/**
 * @internal
 * Convert pasted content from Excel, add borders when source doc doesn't have a border
 * @param doc HTML Document which contains the content from Excel
 */
function convertPastedContentFromExcel(event) {
    var _a;
    var fragment = event.fragment, sanitizingOption = event.sanitizingOption, htmlBefore = event.htmlBefore;
    var html = event.clipboardData.html;
    if (html.match(LAST_TD_END_REGEX)) {
        var trMatch = htmlBefore.match(LAST_TR_REGEX);
        var tr = trMatch ? trMatch[0] : '<TR>';
        html = tr + html + '</TR>';
    }
    if (html.match(LAST_TR_END_REGEX)) {
        var tableMatch = htmlBefore.match(LAST_TABLE_REGEX);
        var table = tableMatch ? tableMatch[0] : '<TABLE>';
        html = table + html + '</TABLE>';
    }
    if (event.clipboardData.html != html) {
        var doc = new DOMParser().parseFromString(html, 'text/html');
        while (fragment.firstChild) {
            fragment.removeChild(fragment.firstChild);
        }
        while ((_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.firstChild) {
            fragment.appendChild(doc.body.firstChild);
        }
    }
    roosterjs_editor_dom_1.chainSanitizerCallback(sanitizingOption.elementCallbacks, 'TD', function (element) {
        if (element.style.borderStyle == 'none') {
            element.style.border = DEFAULT_BORDER_STYLE;
        }
        return true;
    });
}
exports.default = convertPastedContentFromExcel;
//# sourceMappingURL=convertPastedContentFromExcel.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Paste_1 = __webpack_require__(/*! ./Paste */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/Paste.js");
exports.Paste = Paste_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/ListItemBlock.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/ListItemBlock.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internal
 * Initialize an empty ListItemBlock
 */
function createListItemBlock(listItem) {
    if (listItem === void 0) { listItem = null; }
    return {
        startElement: listItem,
        endElement: listItem,
        insertPositionNode: null,
        listItemContainers: listItem ? [listItem] : [],
    };
}
exports.createListItemBlock = createListItemBlock;
//# sourceMappingURL=ListItemBlock.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/constants.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/constants.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internal
 */
exports.WORD_ORDERED_LIST_SELECTOR = 'div.ListContainerWrapper > ul[class^="BulletListStyle"]';
/**
 * @internal
 */
exports.WORD_UNORDERED_LIST_SELECTOR = 'div.ListContainerWrapper > ol[class^="NumberListStyle"]';
/**
 * @internal
 */
exports.WORD_ONLINE_IDENTIFYING_SELECTOR = exports.WORD_ORDERED_LIST_SELECTOR + "," + exports.WORD_UNORDERED_LIST_SELECTOR;
/**
 * @internal
 */
exports.LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';
/**
 * @internal
 */
exports.UNORDERED_LIST_TAG_NAME = 'UL';
/**
 * @internal
 */
exports.ORDERED_LIST_TAG_NAME = 'OL';
var TEXT_CONTAINER_ELEMENT_CLASS_NAME = 'OutlineElement';
/**
 * @internal
 */
exports.WAC_IDENTIFING_SELECTOR = "ul[class^=\"BulletListStyle\"]>." + TEXT_CONTAINER_ELEMENT_CLASS_NAME + ",ol[class^=\"NumberListStyle\"]>." + TEXT_CONTAINER_ELEMENT_CLASS_NAME;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ListItemBlock_1 = __webpack_require__(/*! ./ListItemBlock */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/ListItemBlock.js");
var constants_1 = __webpack_require__(/*! ./constants */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/constants.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/**
 * @internal
 */
function isWordOnlineWithList(fragment) {
    return !!(fragment && fragment.querySelector(constants_1.WORD_ONLINE_IDENTIFYING_SELECTOR));
}
exports.isWordOnlineWithList = isWordOnlineWithList;
// Word Online pasted content DOM structure as of July 12th 2019
//<html>
//  <body>
//      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste
//          <div class="OutlineElement">  ----------> text content
//              <p></p>
//          </div>
//          <div class="ListItemWrapper">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper
//              <ul>                                       list items in the same list can be divided into different ListItemWrapper
//                  <li></li>                              list items in the same list can also be divided into different Outline Group;
//                  <li></li>
//              </ul>
//          </div>
//      </div>
//      <div class='OutlineGroup'>
//          <div class="ListItemWrapper">  ----------> list items: for ordered list, each items has it's own wrapper
//              <ol>
//                  <li></li>
//              </ol>
//          </div>
//          <div class="ListItemWrapper">
//              <ol>
//                  <li></li>
//              </ol>
//          </div>
//      </div>
//  </body>
//</html>
//
/**
 * @internal
 * Convert text copied from word online into text that's workable with rooster editor
 * @param fragment Document fragment that is being pasted into editor.
 */
function convertPastedContentFromWordOnline(fragment) {
    sanitizeListItemContainer(fragment);
    var listItemBlocks = getListItemBlocks(fragment);
    listItemBlocks.forEach(function (itemBlock) {
        // There are cases where consecutive List Elements are seperated into different divs:
        // <div>
        //   <div>
        //      <ol></ol>
        //   </div>
        //   <div>
        //      <ol></ol>
        //   </div>
        // </div>
        // <div>
        //   <div>
        //      <ol></ol>
        //   </div>
        // </div>
        // in the above case we want to collapse the two root level div into one and unwrap the list item divs.
        // after the following flattening the list will become following:
        //
        // <div>
        //    <ol></ol>
        // </div>
        // <div>
        //    <ol></ol>
        // </div>
        // <div>
        //    <ol></ol>
        // </div>
        // Then we are start processing.
        flattenListBlock(fragment, itemBlock);
        // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.
        itemBlock.insertPositionNode = itemBlock.endElement.nextSibling;
        var convertedListElement;
        var doc = fragment.ownerDocument;
        itemBlock.listItemContainers.forEach(function (listItemContainer) {
            var listType = getContainerListType(listItemContainer); // list type that is contained by iterator.
            // Initialize processed element with propery listType if this is the first element
            if (!convertedListElement) {
                convertedListElement = doc.createElement(listType);
            }
            // Get all list items(<li>) in the current iterator element.
            var currentListItems = listItemContainer.querySelectorAll('li');
            currentListItems.forEach(function (item) {
                // If item is in root level and the type of list changes then
                // insert the current list into body and then reinitialize the convertedListElement
                // Word Online is using data-aria-level to determine the the depth of the list item.
                var itemLevel = parseInt(item.getAttribute('data-aria-level'));
                // In first level list, there are cases where a consecutive list item divs may have different list type
                // When that happens we need to insert the processed elements into the document, then change the list type
                // and keep the processing going.
                if (roosterjs_editor_dom_1.getTagOfNode(convertedListElement) != listType && itemLevel == 1) {
                    insertConvertedListToDoc(convertedListElement, fragment, itemBlock);
                    convertedListElement = doc.createElement(listType);
                }
                insertListItem(convertedListElement, item, listType, doc);
            });
        });
        insertConvertedListToDoc(convertedListElement, fragment, itemBlock);
        // Once we finish the process the list items and put them into a list.
        // After inserting the processed element,
        // we need to remove all the non processed node from the parent node.
        var parentContainer = itemBlock.startElement.parentNode;
        if (parentContainer) {
            itemBlock.listItemContainers.forEach(function (listItemContainer) {
                parentContainer.removeChild(listItemContainer);
            });
        }
    });
}
exports.default = convertPastedContentFromWordOnline;
/**
 * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class
 * However the html might be melformed, this function is to split all the other elements out of ListContainerWrapper
 * @param fragment pasted document that contains all the list element.
 */
function sanitizeListItemContainer(fragment) {
    var listItemContainerListEl = fragment.querySelectorAll(constants_1.WORD_ORDERED_LIST_SELECTOR + ", " + constants_1.WORD_UNORDERED_LIST_SELECTOR);
    listItemContainerListEl.forEach(function (el) {
        var replaceRegex = new RegExp("\\b" + constants_1.LIST_CONTAINER_ELEMENT_CLASS_NAME + "\\b", 'g');
        if (el.previousSibling) {
            var prevParent = roosterjs_editor_dom_1.splitParentNode(el, true);
            prevParent.className = prevParent.className.replace(replaceRegex, '');
        }
        if (el.nextSibling) {
            var nextParent = roosterjs_editor_dom_1.splitParentNode(el, false);
            nextParent.className = nextParent.className.replace(replaceRegex, '');
        }
    });
}
/**
 * Take all the list items in the document, and group the consecutive list times in a list block;
 * @param fragment pasted document that contains all the list element.
 */
function getListItemBlocks(fragment) {
    var listElements = fragment.querySelectorAll('.' + constants_1.LIST_CONTAINER_ELEMENT_CLASS_NAME);
    var result = [];
    var curListItemBlock;
    for (var i = 0; i < listElements.length; i++) {
        var curItem = listElements[i];
        if (!curListItemBlock) {
            curListItemBlock = ListItemBlock_1.createListItemBlock(curItem);
        }
        else {
            var listItemContainers = curListItemBlock.listItemContainers;
            var lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];
            if (curItem == lastItemInCurBlock.nextSibling ||
                roosterjs_editor_dom_1.getFirstLeafNode(curItem) ==
                    roosterjs_editor_dom_1.getNextLeafSibling(lastItemInCurBlock.parentNode, lastItemInCurBlock)) {
                listItemContainers.push(curItem);
                curListItemBlock.endElement = curItem;
            }
            else {
                curListItemBlock.endElement = lastItemInCurBlock;
                result.push(curListItemBlock);
                curListItemBlock = ListItemBlock_1.createListItemBlock(curItem);
            }
        }
    }
    if (curListItemBlock.listItemContainers.length > 0) {
        result.push(curListItemBlock);
    }
    return result;
}
/**
 * Flatten the list items, so that all the consecutive list items are under the same parent.
 * @param fragment Root element of that contains the element.
 * @param listItemBlock The list item block needed to be flattened.
 */
function flattenListBlock(fragment, listItemBlock) {
    var collapsedListItemSections = roosterjs_editor_dom_1.collapseNodes(fragment, listItemBlock.startElement, listItemBlock.endElement, true);
    collapsedListItemSections.forEach(function (section) {
        if (roosterjs_editor_dom_1.getTagOfNode(section.firstChild) == 'DIV') {
            roosterjs_editor_dom_1.unwrap(section);
        }
    });
}
/**
 * Get the list type that the container contains. If there is no list in the container
 * return null;
 * @param listItemContainer Container that contains a list
 */
function getContainerListType(listItemContainer) {
    var tag = roosterjs_editor_dom_1.getTagOfNode(listItemContainer.firstChild);
    return tag == constants_1.UNORDERED_LIST_TAG_NAME || tag == constants_1.ORDERED_LIST_TAG_NAME ? tag : null;
}
/**
 * Insert list item into the correct position of a list
 * @param listRootElement Root element of the list that is accepting a coming element.
 * @param itemToInsert List item that needed to be inserted.
 * @param listType Type of list(ul/ol)
 */
function insertListItem(listRootElement, itemToInsert, listType, doc) {
    if (!listType) {
        return;
    }
    // Get item level from 'data-aria-level' attribute
    var itemLevel = parseInt(itemToInsert.getAttribute('data-aria-level'));
    var curListLevel = listRootElement; // Level iterator to find the correct place for the current element.
    // if the itemLevel is 1 it means the level iterator is at the correct place.
    while (itemLevel > 1) {
        if (!curListLevel.firstChild) {
            // If the current level is empty, create empty list within the current level
            // then move the level iterator into the next level.
            curListLevel.append(doc.createElement(listType));
            curListLevel = curListLevel.firstElementChild;
        }
        else {
            // If the current level is not empty, the last item in the needs to be a UL or OL
            // and the level iterator should move to the UL/OL at the last position.
            var lastChild = curListLevel.lastElementChild;
            var lastChildTag = roosterjs_editor_dom_1.getTagOfNode(lastChild);
            if (lastChildTag == constants_1.UNORDERED_LIST_TAG_NAME || lastChildTag == constants_1.ORDERED_LIST_TAG_NAME) {
                // If the last child is a list(UL/OL), then move the level iterator to last child.
                curListLevel = lastChild;
            }
            else {
                // If the last child is not a list, then append a new list to the level
                // and move the level iterator to the new level.
                curListLevel.append(doc.createElement(listType));
                curListLevel = curListLevel.lastElementChild;
            }
        }
        itemLevel--;
    }
    // Once the level iterator is at the right place, then append the list item in the level.
    curListLevel.appendChild(itemToInsert);
}
/**
 * Insert the converted list item into the correct place.
 * @param convertedListElement List element that is converted from list item block
 * @param fragment Root element of that contains the converted listItemBlock
 * @param listItemBlock List item block that was converted.
 */
function insertConvertedListToDoc(convertedListElement, fragment, listItemBlock) {
    if (!convertedListElement) {
        return;
    }
    var insertPositionNode = listItemBlock.insertPositionNode;
    if (insertPositionNode) {
        var parentElement = insertPositionNode.parentElement;
        if (parentElement) {
            parentElement.insertBefore(convertedListElement, insertPositionNode);
        }
    }
    else {
        var parentElement = listItemBlock.startElement.parentElement;
        if (parentElement) {
            parentElement.appendChild(convertedListElement);
        }
        else {
            fragment.appendChild(convertedListElement);
        }
    }
}
//# sourceMappingURL=convertPastedContentFromWordOnline.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/CustomData.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/CustomData.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** NodeId attribute */
var NODE_ID_ATTRIBUTE_NAME = 'NodeId';
/**
 * @internal
 * Create an empty CustomData
 */
function createCustomData() {
    return {
        dict: {},
        nextNodeId: 1,
    };
}
exports.createCustomData = createCustomData;
/**
 * @internal
 * Sets the specified object data
 */
function setObject(customData, element, key, value) {
    // Get the id for the element
    if (element.nodeType == 1 /* Element */) {
        var id = getAndSetNodeId(customData, element);
        if (id != '') {
            // Get the values for the element
            if (!customData.dict[id]) {
                // First time dictionary creation
                customData.dict[id] = {};
            }
            customData.dict[id][key] = value;
        }
    }
}
exports.setObject = setObject;
/**
 * @internal
 * Reads the specified object data
 */
function getObject(customData, element, key) {
    if (element.nodeType == 1 /* Element */) {
        var id = getAndSetNodeId(customData, element);
        if (id != '') {
            return customData.dict[id] && customData.dict[id][key];
        }
    }
    return null;
}
exports.getObject = getObject;
/**
 * Get the unique id for the specified node...
 */
function getAndSetNodeId(customData, element) {
    var id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);
    if (!id) {
        id = customData.nextNodeId.toString();
        customData.nextNodeId++;
        element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);
    }
    return id;
}
//# sourceMappingURL=CustomData.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/LevelLists.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/LevelLists.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internal
 * create an empty LevelLists
 */
function createLevelLists() {
    return {
        listsMetadata: {},
        currentUniqueListId: -1,
    };
}
exports.createLevelLists = createLevelLists;
//# sourceMappingURL=LevelLists.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordConverterArguments.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordConverterArguments.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LevelLists_1 = __webpack_require__(/*! ./LevelLists */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/LevelLists.js");
/**
 * @internal
 * create an empty WordConverterArguments
 */
function createWordConverterArguments(nodes) {
    return {
        nodes: nodes,
        currentIndex: 0,
        lists: {},
        listItems: [],
        currentListIdsByLevels: [LevelLists_1.createLevelLists()],
        lastProcessedItem: null,
    };
}
exports.createWordConverterArguments = createWordConverterArguments;
//# sourceMappingURL=WordConverterArguments.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/convertPastedContentFromWord.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/convertPastedContentFromWord.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var wordConverter_1 = __webpack_require__(/*! ./wordConverter */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/wordConverter.js");
var WordConverterArguments_1 = __webpack_require__(/*! ./WordConverterArguments */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordConverterArguments.js");
var converterUtils_1 = __webpack_require__(/*! ./converterUtils */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.js");
/**
 * @internal
 * Converts all the Word generated list items in the specified node into standard HTML UL and OL tags
 */
function convertPastedContentFromWord(event) {
    var sanitizingOption = event.sanitizingOption, fragment = event.fragment;
    // Preserve <o:p> when its innerHTML is "&nbsp;" to avoid dropping an empty line
    roosterjs_editor_dom_1.chainSanitizerCallback(sanitizingOption.elementCallbacks, 'O:P', function (element) {
        element.innerHTML = '&nbsp;';
        return true;
    });
    var wordConverter = wordConverter_1.createWordConverter();
    // First find all the nodes that we need to check for list item information
    // This call will return all the p and header elements under the root node.. These are the elements that
    // Word uses a list items, so we'll only process them and avoid walking the whole tree.
    var elements = fragment.querySelectorAll('p');
    if (elements.length > 0) {
        wordConverter.wordConverterArgs = WordConverterArguments_1.createWordConverterArguments(elements);
        if (converterUtils_1.processNodesDiscovery(wordConverter)) {
            converterUtils_1.processNodeConvert(wordConverter);
        }
    }
}
exports.default = convertPastedContentFromWord;
//# sourceMappingURL=convertPastedContentFromWord.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LevelLists_1 = __webpack_require__(/*! ./LevelLists */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/LevelLists.js");
var CustomData_1 = __webpack_require__(/*! ./CustomData */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/CustomData.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
/** Word list metadata style name */
var LOOKUP_DEPTH = 5;
/** Name for the word list id property in the custom data */
var UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';
/** Word list metadata style name */
var MSO_LIST_STYLE_NAME = 'mso-list';
/** Regular expression to match line breaks */
var LINE_BREAKS = /[\n|\r]/gi;
/**
 * @internal
 * Handles the pass 1: Discovery
 * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.
 * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these
 * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.
 */
function processNodesDiscovery(wordConverter) {
    var args = wordConverter.wordConverterArgs;
    while (args.currentIndex < args.nodes.length) {
        var node = args.nodes.item(args.currentIndex);
        // Try to get the list metadata for the specified node
        var itemMetadata = getListItemMetadata(node);
        if (itemMetadata) {
            var levelInfo = args.currentListIdsByLevels[itemMetadata.level - 1] || LevelLists_1.createLevelLists();
            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;
            // We need to drop some list information if this is not an item next to another
            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {
                // This list item is not next to the previous one. This means that there is some content in between them
                // so we need to reset our list of list ids per level
                resetCurrentLists(args);
            }
            // Get the list metadata for the list that will hold this item
            var listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];
            if (!listMetadata) {
                // Get the first item fake bullet.. This will be used later to check what is the right type of list
                var firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);
                // This is a the first item of a list.. We'll create the list metadata using the information
                // we already have from this first item
                listMetadata = {
                    numberOfItems: 0,
                    uniqueListId: wordConverter.nextUniqueId++,
                    firstFakeBullet: firstFakeBullet,
                    // If the bullet we got is emtpy or not found, we ignore the list out.. this means
                    // that this is not an item we need to convert of that the format doesn't match what
                    // we are expecting
                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,
                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second
                    // item, we'll perform a better comparasion, but for one item lists, this will be check that will determine the list type
                    tagName: getFakeBulletTagName(firstFakeBullet),
                };
                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;
                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;
            }
            else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {
                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet
                // items we have an decide if we create ordered or unordered lists based on this.
                // This is the best way we can do this since we cannot read the metadata that Word
                // puts in the head of the HTML...
                var secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);
                listMetadata.tagName =
                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';
            }
            // Set the unique id to the list
            itemMetadata.uniqueListId = listMetadata.uniqueListId;
            // Check if we need to ignore this list... we'll either know already that we need to ignore
            // it, or we'll know it because the previous list items are not next to this one
            if (listMetadata.ignore ||
                (listMetadata.tagName == 'OL' &&
                    listMetadata.numberOfItems > 0 &&
                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)) {
                // We need to ignore this item... and we also need to forget about the lists that
                // are not at the root level
                listMetadata.ignore = true;
                args.currentListIdsByLevels[0].currentUniqueListId = -1;
                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);
            }
            else {
                // This is an item we don't need to ignore... If added lists deep under this one before
                // we'll drop their ids from the list of ids per level.. this is because this list item
                // breaks the deeper lists.
                if (args.currentListIdsByLevels.length > itemMetadata.level) {
                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, itemMetadata.level);
                }
                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;
                // Add the list item into the list of items to be processed
                args.listItems.push(itemMetadata);
                listMetadata.numberOfItems++;
            }
            args.lastProcessedItem = node;
        }
        else {
            // Here, we know that this is not a list item, but we'll want to check if it is one "no bullet" list items...
            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will
            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but
            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips
            // the list conversion thinking that the list items are not together...
            var last = args.lastProcessedItem;
            if (last &&
                getRealPreviousSibling(node) == last &&
                node.tagName == last.tagName &&
                node.className == last.className) {
                // Add 2 line breaks and move all the nodes to the last item
                last.appendChild(last.ownerDocument.createElement('br'));
                last.appendChild(last.ownerDocument.createElement('br'));
                while (node.firstChild != null) {
                    last.appendChild(node.firstChild);
                }
                // Remove the item that we don't need anymore
                node.parentNode.removeChild(node);
            }
        }
        // Move to the next element are return true if more elements need to be processed
        args.currentIndex++;
    }
    return args.listItems.length > 0;
}
exports.processNodesDiscovery = processNodesDiscovery;
/**
 * @internal
 * Handles the pass 2: Conversion
 * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the
 * conversion needed
 */
function processNodeConvert(wordConverter) {
    var args = wordConverter.wordConverterArgs;
    args.currentIndex = 0;
    while (args.currentIndex < args.listItems.length) {
        var metadata = args.listItems[args.currentIndex];
        var node = metadata.originalNode;
        var listMetadata = args.lists[metadata.uniqueListId.toString()];
        if (!listMetadata.ignore) {
            // We have a list item that we need to convert, get or create the list
            // that hold this item out
            var list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);
            if (list) {
                // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes
                cleanupListIgnore(node, LOOKUP_DEPTH);
                // Create a new list item and transfer the children
                var li = node.ownerDocument.createElement('LI');
                while (node.firstChild) {
                    li.appendChild(node.firstChild);
                }
                // Append the list item into the list
                list.appendChild(li);
                // Remove the node we just converted
                node.parentNode.removeChild(node);
                if (listMetadata.tagName == 'UL') {
                    wordConverter.numBulletsConverted++;
                }
                else {
                    wordConverter.numNumberedConverted++;
                }
            }
        }
        args.currentIndex++;
    }
    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;
}
exports.processNodeConvert = processNodeConvert;
/**
 * Gets or creates the list (UL or OL) that holds this item out based on the
 * items content and the specified metadata
 */
function getOrCreateListForNode(wordConverter, node, metadata, listMetadata) {
    // First get the last list next to this node under the specified level. This code
    // path will return the list or will create lists if needed
    var list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);
    // Here use the unique list ID to detect if we have the right list...
    // it is possible to have 2 different lists next to each other with different formats, so
    // we want to detect this an create separate lists for those cases
    var listId = CustomData_1.getObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA);
    // If we have a list with and ID, but the ID is different than the ID for this list item, this
    // is a completely new list, so we'll append a new list for that
    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {
        var newList = node.ownerDocument.createElement(listMetadata.tagName);
        list.parentNode.insertBefore(newList, list.nextSibling);
        list = newList;
    }
    // Set the list id into the custom data
    CustomData_1.setObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA, metadata.uniqueListId);
    // This call will convert the list if needed to the right type of list required. This can happen
    // on the cases where the first list item for this list is located after a deeper list. for that
    // case, we will have created a UL for it, and we may need to convert it
    return convertListIfNeeded(wordConverter, list, listMetadata);
}
/**
 * Converts the list between UL and OL if needed, by using the fake bullet and
 * information already stored in the list itself
 */
function convertListIfNeeded(wordConverter, list, listMetadata) {
    // Check if we need to convert the list out
    if (listMetadata.tagName != roosterjs_editor_dom_1.getTagOfNode(list)) {
        // We have the wrong list type.. convert it, set the id again and tranfer all the childs
        var newList = list.ownerDocument.createElement(listMetadata.tagName);
        CustomData_1.setObject(wordConverter.customData, newList, UNIQUE_LIST_ID_CUSTOM_DATA, CustomData_1.getObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA));
        while (list.firstChild) {
            newList.appendChild(list.firstChild);
        }
        list.parentNode.insertBefore(newList, list);
        list.parentNode.removeChild(list);
        list = newList;
    }
    return list;
}
/**
 * Gets or creates the specified list
 */
function recurringGetOrCreateListAtNode(node, level, listMetadata) {
    var parent = null;
    var possibleList;
    if (level == 1) {
        // Root case, we'll check if the list is the previous sibling of the node
        possibleList = getRealPreviousSibling(node);
    }
    else {
        // If we get here, we are looking for level 2 or deeper... get the upper list
        // and check if the last element is a list
        parent = recurringGetOrCreateListAtNode(node, level - 1, null);
        possibleList = parent.lastChild;
    }
    // Check the element that we got and verify that it is a list
    if (possibleList && possibleList.nodeType == 1 /* Element */) {
        var tag = roosterjs_editor_dom_1.getTagOfNode(possibleList);
        if (tag == 'UL' || tag == 'OL') {
            // We have a list.. use it
            return possibleList;
        }
    }
    // If we get here, it means we don't have a list and we need to create one
    // this code path will always create new lists as UL lists
    var newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');
    if (level == 1) {
        // For level 1, we'll insert the list beofre the node
        node.parentNode.insertBefore(newList, node);
    }
    else {
        // Any level 2 or above, we insert the list as the last
        // child of the upper level list
        parent.appendChild(newList);
    }
    return newList;
}
/**
 * Cleans up the node children by removing the childs marked as mso-list: Ignore.
 * This nodes hold the fake bullet information that Word puts in and when
 * conversion is happening, we want to get rid of these elements
 */
function cleanupListIgnore(node, levels) {
    var nodesToRemove = [];
    for (var child = node.firstChild; child; child = child.nextSibling) {
        // Clean up the item internally first if we need to based on the number of levels
        if (child.nodeType == 1 /* Element */ && levels > 1) {
            cleanupListIgnore(child, levels - 1);
        }
        // Try to convert word comments into ignore elements if we haven't done so for this element
        child = fixWordListComments(child, true /*removeComments*/);
        // Check if we can remove this item out
        if (isEmptySpan(child) || isIgnoreNode(child)) {
            nodesToRemove.push(child);
        }
    }
    nodesToRemove.forEach(function (child) { return node.removeChild(child); });
}
/**
 * Reads the word list metadada out of the specified node. If the node
 * is not a Word list item, it returns null.
 */
function getListItemMetadata(node) {
    if (node.nodeType == 1 /* Element */) {
        var listatt = getStyleValue(node, MSO_LIST_STYLE_NAME);
        if (listatt && listatt.length > 0) {
            try {
                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0
                // Where:
                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; metada
                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but
                // for almost all cases, it maps to the list identation (or level). We'll use it as the
                // list indentation value
                // (2) Contains a specific list identifier.
                // Example value: "l0 level1 lfo1"
                var listprops = listatt.split(' ');
                if (listprops.length == 3) {
                    return {
                        level: parseInt(listprops[1].substr('level'.length)),
                        wordListId: listatt,
                        originalNode: node,
                        uniqueListId: 0,
                    };
                }
            }
            catch (e) { }
        }
    }
    return null;
}
function isFakeBullet(fakeBullet) {
    return ['o', '', '', '-'].indexOf(fakeBullet) >= 0;
}
/** Given a fake bullet text, returns the type of list that should be used for it */
function getFakeBulletTagName(fakeBullet) {
    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';
}
/**
 * Finds the fake bullet text out of the specified node and returns it. For images, it will return
 * a bullet string. If not found, it returns null...
 */
function getFakeBulletText(node, levels) {
    // Word uses the following format for their bullets:
    // &lt;p style="mso-list:l1 level1 lfo2"&gt;
    // &lt;span style="..."&gt;
    // &lt;span style="mso-list:Ignore"&gt;1.&lt;span style="..."&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;
    // &lt;/span&gt;
    // Content here...
    // &lt;/p&gt;
    //
    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That
    // text or image node will be the fake bullet we are looking for
    var result = null;
    var child = node.firstChild;
    while (!result && child) {
        // First, check if we need to convert the Word list comments into real elements
        child = fixWordListComments(child, true /*removeComments*/);
        // Check if this is the node that holds the fake bullets (mso-list: Ignore)
        if (isIgnoreNode(child)) {
            // Yes... this is the node that holds either the text or image data
            result = child.textContent.trim();
            // This is the case for image case
            if (result.length == 0) {
                result = 'o';
            }
        }
        else if (child.nodeType == 1 /* Element */ && levels > 1) {
            // If this is an element and we are not in the last level, try to get the fake bullet
            // out of the child
            result = getFakeBulletText(child, levels - 1);
        }
        child = child.nextSibling;
    }
    return result;
}
/**
 * If the specified element is a Word List comments, this code verifies and fixes
 * the markup when needed to ensure that Chrome bullet conversions work as expected
 * -----
 * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into
 * &lt;span style="mso-list:Ignore"&gt;&lt;/span&gt;... Chrome has a bug where it drops the
 * styles of the span, but we'll use these comments to recreate them out
 */
function fixWordListComments(child, removeComments) {
    if (child.nodeType == 8 /* Comment */) {
        var value = child.data;
        if (value && value.trim().toLowerCase() == '[if !supportlists]') {
            // We have a list ignore start, find the end.. We know is not more than
            // 3 nodes away, so we'll optimize our checks
            var nextElement = child;
            var endComment = null;
            for (var j = 0; j < 4; j++) {
                nextElement = getRealNextSibling(nextElement);
                if (!nextElement) {
                    break;
                }
                if (nextElement.nodeType == 8 /* Comment */) {
                    value = nextElement.data;
                    if (value && value.trim().toLowerCase() == '[endif]') {
                        endComment = nextElement;
                        break;
                    }
                }
            }
            // if we found the end node, wrap everything out
            if (endComment) {
                var newSpan = child.ownerDocument.createElement('span');
                newSpan.setAttribute('style', 'mso-list: ignore');
                nextElement = getRealNextSibling(child);
                while (nextElement != endComment) {
                    nextElement = nextElement.nextSibling;
                    newSpan.appendChild(nextElement.previousSibling);
                }
                // Insert the element out and use that one as the current child
                endComment.parentNode.insertBefore(newSpan, endComment);
                // Remove the comments out if the call specified it out
                if (removeComments) {
                    child.parentNode.removeChild(child);
                    endComment.parentNode.removeChild(endComment);
                }
                // Last, make sure we return the new element out instead of the comment
                child = newSpan;
            }
        }
    }
    return child;
}
/** Finds the real previous sibling, ignoring emtpy text nodes */
function getRealPreviousSibling(node) {
    var prevSibling = node;
    do {
        prevSibling = prevSibling.previousSibling;
    } while (prevSibling && isEmptyTextNode(prevSibling));
    return prevSibling;
}
/** Finds the real next sibling, ignoring empty text nodes */
function getRealNextSibling(node) {
    var nextSibling = node;
    do {
        nextSibling = nextSibling.nextSibling;
    } while (nextSibling && isEmptyTextNode(nextSibling));
    return nextSibling;
}
/**
 * Checks if the specified node is marked as a mso-list: Ignore. These
 * nodes need to be ignored when a list item is converted into standard
 * HTML lists
 */
function isIgnoreNode(node) {
    if (node.nodeType == 1 /* Element */) {
        var listatt = getStyleValue(node, MSO_LIST_STYLE_NAME);
        if (listatt && listatt.length > 0 && listatt.trim().toLowerCase() == 'ignore') {
            return true;
        }
    }
    return false;
}
/** Checks if the specified node is an empty span. */
function isEmptySpan(node) {
    return roosterjs_editor_dom_1.getTagOfNode(node) == 'SPAN' && !node.firstChild;
}
/** Reads the specified style value from the node */
function getStyleValue(node, styleName) {
    // Word uses non-standard names for the metadata that puts in the style of the element...
    // Most browsers will not provide the information for those unstandard values throug the node.style
    // property, so the only reliable way to read them is to get the attribute directly and do
    // the required parsing..
    var textStyle = node.getAttribute('style');
    if (textStyle && textStyle.length > 0 && textStyle.indexOf(styleName) >= 0) {
        // Split all the CSS name: value pairs
        var inStyles = textStyle.split(';');
        for (var i = 0; i < inStyles.length; i++) {
            // Split the name and value
            var nvpair = inStyles[i].split(':');
            if (nvpair.length == 2 && nvpair[0].trim() == styleName) {
                return nvpair[1].trim();
            }
        }
    }
    // As a backup mechanism, we'll still try to get the value from the style object
    // Dictionary styles = (Dictionary)(object)node.Style;
    // return (string)styles[styleName];
    return null;
}
/** Checks if the node is an empty text node that can be ignored */
function isEmptyTextNode(node) {
    // No node is empty
    if (!node) {
        return true;
    }
    // Empty text node is empty
    if (node.nodeType == 3 /* Text */) {
        var value = node.nodeValue;
        value = value.replace(LINE_BREAKS, '');
        return value.trim().length == 0;
    }
    // Span or Font with an empty child node is empty
    var tagName = roosterjs_editor_dom_1.getTagOfNode(node);
    if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {
        return isEmptyTextNode(node.firstChild);
    }
    // If not found, then this is not empty
    return false;
}
/** Resets the list */
function resetCurrentLists(args) {
    for (var i = 0; i < args.currentListIdsByLevels.length; i++) {
        var ll = args.currentListIdsByLevels[i];
        if (ll) {
            ll.currentUniqueListId = -1;
        }
    }
}
//# sourceMappingURL=converterUtils.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/wordConverter.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/wordConverter.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CustomData_1 = __webpack_require__(/*! ./CustomData */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/CustomData.js");
/**
 * @internal
 * create an empty WordConverter
 */
function createWordConverter() {
    return {
        nextUniqueId: 1,
        numBulletsConverted: 0,
        numNumberedConverted: 0,
        wordConverterArgs: null,
        customData: CustomData_1.createCustomData(),
    };
}
exports.createWordConverter = createWordConverter;
//# sourceMappingURL=wordConverter.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Picker/PickerPlugin.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Picker/PickerPlugin.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_editor_api_1 = __webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js");
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
// Character codes.
// IE11 uses different character codes. which are noted below.
// If adding a new key, test in IE to figure out what the code is.
var BACKSPACE_CHARCODE = 'Backspace';
var TAB_CHARCODE = 'Tab';
var ENTER_CHARCODE = 'Enter';
var ESC_CHARCODE = !roosterjs_editor_dom_1.Browser.isIE ? 'Escape' : 'Esc';
var LEFT_ARROW_CHARCODE = !roosterjs_editor_dom_1.Browser.isIE ? 'ArrowLeft' : 'Left';
var UP_ARROW_CHARCODE = !roosterjs_editor_dom_1.Browser.isIE ? 'ArrowUp' : 'Up';
var RIGHT_ARROW_CHARCODE = !roosterjs_editor_dom_1.Browser.isIE ? 'ArrowRight' : 'Right';
var DOWN_ARROW_CHARCODE = !roosterjs_editor_dom_1.Browser.isIE ? 'ArrowDown' : 'Down';
var DELETE_CHARCODE = !roosterjs_editor_dom_1.Browser.isIE ? 'Delete' : 'Del';
// Input event input types.
var DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';
// Unidentified key, the code for Android keyboard events.
var UNIDENTIFIED_KEY = 'Unidentified';
// the char code for Android keyboard events on Webview below 51.
var UNIDENTIFIED_CODE = [0, 229];
/**
 * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including
 * - Show picker when special trigger key is pressed
 * - Hide picker
 * - Change selection in picker by Up/Down/Left/Right
 * - Apply selected item in picker
 *
 * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.
 * To show a picker UI, you need to build your own UI component. Please reference to
 * https://github.com/microsoft/roosterjs/tree/master/publish/samplesite/scripts/controls/samplepicker
 */
var PickerPlugin = /** @class */ (function () {
    function PickerPlugin(dataProvider, pickerOptions) {
        this.dataProvider = dataProvider;
        this.pickerOptions = pickerOptions;
        // For detecting backspace in Android
        this.isPendingInputEventHandling = false;
    }
    /**
     * Get a friendly name
     */
    PickerPlugin.prototype.getName = function () {
        return 'Picker';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    PickerPlugin.prototype.initialize = function (editor) {
        var _this = this;
        this.editor = editor;
        this.dataProvider.onInitalize(function (htmlNode) {
            _this.editor.focus();
            var wordToReplace = _this.getWord(null);
            // Safari drops our focus out so we get an empty word to replace when we call getWord.
            // We fall back to using the lastKnownRange to try to get around this.
            if ((!wordToReplace || wordToReplace.length == 0) && _this.lastKnownRange) {
                _this.editor.select(_this.lastKnownRange);
                wordToReplace = _this.getWord(null);
            }
            var insertNode = function () {
                if (wordToReplace) {
                    roosterjs_editor_api_1.replaceWithNode(_this.editor, wordToReplace, htmlNode, true /* exactMatch */);
                }
                else {
                    _this.editor.insertNode(htmlNode);
                }
                _this.setIsSuggesting(false);
            };
            if (_this.pickerOptions.handleAutoComplete) {
                _this.editor.performAutoComplete(insertNode, _this.pickerOptions.changeSource);
            }
            else {
                _this.editor.addUndoSnapshot(insertNode, _this.pickerOptions.changeSource);
            }
        }, function (isSuggesting) {
            _this.setIsSuggesting(isSuggesting);
        }, editor);
    };
    /**
     * Dispose this plugin
     */
    PickerPlugin.prototype.dispose = function () {
        this.editor = null;
        this.dataProvider.onDispose();
    };
    /**
     * Check if the plugin should handle the given event exclusively.
     * Handle an event exclusively means other plugin will not receive this event in
     * onPluginEvent method.
     * If two plugins will return true in willHandleEventExclusively() for the same event,
     * the final result depends on the order of the plugins are added into editor
     * @param event The event to check
     */
    PickerPlugin.prototype.willHandleEventExclusively = function (event) {
        return (this.isSuggesting &&
            (event.eventType == 0 /* KeyDown */ ||
                event.eventType == 2 /* KeyUp */ ||
                event.eventType == 12 /* Input */));
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    PickerPlugin.prototype.onPluginEvent = function (event) {
        switch (event.eventType) {
            case 6 /* ContentChanged */:
                if (event.source == "SetContent" /* SetContent */ && this.dataProvider.onContentChanged) {
                    // Stop suggesting since content is fully changed
                    if (this.isSuggesting) {
                        this.setIsSuggesting(false);
                    }
                    // Undos and other major changes to document content fire this type of event.
                    // Inform the data provider of the current picker placed elements in the body.
                    var elementIds_1 = [];
                    this.editor.queryElements("[id^='" + this.pickerOptions.elementIdPrefix + "']", function (element) {
                        if (element.id) {
                            elementIds_1.push(element.id);
                        }
                    });
                    this.dataProvider.onContentChanged(elementIds_1);
                }
                break;
            case 0 /* KeyDown */:
                this.eventHandledOnKeyDown = false;
                if (this.isAndroidKeyboardEvent(event)) {
                    // On Android, the key for KeyboardEvent is "Unidentified" or undefined,
                    // so handling should be done using the input rather than key down event
                    // Since the key down event happens right before the input event, calculate the input
                    // length here in preparation for onAndroidInputEvent
                    this.currentInputLength = this.calcInputLength(event);
                    this.isPendingInputEventHandling = true;
                }
                else {
                    this.onKeyDownEvent(event);
                    this.isPendingInputEventHandling = false;
                }
                break;
            case 12 /* Input */:
                if (this.isPendingInputEventHandling) {
                    this.onAndroidInputEvent(event);
                }
                break;
            case 2 /* KeyUp */:
                if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {
                    this.onKeyUpDomEvent(event);
                    this.isPendingInputEventHandling = false;
                }
                break;
            case 5 /* MouseUp */:
                if (this.isSuggesting) {
                    this.setIsSuggesting(false);
                }
                break;
            case 15 /* Scroll */:
                if (this.dataProvider.onScroll) {
                    // Dispatch scroll event to data provider
                    this.dataProvider.onScroll(event.scrollContainer);
                }
                break;
        }
    };
    PickerPlugin.prototype.setLastKnownRange = function (range) {
        this.lastKnownRange = range;
    };
    PickerPlugin.prototype.setIsSuggesting = function (isSuggesting) {
        this.isSuggesting = isSuggesting;
        if (!isSuggesting) {
            this.setLastKnownRange(null);
        }
        this.dataProvider.onIsSuggestingChanged(isSuggesting);
        this.setAriaOwns(isSuggesting);
        this.setAriaActiveDescendant(isSuggesting ? 0 : null);
    };
    PickerPlugin.prototype.cancelDefaultKeyDownEvent = function (event) {
        this.eventHandledOnKeyDown = true;
        event.rawEvent.preventDefault();
        event.rawEvent.stopImmediatePropagation();
    };
    PickerPlugin.prototype.getIdValue = function (node) {
        var element = node;
        return element.attributes && element.attributes.getNamedItem('id')
            ? element.attributes.getNamedItem('id').value
            : null;
    };
    PickerPlugin.prototype.getWordBeforeCursor = function (event) {
        var searcher = roosterjs_editor_core_1.cacheGetContentSearcher(event, this.editor);
        return searcher ? searcher.getWordBefore() : null;
    };
    PickerPlugin.prototype.replaceNode = function (currentNode, replacementNode) {
        if (currentNode) {
            this.editor.deleteNode(currentNode);
        }
        if (replacementNode) {
            this.editor.insertNode(replacementNode);
        }
    };
    PickerPlugin.prototype.getRangeUntilAt = function (event) {
        var _this = this;
        var PositionContentSearcher = roosterjs_editor_core_1.cacheGetContentSearcher(event, this.editor);
        var startPos;
        var endPos;
        PositionContentSearcher.forEachTextInlineElement(function (textInline) {
            var hasMatched = false;
            var nodeContent = textInline.getTextContent();
            var nodeIndex = nodeContent ? nodeContent.length : -1;
            while (nodeIndex >= 0) {
                if (nodeContent[nodeIndex] == _this.pickerOptions.triggerCharacter) {
                    startPos = textInline.getStartPosition().move(nodeIndex);
                    hasMatched = true;
                    break;
                }
                nodeIndex--;
            }
            if (hasMatched) {
                endPos = textInline.getEndPosition();
            }
            return hasMatched;
        });
        return roosterjs_editor_dom_1.createRange(startPos, endPos) || this.editor.getDocument().createRange();
    };
    PickerPlugin.prototype.shouldHandleKeyUpEvent = function (event) {
        // onKeyUpDomEvent should only be called when a key that produces a character value is pressed
        // This check will always fail on Android since the KeyboardEvent's key is "Unidentified" or undefined
        // However, we don't need to check for modifier events on mobile, so can ignore this check
        return (this.isAndroidKeyboardEvent(event) ||
            roosterjs_editor_core_1.isCharacterValue(event.rawEvent) ||
            (this.isSuggesting && !roosterjs_editor_core_1.isModifierKey(event.rawEvent)));
    };
    PickerPlugin.prototype.onKeyUpDomEvent = function (event) {
        if (this.isSuggesting) {
            // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.
            var wordBeforeCursor = this.getWord(event);
            var wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);
            var trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();
            // If we hit a case where wordBeforeCursor is just the trigger character,
            // that means we've gotten a onKeyUp event right after it's been typed.
            // Otherwise, update the query string when:
            // 1. There's an actual value
            // 2. That actual value isn't just pure whitespace
            // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)
            // Otherwise, we want to dismiss the picker plugin's UX.
            if (wordBeforeCursor == this.pickerOptions.triggerCharacter ||
                (trimmedWordBeforeCursor &&
                    trimmedWordBeforeCursor.length > 0 &&
                    trimmedWordBeforeCursor.split(' ').length <= 4)) {
                this.dataProvider.queryStringUpdated(trimmedWordBeforeCursor, wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor);
                this.setLastKnownRange(this.editor.getSelectionRange());
            }
            else {
                this.setIsSuggesting(false);
            }
        }
        else {
            var wordBeforeCursor = this.getWordBeforeCursor(event);
            if (!this.blockSuggestions) {
                if (wordBeforeCursor != null &&
                    wordBeforeCursor.split(' ').length <= 4 &&
                    wordBeforeCursor[0] == this.pickerOptions.triggerCharacter) {
                    this.setIsSuggesting(true);
                    var wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);
                    var trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();
                    this.dataProvider.queryStringUpdated(trimmedWordBeforeCursor, wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor);
                    this.setLastKnownRange(this.editor.getSelectionRange());
                    if (this.dataProvider.setCursorPoint) {
                        // Determine the bounding rectangle for the @mention
                        var searcher = roosterjs_editor_core_1.cacheGetContentSearcher(event, this.editor);
                        var rangeNode = this.editor.getDocument().createRange();
                        var nodeBeforeCursor = searcher.getInlineElementBefore().getContainerNode();
                        var rangeStartSuccessfullySet = this.setRangeStart(rangeNode, nodeBeforeCursor, wordBeforeCursor);
                        if (!rangeStartSuccessfullySet) {
                            // VSO 24891: Out of range error is occurring because nodeBeforeCursor
                            // is not including the trigger character. In this case, the node before
                            // the node before cursor is the trigger character, and this is where the range should start.
                            var nodeBeforeNodeBeforeCursor = nodeBeforeCursor.previousSibling;
                            this.setRangeStart(rangeNode, nodeBeforeNodeBeforeCursor, this.pickerOptions.triggerCharacter);
                        }
                        var rect = rangeNode.getBoundingClientRect();
                        // Safari's support for range.getBoundingClientRect is incomplete.
                        // We perform this check to fall back to getClientRects in case it's at the page origin.
                        if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {
                            rect = rangeNode.getClientRects()[0];
                        }
                        if (rect) {
                            rangeNode.detach();
                            // Display the @mention popup in the correct place
                            var targetPoint = { x: rect.left, y: (rect.bottom + rect.top) / 2 };
                            var bufferZone = (rect.bottom - rect.top) / 2;
                            this.dataProvider.setCursorPoint(targetPoint, bufferZone);
                        }
                    }
                }
            }
            else {
                if (wordBeforeCursor != null &&
                    wordBeforeCursor[0] != this.pickerOptions.triggerCharacter) {
                    this.blockSuggestions = false;
                }
            }
        }
    };
    PickerPlugin.prototype.onKeyDownEvent = function (event) {
        var keyboardEvent = event.rawEvent;
        if (this.isSuggesting) {
            if (keyboardEvent.key == ESC_CHARCODE) {
                this.setIsSuggesting(false);
                this.blockSuggestions = true;
                this.cancelDefaultKeyDownEvent(event);
            }
            else if (this.dataProvider.shiftHighlight &&
                (this.pickerOptions.isHorizontal
                    ? keyboardEvent.key == LEFT_ARROW_CHARCODE ||
                        keyboardEvent.key == RIGHT_ARROW_CHARCODE
                    : keyboardEvent.key == UP_ARROW_CHARCODE ||
                        keyboardEvent.key == DOWN_ARROW_CHARCODE)) {
                this.dataProvider.shiftHighlight(this.pickerOptions.isHorizontal
                    ? keyboardEvent.key == RIGHT_ARROW_CHARCODE
                    : keyboardEvent.key == DOWN_ARROW_CHARCODE);
                if (this.dataProvider.getSelectedIndex) {
                    this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());
                }
                this.cancelDefaultKeyDownEvent(event);
            }
            else if (this.dataProvider.selectOption &&
                (keyboardEvent.key == ENTER_CHARCODE || keyboardEvent.key == TAB_CHARCODE)) {
                this.dataProvider.selectOption();
                this.cancelDefaultKeyDownEvent(event);
            }
            else {
                // Currently no op.
            }
        }
        else {
            if (keyboardEvent.key == BACKSPACE_CHARCODE) {
                var nodeRemoved = this.tryRemoveNode(event);
                if (nodeRemoved) {
                    this.cancelDefaultKeyDownEvent(event);
                }
            }
            else if (keyboardEvent.key == DELETE_CHARCODE) {
                var searcher = roosterjs_editor_core_1.cacheGetContentSearcher(event, this.editor);
                var nodeAfterCursor = searcher.getInlineElementAfter()
                    ? searcher.getInlineElementAfter().getContainerNode()
                    : null;
                var nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;
                if (nodeId && nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0) {
                    var replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);
                    this.replaceNode(nodeAfterCursor, replacementNode);
                    this.cancelDefaultKeyDownEvent(event);
                }
            }
        }
    };
    PickerPlugin.prototype.onAndroidInputEvent = function (event) {
        this.newInputLength = this.calcInputLength(event);
        if (this.newInputLength < this.currentInputLength ||
            event.rawEvent.inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE) {
            var nodeRemoved = this.tryRemoveNode(event);
            if (nodeRemoved) {
                this.eventHandledOnKeyDown = true;
            }
        }
    };
    PickerPlugin.prototype.calcInputLength = function (event) {
        var wordBeforCursor = this.getInlineElementBeforeCursor(event);
        return wordBeforCursor ? wordBeforCursor.length : 0;
    };
    PickerPlugin.prototype.tryRemoveNode = function (event) {
        var _this = this;
        var searcher = roosterjs_editor_core_1.cacheGetContentSearcher(event, this.editor);
        var inlineElementBefore = searcher.getInlineElementBefore();
        var nodeBeforeCursor = inlineElementBefore
            ? inlineElementBefore.getContainerNode()
            : null;
        var nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;
        var inlineElementAfter = searcher.getInlineElementAfter();
        if (nodeId &&
            nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&
            (inlineElementAfter == null || !(inlineElementAfter instanceof roosterjs_editor_dom_1.PartialInlineElement))) {
            var replacementNode_1 = this.dataProvider.onRemove(nodeBeforeCursor, true);
            if (replacementNode_1) {
                this.replaceNode(nodeBeforeCursor, replacementNode_1);
                if (this.isPendingInputEventHandling) {
                    this.editor.runAsync(function () {
                        _this.editor.select(replacementNode_1, -3 /* After */);
                    });
                }
                else {
                    this.editor.select(replacementNode_1, -3 /* After */);
                }
            }
            else {
                this.editor.deleteNode(nodeBeforeCursor);
            }
            return true;
        }
        return false;
    };
    PickerPlugin.prototype.getWord = function (event) {
        var wordFromRange = this.getRangeUntilAt(event).toString();
        var wordFromCache = this.getWordBeforeCursor(event);
        // VSO 24891: In picker, trigger and mention are separated into two nodes.
        // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,
        // so wordFromCache is what we want to return.
        if (wordFromRange == this.pickerOptions.triggerCharacter &&
            wordFromRange != wordFromCache) {
            return wordFromCache;
        }
        return wordFromRange;
    };
    PickerPlugin.prototype.setRangeStart = function (rangeNode, node, target) {
        var nodeOffset = node ? node.textContent.lastIndexOf(target) : -1;
        if (nodeOffset > -1) {
            rangeNode.setStart(node, nodeOffset);
            return true;
        }
        return false;
    };
    PickerPlugin.prototype.setAriaOwns = function (isSuggesting) {
        this.editor.setEditorDomAttribute('aria-owns', isSuggesting && this.pickerOptions.suggestionsLabel
            ? this.pickerOptions.suggestionsLabel
            : null);
    };
    PickerPlugin.prototype.setAriaActiveDescendant = function (selectedIndex) {
        this.editor.setEditorDomAttribute('aria-activedescendant', selectedIndex != null && this.pickerOptions.suggestionLabelPrefix
            ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()
            : null);
    };
    PickerPlugin.prototype.getInlineElementBeforeCursor = function (event) {
        var searcher = roosterjs_editor_core_1.cacheGetContentSearcher(event, this.editor);
        var element = searcher ? searcher.getInlineElementBefore() : null;
        return element ? element.getTextContent() : null;
    };
    PickerPlugin.prototype.isAndroidKeyboardEvent = function (event) {
        // Check keyboard events on Android for further handling.
        // On Android Webview later 51, the KeyboardEvent's key is "Unidentified".
        // On Android Webview below 51, the KeyboardEvent's key is not supported and always returns undefined,
        // so using the charCode property, which is 0 or 229.
        return (event.rawEvent.key == UNIDENTIFIED_KEY ||
            (event.rawEvent.key == undefined &&
                UNIDENTIFIED_CODE.indexOf(event.rawEvent.charCode) > -1));
    };
    return PickerPlugin;
}());
exports.default = PickerPlugin;
//# sourceMappingURL=PickerPlugin.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Picker/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Picker/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var PickerPlugin_1 = __webpack_require__(/*! ./PickerPlugin */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Picker/PickerPlugin.js");
exports.PickerPlugin = PickerPlugin_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/TableResize/TableResize.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/TableResize/TableResize.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var INSERTER_COLOR = '#4A4A4A';
var INSERTER_SIDE_LENGTH = 12;
var INSERTER_BORDER_SIZE = 1;
var CELL_RESIZER_WIDTH = 4;
var HORIZONTAL_RESIZER_HTML = '<div style="position: fixed; cursor: row-resize; user-select: none"></div>';
var VERTICAL_RESIZER_HTML = '<div style="position: fixed; cursor: col-resize; user-select: none"></div>';
var ResizeState;
(function (ResizeState) {
    ResizeState[ResizeState["None"] = 0] = "None";
    ResizeState[ResizeState["Horizontal"] = 1] = "Horizontal";
    ResizeState[ResizeState["Vertical"] = 2] = "Vertical";
})(ResizeState || (ResizeState = {}));
/**
 * TableResize plugin, provides the ability to resize a table by drag-and-drop
 */
var TableResize = /** @class */ (function () {
    function TableResize() {
        var _this = this;
        this.tableRectMap = null;
        this.resizingState = 0 /* None */;
        this.insertingState = 0 /* None */;
        this.onMouseMove = function (e) {
            if (_this.resizingState != 0 /* None */) {
                return;
            }
            if (!_this.tableRectMap) {
                _this.cacheRects();
            }
            if (_this.tableRectMap) {
                var i = _this.tableRectMap.length - 1;
                for (; i >= 0; i--) {
                    var _a = _this.tableRectMap[i], table = _a.table, rect = _a.rect;
                    if (e.pageX >= rect.left - INSERTER_SIDE_LENGTH &&
                        e.pageX <= rect.right &&
                        e.pageY >= rect.top - INSERTER_SIDE_LENGTH &&
                        e.pageY <= rect.bottom) {
                        _this.setCurrentTable(table, rect);
                        break;
                    }
                }
                if (i < 0) {
                    _this.setCurrentTable(null);
                }
                if (_this.currentTable) {
                    var map = _this.tableRectMap.filter(function (map) { return map.table == _this.currentTable; })[0];
                    for (var i_1 = 0; i_1 < _this.currentTable.rows.length; i_1++) {
                        var tr = _this.currentTable.rows[i_1];
                        var j = 0;
                        for (; j < tr.cells.length; j++) {
                            var td = tr.cells[Math.max(0, j)];
                            var tdRect = roosterjs_editor_dom_1.normalizeRect(td.getBoundingClientRect());
                            if (e.pageX <= tdRect.right && e.pageY < tdRect.bottom) {
                                if (i_1 == 0 && e.pageY < tdRect.top) {
                                    _this.setCurrentTd(null);
                                    _this.setCurrentInsertTd(2 /* Vertical */, td, map.rect);
                                    break;
                                }
                                else if (j == 0 && e.pageX < tdRect.left) {
                                    _this.setCurrentTd(null);
                                    _this.setCurrentInsertTd(1 /* Horizontal */, td, map.rect);
                                    break;
                                }
                                else {
                                    _this.setCurrentTd(td, map.rect, tdRect.right, tdRect.bottom);
                                    _this.setCurrentInsertTd(0 /* None */);
                                    break;
                                }
                            }
                        }
                        if (j < tr.cells.length) {
                            break;
                        }
                    }
                }
            }
        };
        this.insertTd = function () {
            _this.editor.addUndoSnapshot(function (start, end) {
                var vtable = new roosterjs_editor_dom_1.VTable(_this.currentInsertTd);
                vtable.edit(_this.insertingState == 1 /* Horizontal */
                    ? 1 /* InsertBelow */
                    : 3 /* InsertRight */);
                vtable.writeBack();
                _this.editor.select(start, end);
                _this.setCurrentInsertTd(0 /* None */);
            }, "Format" /* Format */);
        };
        this.startHorizontalResizeTable = function (e) {
            _this.resizingState = 1 /* Horizontal */;
            _this.startResizeTable(e);
        };
        this.startVerticalResizeTable = function (e) {
            _this.resizingState = 2 /* Vertical */;
            _this.startResizeTable(e);
        };
        this.frameAnimateResizeTable = function (e) {
            _this.editor.runAsync(function () { return _this.resizeTable(e); });
        };
        this.resizeTable = function (e) {
            if (_this.currentTd) {
                var rect_1 = roosterjs_editor_dom_1.normalizeRect(_this.currentTd.getBoundingClientRect());
                var newPos_1 = _this.resizingState == 1 /* Horizontal */ ? e.pageY : e.pageX;
                var vtable = new roosterjs_editor_dom_1.VTable(_this.currentTd);
                if (_this.resizingState == 1 /* Horizontal */) {
                    vtable.table.style.height = null;
                    vtable.forEachCellOfCurrentRow(function (cell) {
                        if (cell.td) {
                            cell.td.style.height =
                                cell.td == _this.currentTd ? newPos_1 - rect_1.top + "px" : null;
                        }
                    });
                }
                else {
                    vtable.table.style.width = '';
                    vtable.table.width = '';
                    vtable.forEachCellOfCurrentColumn(function (cell) {
                        if (cell.td) {
                            cell.td.style.width =
                                cell.td == _this.currentTd ? newPos_1 - rect_1.left + "px" : null;
                        }
                    });
                }
                vtable.writeBack();
            }
        };
        this.endResizeTable = function (e) {
            var doc = _this.editor.getDocument();
            doc.removeEventListener('mousemove', _this.frameAnimateResizeTable, true);
            doc.removeEventListener('mouseup', _this.endResizeTable, true);
            _this.editor.addUndoSnapshot(function (start, end) {
                _this.frameAnimateResizeTable(e);
                _this.editor.select(start, end);
            }, "Format" /* Format */);
            _this.setCurrentTd(null);
            _this.resizingState = 0 /* None */;
        };
    }
    /**
     * Get a friendly name of  this plugin
     */
    TableResize.prototype.getName = function () {
        return 'TableResize';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    TableResize.prototype.initialize = function (editor) {
        this.editor = editor;
        this.setupResizerContainer();
        this.onMouseMoveDisposer = this.editor.addDomEventHandler('mousemove', this.onMouseMove);
    };
    /**
     * Dispose this plugin
     */
    TableResize.prototype.dispose = function () {
        this.onMouseMoveDisposer();
        this.destoryRectMap();
        this.removeResizerContainer();
        this.editor = null;
    };
    /**
    * Handle events triggered from editor
    * @param event PluginEvent object
    */
    TableResize.prototype.onPluginEvent = function (e) {
        switch (e.eventType) {
            case 12 /* Input */:
            case 6 /* ContentChanged */:
            case 15 /* Scroll */:
                this.destoryRectMap();
                break;
        }
    };
    TableResize.prototype.setupResizerContainer = function () {
        this.resizerContainer = this.editor.getDocument().createElement('div');
        this.editor.insertNode(this.resizerContainer, {
            updateCursor: false,
            insertOnNewLine: false,
            replaceSelection: false,
            position: 4 /* Outside */,
        });
    };
    TableResize.prototype.removeResizerContainer = function () {
        this.resizerContainer.parentNode.removeChild(this.resizerContainer);
        this.resizerContainer = null;
    };
    TableResize.prototype.setCurrentInsertTd = function (insertingState, td, tableRect) {
        if (td != this.currentInsertTd || insertingState != this.insertingState) {
            if (this.currentInsertTd) {
                this.resizerContainer.removeChild(this.inserter);
                this.inserter = null;
            }
            this.insertingState = insertingState;
            this.currentInsertTd = td;
            if (this.currentInsertTd) {
                this.inserter = this.createInserter(tableRect);
                this.resizerContainer.appendChild(this.inserter);
            }
        }
    };
    TableResize.prototype.createInserter = function (tableRect) {
        var rect = roosterjs_editor_dom_1.normalizeRect(this.currentInsertTd.getBoundingClientRect());
        var editorBackgroundColor = this.editor.getDefaultFormat().backgroundColor;
        var inserterBackgroundColor = editorBackgroundColor || 'white';
        var HORIZONTAL_INSERTER_HTML = "<div style=\"position: fixed; width: " + INSERTER_SIDE_LENGTH + "px; height: " + INSERTER_SIDE_LENGTH + "px; font-size: 16px; color: " + INSERTER_COLOR + "; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid " + INSERTER_BORDER_SIZE + "px " + INSERTER_COLOR + "; border-radius: 50%; background-color: " + inserterBackgroundColor + "\"><div style=\"position: absolute; left: 12px; top: 5px; height: 3px; border-top: 1px solid " + INSERTER_COLOR + "; border-bottom: 1px solid " + INSERTER_COLOR + "; border-right: 1px solid " + INSERTER_COLOR + "; border-left: 0px; box-sizing: border-box; background-color: " + inserterBackgroundColor + ";\"></div>+</div>";
        var VERTICAL_INSERTER_HTML = "<div style=\"position: fixed; width: " + INSERTER_SIDE_LENGTH + "px; height: " + INSERTER_SIDE_LENGTH + "px; font-size: 16px; color: " + INSERTER_COLOR + "; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid " + INSERTER_BORDER_SIZE + "px " + INSERTER_COLOR + "; border-radius: 50%; background-color: " + inserterBackgroundColor + "\"><div style=\"position: absolute; left: 5px; top: 12px; width: 3px; border-left: 1px solid " + INSERTER_COLOR + "; border-right: 1px solid " + INSERTER_COLOR + "; border-bottom: 1px solid " + INSERTER_COLOR + "; border-top: 0px; box-sizing: border-box; background-color: " + inserterBackgroundColor + ";\"></div>+</div>";
        var inserter = roosterjs_editor_dom_1.fromHtml(this.insertingState == 1 /* Horizontal */
            ? HORIZONTAL_INSERTER_HTML
            : VERTICAL_INSERTER_HTML, this.editor.getDocument())[0];
        if (this.insertingState == 1 /* Horizontal */) {
            inserter.style.left = rect.left -
                (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE) + "px";
            inserter.style.top = rect.bottom - 8 + "px";
            inserter.firstChild.style.width = tableRect.right -
                tableRect.left + "px";
        }
        else {
            inserter.style.left = rect.right - 8 + "px";
            inserter.style.top = rect.top -
                (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE) + "px";
            inserter.firstChild.style.height = tableRect.bottom -
                tableRect.top + "px";
        }
        inserter.addEventListener('click', this.insertTd);
        return inserter;
    };
    TableResize.prototype.setCurrentTable = function (table, rect) {
        if (this.currentTable != table) {
            this.setCurrentTd(null);
            this.setCurrentInsertTd(null);
            this.currentTable = table;
        }
    };
    TableResize.prototype.setCurrentTd = function (td, tableRect, right, bottom) {
        if (this.currentTd != td) {
            if (this.currentTd) {
                this.resizerContainer.removeChild(this.horizontalResizer);
                this.resizerContainer.removeChild(this.verticalResizer);
                this.horizontalResizer = null;
                this.verticalResizer = null;
            }
            this.currentTd = td;
            if (this.currentTd) {
                this.horizontalResizer = this.createResizer(true /*horizontal*/, tableRect.left, bottom - CELL_RESIZER_WIDTH + 1, tableRect.right - tableRect.left, CELL_RESIZER_WIDTH);
                this.verticalResizer = this.createResizer(false /*horizontal*/, right - CELL_RESIZER_WIDTH + 1, tableRect.top, CELL_RESIZER_WIDTH, tableRect.bottom - tableRect.top);
                this.resizerContainer.appendChild(this.horizontalResizer);
                this.resizerContainer.appendChild(this.verticalResizer);
            }
        }
    };
    TableResize.prototype.createResizer = function (horizontal, left, top, width, height) {
        var div = roosterjs_editor_dom_1.fromHtml(horizontal ? HORIZONTAL_RESIZER_HTML : VERTICAL_RESIZER_HTML, this.editor.getDocument())[0];
        div.style.top = top + "px";
        div.style.left = left + "px";
        div.style.width = width + "px";
        div.style.height = height + "px";
        div.addEventListener('mousedown', horizontal ? this.startHorizontalResizeTable : this.startVerticalResizeTable);
        return div;
    };
    TableResize.prototype.startResizeTable = function (e) {
        var doc = this.editor.getDocument();
        doc.addEventListener('mousemove', this.frameAnimateResizeTable, true);
        doc.addEventListener('mouseup', this.endResizeTable, true);
    };
    TableResize.prototype.destoryRectMap = function () {
        this.setCurrentTable(null);
        this.tableRectMap = null;
    };
    TableResize.prototype.cacheRects = function () {
        var _this = this;
        this.destoryRectMap();
        this.tableRectMap = [];
        this.editor.queryElements('table', function (table) {
            var rect = roosterjs_editor_dom_1.normalizeRect(table.getBoundingClientRect());
            if (rect) {
                _this.tableRectMap.push({
                    table: table,
                    rect: rect,
                });
            }
        });
    };
    return TableResize;
}());
exports.default = TableResize;
//# sourceMappingURL=TableResize.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/TableResize/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/TableResize/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TableResize_1 = __webpack_require__(/*! ./TableResize */ "./node_modules/roosterjs-editor-plugins/lib/plugins/TableResize/TableResize.js");
exports.TableResize = TableResize_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Watermark/Watermark.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Watermark/Watermark.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var WATERMARK_SPAN_ID = '_rooster_watermarkSpan';
var WATERMARK_REGEX = new RegExp("<span[^>]*id=['\"]?" + WATERMARK_SPAN_ID + "['\"]?[^>]*>[^<]*</span>", 'ig');
var SPELLCHECK_ATTR_NAME = 'spellcheck';
/**
 * A watermark plugin to manage watermark string for roosterjs
 */
var Watermark = /** @class */ (function () {
    /**
     * Create an instance of Watermark plugin
     * @param watermark The watermark string
     */
    function Watermark(watermark, format) {
        var _this = this;
        this.watermark = watermark;
        this.format = format;
        this.handleWatermark = function () {
            _this.showHideWatermark(false /*ignoreCachedState*/);
        };
        this.format = this.format || {
            fontSize: '14px',
            textColor: '#aaa',
        };
    }
    /**
     * Get a friendly name of  this plugin
     */
    Watermark.prototype.getName = function () {
        return 'Watermark';
    };
    /**
     * Initialize this plugin. This should only be called from Editor
     * @param editor Editor instance
     */
    Watermark.prototype.initialize = function (editor) {
        this.editor = editor;
        this.disposer = this.editor.addDomEventHandler({
            focus: this.handleWatermark,
            blur: this.handleWatermark,
        });
        this.spellcheckInitialValue = this.editor.getEditorDomAttribute(SPELLCHECK_ATTR_NAME);
    };
    /**
     * Dispose this plugin
     */
    Watermark.prototype.dispose = function () {
        this.disposer();
        this.disposer = null;
        this.hideWatermark();
        this.editor = null;
    };
    /**
     * Handle events triggered from editor
     * @param event PluginEvent object
     */
    Watermark.prototype.onPluginEvent = function (event) {
        if (event.eventType == 10 /* EditorReady */) {
            this.showHideWatermark(false /*ignoreCachedState*/);
        }
        else if (event.eventType == 6 /* ContentChanged */) {
            // When content is changed from setContent() API, current cached state
            // may not be accurate, so we ignore it
            this.showHideWatermark(event.source == "SetContent" /* SetContent */);
        }
        else if (event.eventType == 7 /* ExtractContent */ && this.isWatermarkShowing) {
            this.removeWartermarkFromHtml(event);
        }
    };
    Watermark.prototype.showHideWatermark = function (ignoreCachedState) {
        if (this.editor.hasFocus() && (ignoreCachedState || this.isWatermarkShowing)) {
            this.hideWatermark();
            this.editor.focus();
        }
        else if (!this.editor.hasFocus() &&
            (ignoreCachedState || !this.isWatermarkShowing) &&
            this.editor.isEmpty(true /*trim*/)) {
            this.showWatermark();
        }
    };
    Watermark.prototype.showWatermark = function () {
        var document = this.editor.getDocument();
        var watermarkNode = roosterjs_editor_dom_1.wrap(document.createTextNode(this.watermark), "<span id=\"" + WATERMARK_SPAN_ID + "\"></span>");
        roosterjs_editor_dom_1.applyFormat(watermarkNode, this.format, this.editor.isDarkMode());
        this.editor.insertNode(watermarkNode, {
            position: 0 /* Begin */,
            updateCursor: false,
            replaceSelection: false,
            insertOnNewLine: false,
        });
        this.editor.setEditorDomAttribute(SPELLCHECK_ATTR_NAME, 'false');
        this.isWatermarkShowing = true;
    };
    Watermark.prototype.hideWatermark = function () {
        var _this = this;
        this.editor.queryElements("span[id=\"" + WATERMARK_SPAN_ID + "\"]", function (span) {
            var parentNode = span.parentNode;
            _this.editor.deleteNode(span);
            // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line
            if (_this.editor.contains(parentNode) &&
                roosterjs_editor_dom_1.getTagOfNode(parentNode) == 'DIV' &&
                !parentNode.firstChild) {
                parentNode.appendChild(_this.editor.getDocument().createElement('BR'));
            }
        });
        this.editor.setEditorDomAttribute(SPELLCHECK_ATTR_NAME, this.spellcheckInitialValue);
        this.isWatermarkShowing = false;
    };
    Watermark.prototype.removeWartermarkFromHtml = function (event) {
        var content = event.content;
        content = content.replace(WATERMARK_REGEX, '');
        event.content = content;
    };
    return Watermark;
}());
exports.default = Watermark;
//# sourceMappingURL=Watermark.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-plugins/lib/plugins/Watermark/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-plugins/lib/plugins/Watermark/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Watermark_1 = __webpack_require__(/*! ./Watermark */ "./node_modules/roosterjs-editor-plugins/lib/plugins/Watermark/Watermark.js");
exports.Watermark = Watermark_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/browser/DocumentCommand.js":
/*!****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/browser/DocumentCommand.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Command strings for Document.execCommand() API
 * https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand
 */
var DocumentCommand;
(function (DocumentCommand) {
    /**
     * Changes the browser auto-link behavior (Internet Explorer only)
     */
    DocumentCommand["AutoUrlDetect"] = "AutoUrlDetect";
    /**
     * Changes the document background color. In styleWithCss mode, it affects the background color of the containing block instead.
     * This requires a &lt;color&gt; value string to be passed in as a value argument. Note that Internet Explorer uses this to set the
     * text background color.
     */
    DocumentCommand["BackColor"] = "backColor";
    /**
     * Toggles bold on/off for the selection or at the insertion point. Internet Explorer uses the &lt;strong&gt; tag instead of &lt;b&gt;.
     */
    DocumentCommand["Bold"] = "bold";
    /**
     * Clears all authentication credentials from the cache.
     */
    DocumentCommand["ClearAuthenticationCache"] = "ClearAuthenticationCache";
    /**
     * Makes the content document either read-only or editable. This requires a boolean true/false as the value argument.
     * (Not supported by Internet Explorer.)
     */
    DocumentCommand["ContentReadOnly"] = "contentReadOnly";
    /**
     * Copies the current selection to the clipboard. Conditions of having this behavior enabled vary from one browser to another,
     * and have evolved over time. Check the compatibility table to determine if you can use it in your case.
     */
    DocumentCommand["Copy"] = "copy";
    /**
     * Creates an hyperlink from the selection, but only if there is a selection. Requires a URI string as a value argument for the
     * hyperlink's href. The URI must contain at least a single character, which may be whitespace.
     * (Internet Explorer will create a link with a null value.)
     */
    DocumentCommand["CreateLink"] = "createLink";
    /**
     * Removes the current selection and copies it to the clipboard. When this behavior is enabled varies between browsers,
     * and its conditions have evolved over time. Check the compatibility table for usage details.
     */
    DocumentCommand["Cut"] = "cut";
    /**
     * Adds a &lt;small&gt; tag around the selection or at the insertion point. (Not supported by Internet Explorer.)
     */
    DocumentCommand["DecreaseFontSize"] = "decreaseFontSize";
    /**
     * Changes the paragraph separator used when new paragraphs are created in editable text regions. See Differences in markup
     * generation for more details.
     */
    DocumentCommand["DefaultParagraphSeparator"] = "defaultParagraphSeparator";
    /**
     * Deletes the current selection.
     */
    DocumentCommand["Delete"] = "delete";
    /**
     * Enables or disables the table row/column insertion and deletion controls. (Not supported by Internet Explorer.)
     */
    DocumentCommand["EnableInlineTableEditing"] = "enableInlineTableEditing";
    /**
     * Enables or disables the resize handles on images and other resizable objects. (Not supported by Internet Explorer.)
     */
    DocumentCommand["EnableObjectResizing"] = "enableObjectResizing";
    /**
     * Changes the font name for the selection or at the insertion point. This requires a font name string (like "Arial")
     * as a value argument.
     */
    DocumentCommand["FontName"] = "fontName";
    /**
     * Changes the font size for the selection or at the insertion point. This requires an integer from 1-7 as a value argument.
     */
    DocumentCommand["FontSize"] = "fontSize";
    /**
     * Changes a font color for the selection or at the insertion point. This requires a hexidecimal color value string
     * as a value argument.
     */
    DocumentCommand["ForeColor"] = "foreColor";
    /**
     * Adds an HTML block-level element around the line containing the current selection, replacing the block element containing
     * the line if one exists (in Firefox, &lt;blockquote&gt; is the exception  it will wrap any containing block element).
     * Requires a tag-name string as a value argument. Virtually all block-level elements can be used.
     * (Internet Explorer supports only heading tags H1H6, ADDRESS, and PRE, which must be wrapped in angle brackets, such as "&lt;H1&gt;".)
     */
    DocumentCommand["FormatBlock"] = "formatBlock";
    /**
     * Deletes the character ahead of the cursor's position, identical to hitting the Delete key on a Windows keyboard.
     */
    DocumentCommand["ForwardDelete"] = "forwardDelete";
    /**
     * Adds a heading element around a selection or insertion point line. Requires the tag-name stringas a value argument (i.e. "H1", "H6").
     * (Not supported by Internet Explorer and Safari.)
     */
    DocumentCommand["Heading"] = "heading";
    /**
     * Changes the background color for the selection or at the insertion point. Requires a color value string as a value argument.
     * useCSS must be true for this to function. (Not supported by Internet Explorer.)
     */
    DocumentCommand["HiliteColor"] = "hiliteColor";
    /**
     * Adds a &lt;big&gt; tag around the selection or at the insertion point. (Not supported by Internet Explorer.)
     */
    DocumentCommand["IncreaseFontSize"] = "increaseFontSize";
    /**
     * Indents the line containing the selection or insertion point. In Firefox, if the selection spans multiple lines at different
     * levels of indentation, only the least indented lines in the selection will be indented.
     */
    DocumentCommand["Indent"] = "indent";
    /**
     * Controls whether the Enter key inserts a &lt;br&gt; element, or splits the current block element into two.
     * (Not supported by Internet Explorer.)
     */
    DocumentCommand["InsertBrOnReturn"] = "insertBrOnReturn";
    /**
     * Inserts a &lt;hr&gt; element at the insertion point, or replaces the selection with it.
     */
    DocumentCommand["InsertHorizontalRule"] = "insertHorizontalRule";
    /**
     * Inserts an HTML string at the insertion point (deletes selection). Requires a valid HTML string as a value argument.
     * (Not supported by Internet Explorer.)
     */
    DocumentCommand["InsertHTML"] = "insertHTML";
    /**
     * Inserts an image at the insertion point (deletes selection). Requires a URL string for the image's src as a value argument.
     * The requirements for this string are the same as createLink.
     */
    DocumentCommand["InsertImage"] = "insertImage";
    /**
     * Creates a numbered ordered list for the selection or at the insertion point.
     */
    DocumentCommand["InsertOrderedList"] = "insertOrderedList";
    /**
     * Creates a bulleted unordered list for the selection or at the insertion point.
     */
    DocumentCommand["InsertUnorderedList"] = "insertUnorderedList";
    /**
     * Inserts a paragraph around the selection or the current line.
     * (Internet Explorer inserts a paragraph at the insertion point and deletes the selection.)
     */
    DocumentCommand["InsertParagraph"] = "insertParagraph";
    /**
     * Inserts the given plain text at the insertion point (deletes selection).
     */
    DocumentCommand["InsertText"] = "insertText";
    /**
     * Toggles italics on/off for the selection or at the insertion point.
     * (Internet Explorer uses the &lt;em&gt; element instead of &lt;i&gt;.)
     */
    DocumentCommand["Italic"] = "italic";
    /**
     * Centers the selection or insertion point.
     */
    DocumentCommand["JustifyCenter"] = "justifyCenter";
    /**
     * Justifies the selection or insertion point.
     */
    DocumentCommand["JustifyFull"] = "justifyFull";
    /**
     * Justifies the selection or insertion point to the left.
     */
    DocumentCommand["JustifyLeft"] = "justifyLeft";
    /**
     * Right-justifies the selection or the insertion point.
     */
    DocumentCommand["JustifyRight"] = "justifyRight";
    /**
     * Outdents the line containing the selection or insertion point.
     */
    DocumentCommand["Outdent"] = "outdent";
    /**
     * Pastes the clipboard contents at the insertion point (replaces current selection). Disabled for web content. See [1].
     */
    DocumentCommand["Paste"] = "paste";
    /**
     * Redoes the previous undo command.
     */
    DocumentCommand["Redo"] = "redo";
    /**
     * Removes all formatting from the current selection.
     */
    DocumentCommand["RemoveFormat"] = "removeFormat";
    /**
     * Selects all of the content of the editable region.
     */
    DocumentCommand["SelectAll"] = "selectAll";
    /**
     * Toggles strikethrough on/off for the selection or at the insertion point.
     */
    DocumentCommand["StrikeThrough"] = "strikeThrough";
    /**
     * Toggles subscript on/off for the selection or at the insertion point.
     */
    DocumentCommand["Subscript"] = "subscript";
    /**
     * Toggles superscript on/off for the selection or at the insertion point.
     */
    DocumentCommand["Superscript"] = "superscript";
    /**
     * Toggles underline on/off for the selection or at the insertion point.
     */
    DocumentCommand["Underline"] = "underline";
    /**
     * Undoes the last executed command.
     */
    DocumentCommand["Undo"] = "undo";
    /**
     * Removes the anchor element from a selected hyperlink.
     */
    DocumentCommand["Unlink"] = "unlink";
    /**
     * Replaces the useCSS command. true modifies/generates style attributes in markup, false generates presentational elements.
     */
    DocumentCommand["StyleWithCSS"] = "styleWithCSS";
})(DocumentCommand = exports.DocumentCommand || (exports.DocumentCommand = {}));
//# sourceMappingURL=DocumentCommand.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/browser/DocumentPosition.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/browser/DocumentPosition.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The is essentially an enum representing result from browser compareDocumentPosition API
 * https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
 */
var DocumentPosition;
(function (DocumentPosition) {
    /**
     * Same node
     */
    DocumentPosition[DocumentPosition["Same"] = 0] = "Same";
    /**
     * Node is disconnected from document
     */
    DocumentPosition[DocumentPosition["Disconnected"] = 1] = "Disconnected";
    /**
     * Node is preceding the comparing node
     */
    DocumentPosition[DocumentPosition["Preceding"] = 2] = "Preceding";
    /**
     * Node is following the comparing node
     */
    DocumentPosition[DocumentPosition["Following"] = 4] = "Following";
    /**
     * Node contains the comparing node
     */
    DocumentPosition[DocumentPosition["Contains"] = 8] = "Contains";
    /**
     * Node is contained by the comparing node
     */
    DocumentPosition[DocumentPosition["ContainedBy"] = 16] = "ContainedBy";
})(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
//# sourceMappingURL=DocumentPosition.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/browser/NodeType.js":
/*!*********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/browser/NodeType.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The is essentially an enum represents the type of the node
 * https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
 * Values not listed here are deprecated.
 */
var NodeType;
(function (NodeType) {
    /**
     * An Element node such as &lt;p&gt; or &lt;div&gt;.
     */
    NodeType[NodeType["Element"] = 1] = "Element";
    /**
     * The actual Text of Element or Attr.
     */
    NodeType[NodeType["Text"] = 3] = "Text";
    /**
     * A ProcessingInstruction of an XML document such as &lt;?xml-stylesheet ... ?&gt; declaration.
     */
    NodeType[NodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
    /**
     * A Comment node.
     */
    NodeType[NodeType["Comment"] = 8] = "Comment";
    /**
     * A Document node.
     */
    NodeType[NodeType["Document"] = 9] = "Document";
    /**
     * A DocumentType node e.g. &lt;!DOCTYPE html&gt; for HTML5 documents.
     */
    NodeType[NodeType["DocumentType"] = 10] = "DocumentType";
    /**
     * A DocumentFragment node.
     */
    NodeType[NodeType["DocumentFragment"] = 11] = "DocumentFragment";
})(NodeType = exports.NodeType || (exports.NodeType = {}));
//# sourceMappingURL=NodeType.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/Alignment.js":
/*!*******************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/Alignment.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * enum for setting block alignment, used by setAlignment API
 */
var Alignment;
(function (Alignment) {
    /**
     * Align left
     */
    Alignment[Alignment["Left"] = 0] = "Left";
    /**
     * Align center
     */
    Alignment[Alignment["Center"] = 1] = "Center";
    /**
     * Align right
     */
    Alignment[Alignment["Right"] = 2] = "Right";
})(Alignment = exports.Alignment || (exports.Alignment = {}));
//# sourceMappingURL=Alignment.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/ChangeSource.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/ChangeSource.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Possible change sources. Here are the predefined sources.
 * It can also be other string if the change source can't fall into these sources.
 */
var ChangeSource;
(function (ChangeSource) {
    /**
     * Content changed by auto link
     */
    ChangeSource["AutoLink"] = "AutoLink";
    /**
     * Content changed by create link
     */
    ChangeSource["CreateLink"] = "CreateLink";
    /**
     * Content changed by format
     */
    ChangeSource["Format"] = "Format";
    /**
     * Content changed by image resize
     */
    ChangeSource["ImageResize"] = "ImageResize";
    /**
     * Content changed by paste
     */
    ChangeSource["Paste"] = "Paste";
    /**
     * Content changed by setContent API
     */
    ChangeSource["SetContent"] = "SetContent";
    /**
     * Content changed by cut operation
     */
    ChangeSource["Cut"] = "Cut";
    /**
     * Content changed by drag & drop operation
     */
    ChangeSource["Drop"] = "Drop";
    /**
     * Insert a new entity into editor
     */
    ChangeSource["InsertEntity"] = "InsertEntity";
})(ChangeSource = exports.ChangeSource || (exports.ChangeSource = {}));
//# sourceMappingURL=ChangeSource.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/ContentPosition.js":
/*!*************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/ContentPosition.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The position. Mostly used for content insertion and traversing
 * On insertion, we will need to specify where we want the content to be placed (begin, end, selection or outside)
 * On content traversing, we will need to specify the start position of traversing
 */
var ContentPosition;
(function (ContentPosition) {
    /**
     * Begin of the container
     */
    ContentPosition[ContentPosition["Begin"] = 0] = "Begin";
    /**
     * End of the container
     */
    ContentPosition[ContentPosition["End"] = 1] = "End";
    /**
     * End of the content div domain.
     */
    ContentPosition[ContentPosition["DomEnd"] = 2] = "DomEnd";
    /**
     * Selection start
     */
    ContentPosition[ContentPosition["SelectionStart"] = 3] = "SelectionStart";
    /**
     * Outside of editor
     */
    ContentPosition[ContentPosition["Outside"] = 4] = "Outside";
    /**
     * Manually defined range
     */
    ContentPosition[ContentPosition["Range"] = 5] = "Range";
})(ContentPosition = exports.ContentPosition || (exports.ContentPosition = {}));
//# sourceMappingURL=ContentPosition.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/Direction.js":
/*!*******************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/Direction.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * enum for setting block direction, used by setDirection API
 */
var Direction;
(function (Direction) {
    /**
     * Left to right
     */
    Direction[Direction["LeftToRight"] = 0] = "LeftToRight";
    /**
     * Right to left
     */
    Direction[Direction["RightToLeft"] = 1] = "RightToLeft";
})(Direction = exports.Direction || (exports.Direction = {}));
//# sourceMappingURL=Direction.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/EntityOperation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/EntityOperation.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Define possible operations to an entity
 */
var EntityOperation;
(function (EntityOperation) {
    /**
     * Notify plugins that there is a new plugin was added into editor.
     * Plugin can handle this event to entity hydration.
     * This event will be only fired once for each entity DOM node.
     * After undo, or copy/paste, since new DOM nodes were added, this event will be fired
     * for those entites represented by newly added nodes.
     */
    EntityOperation[EntityOperation["NewEntity"] = 0] = "NewEntity";
    /**
     * Notify plugins that user is clicking target to an entity
     */
    EntityOperation[EntityOperation["Click"] = 1] = "Click";
    /**
     * Notify plugins that user is triggering context menu to an entity
     */
    EntityOperation[EntityOperation["ContextMenu"] = 2] = "ContextMenu";
    /**
     * Notify plugins that user is escaping from an entity by pressing ESC key
     */
    EntityOperation[EntityOperation["Escape"] = 3] = "Escape";
    /**
     * Notify plugins that user is removing an entity from its start position using DELETE key
     */
    EntityOperation[EntityOperation["RemoveFromStart"] = 4] = "RemoveFromStart";
    /**
     * Notify plugins that user is remove an entity from its end position using BACKSPACE key
     */
    EntityOperation[EntityOperation["RemoveFromEnd"] = 5] = "RemoveFromEnd";
    /**
     * Notify plugins that an entity is being overwritten.
     * This can be causes by key in, cut, paste, delete, backspace ... on a selection
     * which contains some entites.
     */
    EntityOperation[EntityOperation["Overwrite"] = 6] = "Overwrite";
    /**
     * Notify plugins that an entity is being partially overwritten.
     * This happens when user selected part of the entity then do key press, or cut, paste, delete, backspace, ...
     */
    EntityOperation[EntityOperation["PartialOverwrite"] = 7] = "PartialOverwrite";
    /**
     * Notify plugins that editor is generating HTML content for save.
     * Plugin should use this event to remove any temporary content, and only leave DOM nodes that
     * should be saved as HTML string.
     * This event will provide a cloned DOM tree for each entity, do NOT compare the DOM nodes with cached nodes
     * because it will always return false.
     */
    EntityOperation[EntityOperation["ReplaceTemporaryContent"] = 8] = "ReplaceTemporaryContent";
})(EntityOperation = exports.EntityOperation || (exports.EntityOperation = {}));
//# sourceMappingURL=EntityOperation.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/FontSizeChange.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/FontSizeChange.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The enum used for increase or decrease font size
 * Used by setFontSize API
 */
var FontSizeChange;
(function (FontSizeChange) {
    /**
     * Increase font size
     */
    FontSizeChange[FontSizeChange["Increase"] = 0] = "Increase";
    /**
     * Decrease font size
     */
    FontSizeChange[FontSizeChange["Decrease"] = 1] = "Decrease";
})(FontSizeChange = exports.FontSizeChange || (exports.FontSizeChange = {}));
//# sourceMappingURL=FontSizeChange.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/Indentation.js":
/*!*********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/Indentation.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The enum used for increase or decrease indentation of a block
 * Used by setIndentation API
 */
var Indentation;
(function (Indentation) {
    /**
     * Increase indentation
     */
    Indentation[Indentation["Increase"] = 0] = "Increase";
    /**
     * Decrease indentation
     */
    Indentation[Indentation["Decrease"] = 1] = "Decrease";
})(Indentation = exports.Indentation || (exports.Indentation = {}));
//# sourceMappingURL=Indentation.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/ListType.js":
/*!******************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/ListType.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Type of list (numbering or bullet)
 */
var ListType;
(function (ListType) {
    /**
     * None list type
     * It means this is not a list
     */
    ListType[ListType["None"] = 0] = "None";
    /**
     * Ordered List type (numbering list)
     * Represented by "OL" tag
     */
    ListType[ListType["Ordered"] = 1] = "Ordered";
    /**
     * Unordered List type (bullet list)
     * Represented by "UL" tag
     */
    ListType[ListType["Unordered"] = 2] = "Unordered";
})(ListType = exports.ListType || (exports.ListType = {}));
//# sourceMappingURL=ListType.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/PasteOption.js":
/*!*********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/PasteOption.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Paste option
 */
var PasteOption;
(function (PasteOption) {
    /**
     * Paste html with content type "text/html"
     */
    PasteOption[PasteOption["PasteHtml"] = 0] = "PasteHtml";
    /**
     * Paste plain text with content type "text/plain"
     */
    PasteOption[PasteOption["PasteText"] = 1] = "PasteText";
    /**
     * Paste image from clipboard with content type "image/*"
     */
    PasteOption[PasteOption["PasteImage"] = 2] = "PasteImage";
})(PasteOption = exports.PasteOption || (exports.PasteOption = {}));
//# sourceMappingURL=PasteOption.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/PositionType.js":
/*!**********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/PositionType.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represent the type of a position
 */
var PositionType;
(function (PositionType) {
    /**
     * At the begninning of a node
     */
    PositionType[PositionType["Begin"] = 0] = "Begin";
    /**
     * At the endo of a node
     */
    PositionType[PositionType["End"] = -1] = "End";
    /**
     * Before a node
     */
    PositionType[PositionType["Before"] = -2] = "Before";
    /**
     * After a node
     */
    PositionType[PositionType["After"] = -3] = "After";
})(PositionType = exports.PositionType || (exports.PositionType = {}));
//# sourceMappingURL=PositionType.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/QueryScope.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/QueryScope.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Query scope for queryElements() API
 */
var QueryScope;
(function (QueryScope) {
    /**
     * Query from the whole body of root node. This is default value.
     */
    QueryScope[QueryScope["Body"] = 0] = "Body";
    /**
     * Query elements on a given selction (intersect)
     * The result element can contain the selection, contain part of selection, or inside selection
     */
    QueryScope[QueryScope["OnSelection"] = 1] = "OnSelection";
    /**
     * Query elements inside a given selection only
     */
    QueryScope[QueryScope["InSelection"] = 2] = "InSelection";
})(QueryScope = exports.QueryScope || (exports.QueryScope = {}));
//# sourceMappingURL=QueryScope.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/RegionType.js":
/*!********************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/RegionType.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Type of all possible regions. Currently we only support region of Table
 */
var RegionType;
(function (RegionType) {
    /**
     * Region splitted by Table
     */
    RegionType[RegionType["Table"] = 0] = "Table";
})(RegionType = exports.RegionType || (exports.RegionType = {}));
//# sourceMappingURL=RegionType.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/enum/TableOperation.js":
/*!************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/enum/TableOperation.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Operations used by editTable() API
 */
var TableOperation;
(function (TableOperation) {
    /**
     * Insert a row above current row
     */
    TableOperation[TableOperation["InsertAbove"] = 0] = "InsertAbove";
    /**
     * Insert a row below current row
     */
    TableOperation[TableOperation["InsertBelow"] = 1] = "InsertBelow";
    /**
     * Insert a column on the left of current column
     */
    TableOperation[TableOperation["InsertLeft"] = 2] = "InsertLeft";
    /**
     * Insert a column on the right of current column
     */
    TableOperation[TableOperation["InsertRight"] = 3] = "InsertRight";
    /**
     * Delete the whole table
     */
    TableOperation[TableOperation["DeleteTable"] = 4] = "DeleteTable";
    /**
     * Delete current column
     */
    TableOperation[TableOperation["DeleteColumn"] = 5] = "DeleteColumn";
    /**
     * Delete current row
     */
    TableOperation[TableOperation["DeleteRow"] = 6] = "DeleteRow";
    /**
     * Merge current row with the row above
     */
    TableOperation[TableOperation["MergeAbove"] = 7] = "MergeAbove";
    /**
     * Merge current row with the row below
     */
    TableOperation[TableOperation["MergeBelow"] = 8] = "MergeBelow";
    /**
     * Merge current column with the column on the left
     */
    TableOperation[TableOperation["MergeLeft"] = 9] = "MergeLeft";
    /**
     * Merge current column with the column on the right
     */
    TableOperation[TableOperation["MergeRight"] = 10] = "MergeRight";
    /**
     * Split current table cell horizontally
     */
    TableOperation[TableOperation["SplitHorizontally"] = 11] = "SplitHorizontally";
    /**
     * Split current table cell vertically
     */
    TableOperation[TableOperation["SplitVertically"] = 12] = "SplitVertically";
})(TableOperation = exports.TableOperation || (exports.TableOperation = {}));
//# sourceMappingURL=TableOperation.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/event/PluginEventType.js":
/*!**************************************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/event/PluginEventType.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Editor plugin event type
 */
var PluginEventType;
(function (PluginEventType) {
    /**
     * HTML KeyDown event
     */
    PluginEventType[PluginEventType["KeyDown"] = 0] = "KeyDown";
    /**
     * HTML KeyPress event
     */
    PluginEventType[PluginEventType["KeyPress"] = 1] = "KeyPress";
    /**
     * HTML KeyUp event
     */
    PluginEventType[PluginEventType["KeyUp"] = 2] = "KeyUp";
    /**
     * HTML CompositionEnd event
     */
    PluginEventType[PluginEventType["CompositionEnd"] = 3] = "CompositionEnd";
    /**
     * HTML MouseDown event
     */
    PluginEventType[PluginEventType["MouseDown"] = 4] = "MouseDown";
    /**
     * HTML MouseUp event
     */
    PluginEventType[PluginEventType["MouseUp"] = 5] = "MouseUp";
    /**
     * Content changed event
     */
    PluginEventType[PluginEventType["ContentChanged"] = 6] = "ContentChanged";
    /**
     * @deprecated Use ExtractContentWithDom instead.
     * Extract Content event
     * This event is triggered when getContent() is called with triggerExtractContentEvent = true
     * Plugin can handle this event to remove the UI only markups to return clean HTML
     */
    PluginEventType[PluginEventType["ExtractContent"] = 7] = "ExtractContent";
    /**
     * Extract Content with a DOM tree event
     * This event is triggered when getContent() is called with triggerExtractContentEvent = true
     * Plugin can handle this event to remove the UI only markups to return clean HTML
     * by operating on a cloned DOM tree
     */
    PluginEventType[PluginEventType["ExtractContentWithDom"] = 8] = "ExtractContentWithDom";
    /**
     * Before Paste event, provide a chance to change paste content
     */
    PluginEventType[PluginEventType["BeforePaste"] = 9] = "BeforePaste";
    /**
     * Let plugin know editor is ready now
     */
    PluginEventType[PluginEventType["EditorReady"] = 10] = "EditorReady";
    /**
     * Let plugin know editor is about to dispose
     */
    PluginEventType[PluginEventType["BeforeDispose"] = 11] = "BeforeDispose";
    /**
     * HTML Input / TextInput event
     */
    PluginEventType[PluginEventType["Input"] = 12] = "Input";
    /**
     * Pending format state (bold, italic, underline, ... with collapsed selection) is changed
     */
    PluginEventType[PluginEventType["PendingFormatStateChanged"] = 13] = "PendingFormatStateChanged";
    /**
     * Dark mode state is changed
     */
    PluginEventType[PluginEventType["DarkModeChanged"] = 14] = "DarkModeChanged";
    /**
     * Scroll event triggered by scroll container
     */
    PluginEventType[PluginEventType["Scroll"] = 15] = "Scroll";
    /**
     * Operating on an entity. See enum EntityOperation for more details about each operation
     */
    PluginEventType[PluginEventType["EntityOperation"] = 16] = "EntityOperation";
})(PluginEventType = exports.PluginEventType || (exports.PluginEventType = {}));
//# sourceMappingURL=PluginEventType.js.map

/***/ }),

/***/ "./node_modules/roosterjs-editor-types/lib/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/roosterjs-editor-types/lib/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DocumentCommand_1 = __webpack_require__(/*! ./browser/DocumentCommand */ "./node_modules/roosterjs-editor-types/lib/browser/DocumentCommand.js");
exports.DocumentCommand = DocumentCommand_1.DocumentCommand;
var DocumentPosition_1 = __webpack_require__(/*! ./browser/DocumentPosition */ "./node_modules/roosterjs-editor-types/lib/browser/DocumentPosition.js");
exports.DocumentPosition = DocumentPosition_1.DocumentPosition;
var NodeType_1 = __webpack_require__(/*! ./browser/NodeType */ "./node_modules/roosterjs-editor-types/lib/browser/NodeType.js");
exports.NodeType = NodeType_1.NodeType;
// Enum
var Alignment_1 = __webpack_require__(/*! ./enum/Alignment */ "./node_modules/roosterjs-editor-types/lib/enum/Alignment.js");
exports.Alignment = Alignment_1.Alignment;
var ChangeSource_1 = __webpack_require__(/*! ./enum/ChangeSource */ "./node_modules/roosterjs-editor-types/lib/enum/ChangeSource.js");
exports.ChangeSource = ChangeSource_1.ChangeSource;
var ContentPosition_1 = __webpack_require__(/*! ./enum/ContentPosition */ "./node_modules/roosterjs-editor-types/lib/enum/ContentPosition.js");
exports.ContentPosition = ContentPosition_1.ContentPosition;
var Direction_1 = __webpack_require__(/*! ./enum/Direction */ "./node_modules/roosterjs-editor-types/lib/enum/Direction.js");
exports.Direction = Direction_1.Direction;
var EntityOperation_1 = __webpack_require__(/*! ./enum/EntityOperation */ "./node_modules/roosterjs-editor-types/lib/enum/EntityOperation.js");
exports.EntityOperation = EntityOperation_1.EntityOperation;
var FontSizeChange_1 = __webpack_require__(/*! ./enum/FontSizeChange */ "./node_modules/roosterjs-editor-types/lib/enum/FontSizeChange.js");
exports.FontSizeChange = FontSizeChange_1.FontSizeChange;
var Indentation_1 = __webpack_require__(/*! ./enum/Indentation */ "./node_modules/roosterjs-editor-types/lib/enum/Indentation.js");
exports.Indentation = Indentation_1.Indentation;
var ListType_1 = __webpack_require__(/*! ./enum/ListType */ "./node_modules/roosterjs-editor-types/lib/enum/ListType.js");
exports.ListType = ListType_1.ListType;
var PasteOption_1 = __webpack_require__(/*! ./enum/PasteOption */ "./node_modules/roosterjs-editor-types/lib/enum/PasteOption.js");
exports.PasteOption = PasteOption_1.PasteOption;
var PositionType_1 = __webpack_require__(/*! ./enum/PositionType */ "./node_modules/roosterjs-editor-types/lib/enum/PositionType.js");
exports.PositionType = PositionType_1.PositionType;
var QueryScope_1 = __webpack_require__(/*! ./enum/QueryScope */ "./node_modules/roosterjs-editor-types/lib/enum/QueryScope.js");
exports.QueryScope = QueryScope_1.QueryScope;
var RegionType_1 = __webpack_require__(/*! ./enum/RegionType */ "./node_modules/roosterjs-editor-types/lib/enum/RegionType.js");
exports.RegionType = RegionType_1.RegionType;
var TableOperation_1 = __webpack_require__(/*! ./enum/TableOperation */ "./node_modules/roosterjs-editor-types/lib/enum/TableOperation.js");
exports.TableOperation = TableOperation_1.TableOperation;
var PluginEventType_1 = __webpack_require__(/*! ./event/PluginEventType */ "./node_modules/roosterjs-editor-types/lib/event/PluginEventType.js");
exports.PluginEventType = PluginEventType_1.PluginEventType;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/roosterjs-html-sanitizer/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/roosterjs-html-sanitizer/lib/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// This package is deprecated.
// All exports here are just for backward compatibility.
// Please use type from their real packages directly
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
exports.HtmlSanitizer = roosterjs_editor_dom_1.HtmlSanitizer;
exports.htmlToDom = roosterjs_editor_dom_1.htmlToDom;
exports.splitWithFragment = roosterjs_editor_dom_1.splitWithFragment;
exports.getInheritableStyles = roosterjs_editor_dom_1.getInheritableStyles;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./packages/roosterjs-react-command-bar/lib/components/LinkDialog.scss.g.ts":
/*!**********************************************************************************!*\
  !*** ./packages/roosterjs-react-command-bar/lib/components/LinkDialog.scss.g.ts ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.modal = void 0;
/* tslint:disable */
var load_themed_styles_1 = __webpack_require__(/*! @microsoft/load-themed-styles */ "./node_modules/@microsoft/load-themed-styles/lib-es6/index.js");
load_themed_styles_1.loadStyles([{ "rawString": "div.modal_f58d80d5{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;padding:250px 0 10px;position:static}" }]);
exports.modal = "modal_f58d80d5";


/***/ }),

/***/ "./packages/roosterjs-react-command-bar/lib/components/LinkDialog.tsx":
/*!****************************************************************************!*\
  !*** ./packages/roosterjs-react-command-bar/lib/components/LinkDialog.tsx ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLinkDialog = exports.InsertLinkStringKeys = void 0;
var Styles = __webpack_require__(/*! ./LinkDialog.scss.g */ "./packages/roosterjs-react-command-bar/lib/components/LinkDialog.scss.g.ts");
var Button_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Button */ "office-ui-fabric-react/lib/Button");
var Dialog_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Dialog */ "office-ui-fabric-react/lib/Dialog");
var TextField_1 = __webpack_require__(/*! office-ui-fabric-react/lib/TextField */ "office-ui-fabric-react/lib/TextField");
var Utilities_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Utilities */ "office-ui-fabric-react/lib/Utilities");
var React = __webpack_require__(/*! react */ "react");
var ReactDOM = __webpack_require__(/*! react-dom */ "react-dom");
var roosterjs_editor_api_1 = __webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
exports.InsertLinkStringKeys = {
    LinkFieldLabel: "linkFieldLabel",
    Title: "linkPromptTitle",
    InsertButton: "insertLinkText",
    CancelButton: "cancelLinkText"
};
var LinkDialog = /** @class */ (function (_super) {
    __extends(LinkDialog, _super);
    function LinkDialog(props) {
        var _this = _super.call(this, props) || this;
        _this.onLinkFieldRef = function (ref) {
            _this.linkField = ref;
        };
        _this.onLinkFieldChanged = function (_e, newValue) {
            _this.setState({ insertButtonDisabled: newValue.trim().length === 0 });
        };
        _this.onLinkFieldKeyDown = function (ev) {
            if (ev.which === Utilities_1.KeyCodes.enter) {
                _this.insertLink();
                ev.preventDefault();
                ev.stopPropagation();
            }
        };
        _this.insertLink = function () {
            var _a = _this.props, editor = _a.editor, selectionRange = _a.selectionRange;
            if (!_this.linkField || !editor || editor.isDisposed()) {
                return;
            }
            editor && !editor.isDisposed() && editor.select(selectionRange);
            _this.linkInserted = true; // don't need to restore the selection after dismiss if we're changing selection into a link
            roosterjs_editor_api_1.createLink(editor, _this.linkField.value);
            _this.dismissDialog();
        };
        _this.dismissDialog = function (ev) {
            var _a = _this.props, editor = _a.editor, _b = _a.onDismiss, onDismiss = _b === void 0 ? roosterjs_react_common_1.NullFunction : _b, selectionRange = _a.selectionRange;
            onDismiss(ev);
            !_this.linkInserted && editor && !editor.isDisposed() && editor.select(selectionRange);
        };
        _this.state = { insertButtonDisabled: true };
        return _this;
    }
    LinkDialog.prototype.render = function () {
        var _a = this.props, _b = _a.strings, strings = _b === void 0 ? {} : _b, className = _a.className;
        return (React.createElement(Dialog_1.Dialog, { onDismiss: this.dismissDialog, dialogContentProps: { type: Dialog_1.DialogType.normal, title: strings[exports.InsertLinkStringKeys.Title] }, hidden: false, modalProps: { isBlocking: true }, className: Utilities_1.css(Styles.modal, className) },
            React.createElement(TextField_1.TextField, { label: strings[exports.InsertLinkStringKeys.LinkFieldLabel] || "Link", componentRef: this.onLinkFieldRef, onKeyDown: this.onLinkFieldKeyDown, required: true, onChange: this.onLinkFieldChanged }),
            React.createElement(Dialog_1.DialogFooter, null,
                React.createElement(Button_1.PrimaryButton, { onClick: this.insertLink, text: strings[exports.InsertLinkStringKeys.InsertButton] || "Insert", disabled: this.state.insertButtonDisabled }),
                React.createElement(Button_1.DefaultButton, { onClick: this.dismissDialog, text: strings[exports.InsertLinkStringKeys.CancelButton] || "Cancel" }))));
    };
    LinkDialog.prototype.componentDidMount = function () {
        this.linkField && this.linkField.focus();
    };
    return LinkDialog;
}(React.PureComponent));
function createLinkDialog(doc, props, calloutClassName) {
    var editor = props.editor, onDismiss = props.onDismiss;
    var container = doc.createElement("div");
    doc.body.appendChild(container);
    var dispose = function () {
        if (container) {
            ReactDOM.unmountComponentAtNode(container);
            // hack to clear placeholder and also for Firefox, to get cursor visible again
            container.setAttribute("tabindex", "0");
            calloutClassName && container.setAttribute("class", calloutClassName);
            container.focus();
            editor && !editor.isDisposed() && editor.focus();
            container.parentElement.removeChild(container);
            container = null;
        }
    };
    // for the case that selection isn't tracked, we need to save the selection before bringing up the dialog
    // and from there, we need to restore it before converting the selected text into a link or restore
    // the selection if the dialog was cancelled
    var selectionRange = editor && !editor.isDisposed() ? editor.getSelectionRange() : null;
    ReactDOM.render(React.createElement(LinkDialog, __assign({}, props, { selectionRange: selectionRange, onDismiss: function (ev) {
            dispose();
            onDismiss && onDismiss(ev);
        }, className: Utilities_1.css(calloutClassName, props.className) })), container);
    return dispose;
}
exports.createLinkDialog = createLinkDialog;


/***/ }),

/***/ "./packages/roosterjs-react-command-bar/lib/components/RoosterCommandBar.scss.g.ts":
/*!*****************************************************************************************!*\
  !*** ./packages/roosterjs-react-command-bar/lib/components/RoosterCommandBar.scss.g.ts ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
var load_themed_styles_1 = __webpack_require__(/*! @microsoft/load-themed-styles */ "./node_modules/@microsoft/load-themed-styles/lib-es6/index.js");
load_themed_styles_1.loadStyles([{ "rawString": ".rooster-command-bar .rooster-command-bar-base{background:#fff}.rooster-command-bar .ms-CommandBar-primaryCommands{margin:0 4px}.rooster-command-bar .ms-CommandBar-sideCommands{padding:0}.rooster-command-button-root.first-level:not(:last-child){padding-right:2px}.rooster-command-bar-button{min-width:32px;line-height:40px;height:40px;border-color:transparent}html[dir=ltr] .rooster-command-bar .ms-CommandBar-primaryCommands,html[dir=rtl] .rooster-command-bar .ms-CommandBar-primaryCommands{margin:0 4px}html[dir=ltr] .rooster-command-bar .ms-CommandBar-sideCommands,html[dir=rtl] .rooster-command-bar .ms-CommandBar-sideCommands{padding:0}.rooster-command-bar .command-button-tool-tip,.rooster-command-bar-overflow .command-button-tool-tip{display:block}.rooster-command-bar .stacked-icon-container,.rooster-command-bar-overflow .stacked-icon-container{display:-webkit-box;display:-ms-flexbox;display:flex;height:100%;position:relative}.rooster-command-bar .stacked-icon-container>.stacked-icon,.rooster-command-bar-overflow .stacked-icon-container>.stacked-icon{font-size:16px;position:absolute;left:0;top:0}.rooster-command-bar .stacked-icon-container>.stacked-icon:first-child,.rooster-command-bar-overflow .stacked-icon-container>.stacked-icon:first-child{position:relative}.rooster-command-bar .stacked-icon-container .highlight-swatch,.rooster-command-bar-overflow .stacked-icon-container .highlight-swatch{color:#ff0}.rooster-command-bar .stacked-icon-container .stacked-icon-RemoveLinkX,.rooster-command-bar .stacked-icon-container .color-swatch,.rooster-command-bar-overflow .stacked-icon-container .stacked-icon-RemoveLinkX,.rooster-command-bar-overflow .stacked-icon-container .color-swatch{color:#e81123}.rooster-command-bar .stacked-icon-container .stacked-icon-ClearFormattingEraser,.rooster-command-bar-overflow .stacked-icon-container .stacked-icon-ClearFormattingEraser{color:#e68497}.rooster-command-bar .stacked-icon-container .stacked-icon-IncreaseIndentArrow,.rooster-command-bar .stacked-icon-container .stacked-icon-DecreaseIndentArrow,.rooster-command-bar .stacked-icon-container .stacked-icon-BulletedListBullet,.rooster-command-bar .stacked-icon-container .stacked-icon-NumberedListNumber,.rooster-command-bar .stacked-icon-container .stacked-icon-Photo2Fill,.rooster-command-bar-overflow .stacked-icon-container .stacked-icon-IncreaseIndentArrow,.rooster-command-bar-overflow .stacked-icon-container .stacked-icon-DecreaseIndentArrow,.rooster-command-bar-overflow .stacked-icon-container .stacked-icon-BulletedListBullet,.rooster-command-bar-overflow .stacked-icon-container .stacked-icon-NumberedListNumber,.rooster-command-bar-overflow .stacked-icon-container .stacked-icon-Photo2Fill{color:#0078d4}.rooster-command-bar .stacked-icon-container .high-contrast-icon,.rooster-command-bar-overflow .stacked-icon-container .high-contrast-icon{display:none}@media screen and (-ms-high-contrast: active){.rooster-command-bar .stacked-icon-container .high-contrast-icon,.rooster-command-bar-overflow .stacked-icon-container .high-contrast-icon{display:block}}.rooster-command-bar .rooster-command-bar-icon,.rooster-command-bar-overflow .rooster-command-bar-icon{color:#212121}@media screen and (-ms-high-contrast: active){.rooster-command-bar .rooster-command-bar-icon,.rooster-command-bar-overflow .rooster-command-bar-icon{color:ButtonText}}.rooster-command-bar .rooster-command-bar-icon.rooster-emoji,.rooster-command-bar-overflow .rooster-command-bar-icon.rooster-emoji{font-style:normal}.rooster-command-bar .rooster-command-bar-icon.rooster-emoji:before,.rooster-command-bar-overflow .rooster-command-bar-icon.rooster-emoji:before{content:\"\\1F642\"}.rooster-command-bar button:not(:hover):not(:active):not(:focus):not(.is-checked),.rooster-command-bar-overflow button:not(:hover):not(:active):not(:focus):not(.is-checked){background:#fff;border-color:transparent}@media screen and (-ms-high-contrast: active){.rooster-command-bar button:hover:not([disabled])::after,.rooster-command-bar-overflow button:hover:not([disabled])::after{content:\"\";position:absolute;left:0;top:0;bottom:0;right:0;border:1px solid WindowText}}.rooster-command-bar button:hover:not([disabled]) .rooster-command-bar-icon,.rooster-command-bar-overflow button:hover:not([disabled]) .rooster-command-bar-icon{color:#212121}@media screen and (-ms-high-contrast: active){.rooster-command-bar button:hover:not([disabled]) .rooster-command-bar-icon,.rooster-command-bar-overflow button:hover:not([disabled]) .rooster-command-bar-icon{color:ButtonText}}.rooster-command-bar button.is-checked,.rooster-command-bar-overflow button.is-checked{background:#dadada}@media screen and (-ms-high-contrast: active){.rooster-command-bar button.is-checked,.rooster-command-bar button.is-checked:hover,.rooster-command-bar button.is-checked:active,.rooster-command-bar-overflow button.is-checked,.rooster-command-bar-overflow button.is-checked:hover,.rooster-command-bar-overflow button.is-checked:active{background-color:Highlight;-ms-high-contrast-adjust:none}.rooster-command-bar button.is-checked,.rooster-command-bar button.is-checked .rooster-command-bar-icon,.rooster-command-bar button.is-checked:hover,.rooster-command-bar button.is-checked:hover .rooster-command-bar-icon,.rooster-command-bar button.is-checked:active,.rooster-command-bar button.is-checked:active .rooster-command-bar-icon,.rooster-command-bar-overflow button.is-checked,.rooster-command-bar-overflow button.is-checked .rooster-command-bar-icon,.rooster-command-bar-overflow button.is-checked:hover,.rooster-command-bar-overflow button.is-checked:hover .rooster-command-bar-icon,.rooster-command-bar-overflow button.is-checked:active,.rooster-command-bar-overflow button.is-checked:active .rooster-command-bar-icon{color:HighlightText}}.rooster-command-bar-overflow div{min-width:0}.rooster-command-bar-overflow ul{display:-webkit-box;display:-ms-flexbox;display:flex;overflow:hidden}.rooster-command-bar-overflow li{display:inline-block}.rooster-command-bar-header1 span{font-size:28px;font-weight:bold}.rooster-command-bar-header2 span{font-size:21px;font-weight:bold}.rooster-command-bar-header3 span{font-size:16px;font-weight:bold}.rooster-command-bar-color-container{padding:2px;overflow:hidden;background:#fff}@media screen and (-ms-high-contrast: active){.rooster-command-bar-color-container{background-color:Background}}.rooster-command-bar-color-container ul{width:180px}.rooster-command-bar-color-cell-border{border-width:1px;border-style:solid;position:absolute;left:1px;right:1px;bottom:1px;top:1px}.rooster-command-bar-color-item{display:inline-block;width:30px;height:30px;background:#fff}@media screen and (-ms-high-contrast: active){.rooster-command-bar-color-item{background-color:Background}}.rooster-command-bar-color-item button{padding:0;min-width:0;border:0}.rooster-command-bar-color-item button:before{content:\"\";position:absolute;left:0;right:0;top:0;bottom:0;border:2px solid #fff}@media screen and (-ms-high-contrast: active){.rooster-command-bar-color-item button:before{border-color:Background}}.rooster-command-bar-color-item button:hover:before{display:none}.rooster-command-bar-color-item button:hover .rooster-command-bar-color-cell-border{left:0;right:0;top:0;bottom:0}.rooster-command-bar-color-button{height:30px;border:0}.rooster-command-bar-color-cell{width:30px;height:30px}" }]);


/***/ }),

/***/ "./packages/roosterjs-react-command-bar/lib/components/RoosterCommandBar.tsx":
/*!***********************************************************************************!*\
  !*** ./packages/roosterjs-react-command-bar/lib/components/RoosterCommandBar.tsx ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! ./RoosterCommandBar.scss.g */ "./packages/roosterjs-react-command-bar/lib/components/RoosterCommandBar.scss.g.ts");
var CommandBar_1 = __webpack_require__(/*! office-ui-fabric-react/lib/CommandBar */ "office-ui-fabric-react/lib/CommandBar");
var FocusZone_1 = __webpack_require__(/*! office-ui-fabric-react/lib/FocusZone */ "office-ui-fabric-react/lib/FocusZone");
var Utilities_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Utilities */ "office-ui-fabric-react/lib/Utilities");
var React = __webpack_require__(/*! react */ "react");
var roosterjs_editor_api_1 = __webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
var roosterjs_react_editor_1 = __webpack_require__(/*! roosterjs-react-editor */ "./packages/roosterjs-react-editor/lib/index.ts");
var getIconOnRenderDelegate_1 = __webpack_require__(/*! ../utils/getIconOnRenderDelegate */ "./packages/roosterjs-react-command-bar/lib/utils/getIconOnRenderDelegate.tsx");
var OutOfBoxCommandBarButtons_1 = __webpack_require__(/*! ../utils/OutOfBoxCommandBarButtons */ "./packages/roosterjs-react-command-bar/lib/utils/OutOfBoxCommandBarButtons.tsx");
var DisplayNoneStyle = { display: "none" };
var RoosterCommandBar = /** @class */ (function (_super) {
    __extends(RoosterCommandBar, _super);
    function RoosterCommandBar(props) {
        var _this = _super.call(this, props) || this;
        _this._id = RoosterCommandBar.IdCounter++;
        _this._fileInputOnRef = function (ref) {
            _this._fileInput = ref;
        };
        _this._fileInputOnChange = function () {
            var _a = _this.props, roosterCommandBarPlugin = _a.roosterCommandBarPlugin, imageManager = _a.imageManager;
            var editor = roosterCommandBarPlugin.getEditor();
            var file = _this._fileInput.files[0];
            if (editor && !editor.isDisposed() && file) {
                if (imageManager) {
                    var placeholder = imageManager.upload(editor, file);
                    editor.insertNode(placeholder);
                    editor.triggerContentChangedEvent("Format" /* Format */);
                    editor.addUndoSnapshot();
                }
                else {
                    roosterjs_editor_api_1.insertImage(editor, file);
                }
                _this._fileInput.value = "";
            }
        };
        _this._refreshButtonStatesCore = function (commandBarButton, firstLevel) {
            if (!commandBarButton) {
                return null;
            }
            var formatState = _this.state.formatState;
            if (commandBarButton.getChecked) {
                var checked = commandBarButton.getChecked(formatState);
                commandBarButton.checked = checked;
                if (!commandBarButton.isContextMenuItem) {
                    commandBarButton[roosterjs_react_common_1.AriaAttributes.Pressed] = checked; // OF 5.0
                }
            }
            if (commandBarButton.getDisabled) {
                commandBarButton.disabled = commandBarButton.getDisabled(formatState);
            }
            if (commandBarButton.subMenuProps && commandBarButton.subMenuProps.items) {
                commandBarButton.subMenuProps.items.forEach(_this._refreshChildButtonStates);
            }
            return commandBarButton;
        };
        _this._refreshButtonStates = function (commandBarButton) {
            return _this._refreshButtonStatesCore(commandBarButton, true);
        };
        _this._refreshChildButtonStates = function (commandBarButton) {
            return _this._refreshButtonStatesCore(commandBarButton, false);
        };
        _this._createButton = function (commandBarButton, firstLevel) {
            if (firstLevel === void 0) { firstLevel = true; }
            if (!commandBarButton) {
                return null;
            }
            var _a = _this.props, strings = _a.strings, calloutClassName = _a.calloutClassName, calloutOnDismiss = _a.calloutOnDismiss, tooltipDirectionHint = _a.tooltipDirectionHint;
            var className = commandBarButton.className || "";
            var rootClassName = className.split(" ").indexOf(OutOfBoxCommandBarButtons_1.RoosterCommandBarButtonRootClassName) < 0 ? OutOfBoxCommandBarButtons_1.RoosterCommandBarButtonRootClassName : undefined;
            // make a copy of the OOB button template since we're changing its properties
            var button = __assign(__assign({}, commandBarButton), { className: Utilities_1.css(rootClassName, { "first-level": firstLevel }, className) });
            if (!button.onRender && button.onRenderOptions) {
                var _b = button.onRenderOptions.customCacheKey, customCacheKey = _b === void 0 ? "" + button.key + _this._id : _b;
                button.onRender = getIconOnRenderDelegate_1.getIconButtonOnRenderDelegate(__assign(__assign({}, button.onRenderOptions), { customCacheKey: customCacheKey, tooltipDirectionHint: tooltipDirectionHint }));
            }
            button.onClick = button.onClick || _this._onCommandBarButtonClick.bind(_this, button);
            button.iconOnly = true;
            if (button.iconProps) {
                var _c = button.iconProps.className, className_1 = _c === void 0 ? "" : _c;
                button.iconProps = __assign(__assign({}, button.iconProps), { className: className_1.split(" ").indexOf(OutOfBoxCommandBarButtons_1.RoosterCommandBarIconClassName) < 0 ? Utilities_1.css(OutOfBoxCommandBarButtons_1.RoosterCommandBarIconClassName, className_1) : className_1 });
            }
            if (strings && strings[button.key] != null) {
                button.name = strings[button.key];
                if (button.title) {
                    button.title = button.name; // for buttons like color which has title/tooltip
                }
            }
            if (button.subMenuProps && button.subMenuProps.items) {
                button.subMenuProps = __assign({}, button.subMenuProps); // make a copy of the OOB submenu properties since we're changing them
                button.subMenuProps.items = button.subMenuProps.items.map(_this._createChildButton);
                button.subMenuProps.calloutProps = { className: calloutClassName };
                button.subMenuProps.onDismiss = calloutOnDismiss;
            }
            // make sure the initial states are correct
            _this._refreshButtonStatesCore(button, firstLevel);
            return button;
        };
        _this._createChildButton = function (commandBarButton) {
            return _this._createButton(commandBarButton, false);
        };
        _this._onCommandBarButtonClick = function (button) {
            var _a = _this.props, roosterCommandBarPlugin = _a.roosterCommandBarPlugin, onButtonClicked = _a.onButtonClicked;
            var editor = roosterCommandBarPlugin.getEditor();
            if (editor && button.handleChange) {
                var outOfBoxItem = button;
                outOfBoxItem.handleChange(editor, _this.props, _this.state);
            }
            // special case insert image
            if (button.key === OutOfBoxCommandBarButtons_1.RoosterCommmandBarButtonKeys.InsertImage) {
                _this._fileInput.click();
            }
            _this._updateFormatState();
            onButtonClicked && onButtonClicked(button.key);
        };
        _this._updateFormatState = function () {
            var roosterCommandBarPlugin = _this.props.roosterCommandBarPlugin;
            var editor = roosterCommandBarPlugin.getEditor();
            var formatState = editor ? roosterjs_editor_api_1.getFormatState(editor) : null;
            if (formatState && _this._hasFormatStateChanged(formatState)) {
                _this.setState({ formatState: formatState });
            }
        };
        _this.state = { formatState: roosterjs_react_editor_1.createFormatState() };
        _this._initButtons(props);
        _this._async = new Utilities_1.Async();
        _this._updateFormatStateDebounced = _this._async.debounce(function () { return _this._updateFormatState(); }, 100);
        return _this;
    }
    RoosterCommandBar.prototype.render = function () {
        var _a = this.props, className = _a.className, calloutClassName = _a.calloutClassName, calloutOnDismiss = _a.calloutOnDismiss, overflowMenuProps = _a.overflowMenuProps, commandBarClassName = _a.commandBarClassName, ellipsisAriaLabel = _a.ellipsisAriaLabel;
        // with the newest changes on the editor, refresh the buttons (e.g. bold button being selected if text selected is bold and header being checked if used)
        this._buttons.forEach(this._refreshButtonStates);
        return (React.createElement("div", { className: Utilities_1.css("rooster-command-bar", className) },
            React.createElement(CommandBar_1.CommandBar, { className: Utilities_1.css("rooster-command-bar-base", commandBarClassName), items: this._buttons, overflowButtonProps: {
                    ariaLabel: ellipsisAriaLabel,
                    menuProps: __assign(__assign({}, overflowMenuProps), { 
                        // we set items as empty to satisfy the type checker & because otherwise the component
                        // throws an error about an unexpected `undefined` value on first render.
                        //
                        // We expect it to be overridden by the commandBar when rendering the button
                        // after measuring.
                        items: [], calloutProps: {
                            className: calloutClassName
                        }, onDismiss: calloutOnDismiss, className: Utilities_1.css("rooster-command-bar-overflow", overflowMenuProps && overflowMenuProps.className), focusZoneProps: { direction: FocusZone_1.FocusZoneDirection.horizontal } })
                } }),
            React.createElement("input", { type: "file", ref: this._fileInputOnRef, accept: "image/*", style: DisplayNoneStyle, onChange: this._fileInputOnChange })));
    };
    RoosterCommandBar.prototype.componentDidMount = function () {
        var roosterCommandBarPlugin = this.props.roosterCommandBarPlugin;
        roosterCommandBarPlugin.registerRoosterCommandBar(this);
    };
    RoosterCommandBar.prototype.componentWillUnmount = function () {
        var roosterCommandBarPlugin = this.props.roosterCommandBarPlugin;
        roosterCommandBarPlugin.unregisterRoosterCommandBar(this);
        if (this._async) {
            this._async.dispose();
            this._async = null;
        }
    };
    RoosterCommandBar.prototype.componentWillReceiveProps = function (nextProps, nextState) {
        if (nextProps.buttonOverrides !== this.props.buttonOverrides) {
            this._initButtons(nextProps);
        }
    };
    RoosterCommandBar.prototype.refreshFormatState = function () {
        this._updateFormatStateDebounced();
    };
    RoosterCommandBar.prototype._initButtons = function (props) {
        var _this = this;
        var _a = props.buttonOverrides, buttonOverrides = _a === void 0 ? [] : _a, emojiPlugin = props.emojiPlugin;
        var buttonMap = __assign({}, OutOfBoxCommandBarButtons_1.OutOfBoxCommandBarButtonMap);
        var visibleButtonKeys = OutOfBoxCommandBarButtons_1.OutOfBoxCommandBarButtons.map(function (item) { return item.key; });
        for (var _i = 0, buttonOverrides_1 = buttonOverrides; _i < buttonOverrides_1.length; _i++) {
            var button = buttonOverrides_1[_i];
            if (!button) {
                continue;
            }
            var currentButton = buttonMap[button.key];
            if (currentButton) {
                buttonMap[button.key] = __assign(__assign({}, currentButton), button);
                var currentSubMenuProps = currentButton.subMenuProps;
                var subMenuPropsOverride = button.subMenuPropsOverride;
                if (currentSubMenuProps && subMenuPropsOverride) {
                    buttonMap[button.key].subMenuProps = __assign(__assign(__assign({}, currentSubMenuProps), subMenuPropsOverride), { className: Utilities_1.css(currentSubMenuProps.className, subMenuPropsOverride.className) });
                }
            }
            else {
                buttonMap[button.key] = button;
            }
            if (visibleButtonKeys.indexOf(button.key) === -1) {
                visibleButtonKeys.push(button.key);
            }
        }
        if (!emojiPlugin) {
            var emojiIndex = visibleButtonKeys.indexOf(OutOfBoxCommandBarButtons_1.RoosterCommmandBarButtonKeys.Emoji);
            if (emojiIndex > -1) {
                visibleButtonKeys.splice(emojiIndex, 1);
            }
        }
        this._buttons = visibleButtonKeys.map(function (key) { return _this._createButton(buttonMap[key]); }).filter(function (b) { return !!b && !b.exclude; });
        this._buttons.sort(function (l, r) {
            if (l.order !== r.order) {
                var leftOrder = l.order == null ? Number.MAX_VALUE : l.order;
                var rightOrder = r.order == null ? Number.MAX_VALUE : r.order;
                return leftOrder - rightOrder;
            }
            return visibleButtonKeys.indexOf(l.key) - visibleButtonKeys.indexOf(r.key);
        });
    };
    RoosterCommandBar.prototype._hasFormatStateChanged = function (newState) {
        var formatState = this.state.formatState;
        for (var key in formatState) {
            if (formatState[key] !== newState[key]) {
                return true;
            }
        }
        return false;
    };
    RoosterCommandBar.IdCounter = 0;
    return RoosterCommandBar;
}(React.PureComponent));
exports.default = RoosterCommandBar;


/***/ }),

/***/ "./packages/roosterjs-react-command-bar/lib/index.ts":
/*!***********************************************************!*\
  !*** ./packages/roosterjs-react-command-bar/lib/index.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InsertLinkStringKeys = exports.createLinkDialog = exports.getIconButtonOnRenderDelegate = exports.getIconOnRenderDelegateWithCustomCacheKey = exports.getIconOnRenderDelegate = exports.RoosterCommmandBarButtonKeys = exports.RoosterCommandBarStringKeys = exports.RoosterCommandBarPlugin = exports.RoosterCommandBar = void 0;
var RoosterCommandBar_1 = __webpack_require__(/*! ./components/RoosterCommandBar */ "./packages/roosterjs-react-command-bar/lib/components/RoosterCommandBar.tsx");
Object.defineProperty(exports, "RoosterCommandBar", { enumerable: true, get: function () { return RoosterCommandBar_1.default; } });
var RoosterCommandBarPlugin_1 = __webpack_require__(/*! ./plugins/RoosterCommandBarPlugin */ "./packages/roosterjs-react-command-bar/lib/plugins/RoosterCommandBarPlugin.ts");
Object.defineProperty(exports, "RoosterCommandBarPlugin", { enumerable: true, get: function () { return RoosterCommandBarPlugin_1.default; } });
var OutOfBoxCommandBarButtons_1 = __webpack_require__(/*! ./utils/OutOfBoxCommandBarButtons */ "./packages/roosterjs-react-command-bar/lib/utils/OutOfBoxCommandBarButtons.tsx");
Object.defineProperty(exports, "RoosterCommandBarStringKeys", { enumerable: true, get: function () { return OutOfBoxCommandBarButtons_1.RoosterCommandBarStringKeys; } });
Object.defineProperty(exports, "RoosterCommmandBarButtonKeys", { enumerable: true, get: function () { return OutOfBoxCommandBarButtons_1.RoosterCommmandBarButtonKeys; } });
var getIconOnRenderDelegate_1 = __webpack_require__(/*! ./utils/getIconOnRenderDelegate */ "./packages/roosterjs-react-command-bar/lib/utils/getIconOnRenderDelegate.tsx");
Object.defineProperty(exports, "getIconOnRenderDelegate", { enumerable: true, get: function () { return getIconOnRenderDelegate_1.getIconOnRenderDelegate; } });
Object.defineProperty(exports, "getIconOnRenderDelegateWithCustomCacheKey", { enumerable: true, get: function () { return getIconOnRenderDelegate_1.getIconOnRenderDelegateWithCustomCacheKey; } });
Object.defineProperty(exports, "getIconButtonOnRenderDelegate", { enumerable: true, get: function () { return getIconOnRenderDelegate_1.getIconButtonOnRenderDelegate; } });
var LinkDialog_1 = __webpack_require__(/*! ./components/LinkDialog */ "./packages/roosterjs-react-command-bar/lib/components/LinkDialog.tsx");
Object.defineProperty(exports, "createLinkDialog", { enumerable: true, get: function () { return LinkDialog_1.createLinkDialog; } });
Object.defineProperty(exports, "InsertLinkStringKeys", { enumerable: true, get: function () { return LinkDialog_1.InsertLinkStringKeys; } });


/***/ }),

/***/ "./packages/roosterjs-react-command-bar/lib/plugins/RoosterCommandBarPlugin.Shortcuts.ts":
/*!***********************************************************************************************!*\
  !*** ./packages/roosterjs-react-command-bar/lib/plugins/RoosterCommandBarPlugin.Shortcuts.ts ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommandFromEvent = void 0;
var Utilities_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Utilities */ "office-ui-fabric-react/lib/Utilities");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var macCommands = [
    // Bold for Mac: Command (Meta) + B
    {
        metaKey: true,
        ctrlKey: false,
        shiftKey: false,
        which: Utilities_1.KeyCodes.b,
        command: "Bold" /* Bold */
    },
    // Italic for Mac: Command (Meta) + I
    {
        metaKey: true,
        ctrlKey: false,
        shiftKey: false,
        which: Utilities_1.KeyCodes.i,
        command: "Italic" /* Italic */
    },
    // Underline for Mac: Command (Meta) + U
    {
        metaKey: true,
        ctrlKey: false,
        shiftKey: false,
        which: Utilities_1.KeyCodes.u,
        command: "Underline" /* Underline */
    },
    // Undo for Mac: Command (Meta) + Z
    {
        metaKey: true,
        ctrlKey: false,
        shiftKey: false,
        which: Utilities_1.KeyCodes.z,
        command: "Undo" /* Undo */
    },
    // Redo for Mac: Command (meta) + SHIFT + Z
    {
        metaKey: true,
        ctrlKey: false,
        shiftKey: true,
        which: Utilities_1.KeyCodes.z,
        command: "Redo" /* Redo */
    },
    // Bullet for Mac: Command (meta) + .
    {
        metaKey: true,
        ctrlKey: false,
        shiftKey: false,
        which: Utilities_1.KeyCodes.period,
        command: "Bullet" /* Bullet */
    },
    // Numbering for Mac: Command (meta) + /
    {
        metaKey: true,
        ctrlKey: false,
        shiftKey: false,
        which: Utilities_1.KeyCodes.forwardSlash,
        command: "Numbering" /* Numbering */
    },
    // Insert link for Mac: Command (meta) + k
    {
        metaKey: true,
        ctrlKey: false,
        shiftKey: false,
        which: Utilities_1.KeyCodes.k,
        command: "InsertLink" /* InsertLink */
    },
    // Clear format for Mac: Command (meta) + space
    {
        metaKey: true,
        ctrlKey: false,
        shiftKey: false,
        which: Utilities_1.KeyCodes.space,
        command: "ClearFormat" /* ClearFormat */
    }
];
var winCommands = [
    // Bold for Windows: Ctrl + B
    {
        metaKey: false,
        ctrlKey: true,
        shiftKey: false,
        which: Utilities_1.KeyCodes.b,
        command: "Bold" /* Bold */
    },
    // Italic for Windows: Ctrl + I
    {
        metaKey: false,
        ctrlKey: true,
        shiftKey: false,
        which: Utilities_1.KeyCodes.i,
        command: "Italic" /* Italic */
    },
    // Underline for Windows: Ctrl + U
    {
        metaKey: false,
        ctrlKey: true,
        shiftKey: false,
        which: Utilities_1.KeyCodes.u,
        command: "Underline" /* Underline */
    },
    // Undo for Windows: Ctrl + Z
    {
        metaKey: false,
        ctrlKey: true,
        shiftKey: false,
        which: Utilities_1.KeyCodes.z,
        command: "Undo" /* Undo */
    },
    // Redo for Windows: Ctrl + Y
    {
        metaKey: false,
        ctrlKey: true,
        shiftKey: false,
        which: Utilities_1.KeyCodes.y,
        command: "Redo" /* Redo */
    },
    // Bullet for Windows: Ctrl + .
    {
        metaKey: false,
        ctrlKey: true,
        shiftKey: false,
        which: Utilities_1.KeyCodes.period,
        command: "Bullet" /* Bullet */
    },
    // Numbering for Windows: Ctrl + /
    {
        metaKey: false,
        ctrlKey: true,
        shiftKey: false,
        which: Utilities_1.KeyCodes.forwardSlash,
        command: "Numbering" /* Numbering */
    },
    // Insert link for Windows: Ctrl + k
    {
        metaKey: false,
        ctrlKey: true,
        shiftKey: false,
        which: Utilities_1.KeyCodes.k,
        command: "InsertLink" /* InsertLink */
    },
    // Clear format for Windows: Ctrl + space
    {
        metaKey: false,
        ctrlKey: true,
        shiftKey: false,
        which: Utilities_1.KeyCodes.space,
        command: "ClearFormat" /* ClearFormat */
    }
];
function getCommandFromEvent(event) {
    if (event.eventType !== 0 /* KeyDown */) {
        return "None" /* None */;
    }
    var commands = roosterjs_editor_dom_1.Browser.isMac ? macCommands : winCommands;
    var keyboardEvent = event.rawEvent;
    for (var _i = 0, commands_1 = commands; _i < commands_1.length; _i++) {
        var cmd = commands_1[_i];
        if (!keyboardEvent.altKey &&
            cmd.ctrlKey === keyboardEvent.ctrlKey &&
            cmd.metaKey === keyboardEvent.metaKey &&
            cmd.shiftKey === keyboardEvent.shiftKey &&
            cmd.which === keyboardEvent.which) {
            return cmd.command;
        }
    }
    return "None" /* None */;
}
exports.getCommandFromEvent = getCommandFromEvent;


/***/ }),

/***/ "./packages/roosterjs-react-command-bar/lib/plugins/RoosterCommandBarPlugin.ts":
/*!*************************************************************************************!*\
  !*** ./packages/roosterjs-react-command-bar/lib/plugins/RoosterCommandBarPlugin.ts ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InsertLinkStringKeys = void 0;
var roosterjs_editor_api_1 = __webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
var LinkDialog_1 = __webpack_require__(/*! ../components/LinkDialog */ "./packages/roosterjs-react-command-bar/lib/components/LinkDialog.tsx");
var RoosterCommandBarPlugin_Shortcuts_1 = __webpack_require__(/*! ./RoosterCommandBarPlugin.Shortcuts */ "./packages/roosterjs-react-command-bar/lib/plugins/RoosterCommandBarPlugin.Shortcuts.ts");
exports.InsertLinkStringKeys = {
    LinkFieldLabel: "linkFieldLabel",
    Title: "linkPromptTitle",
    InsertButton: "insertLinkText",
    CancelButton: "cancelLinkText"
};
var RoosterCommandBarPlugin = /** @class */ (function () {
    function RoosterCommandBarPlugin(options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        this.commandBars = [];
    }
    RoosterCommandBarPlugin.prototype.getName = function () {
        return 'RoosterCommandBar';
    };
    RoosterCommandBarPlugin.prototype.initialize = function (editor) {
        this.editor = editor;
        if (!editor) {
            return;
        }
        var doc = this.editor.getDocument();
        if (!doc) {
            return;
        }
    };
    RoosterCommandBarPlugin.prototype.dispose = function () {
        var _this = this;
        if (this.dialogDismiss) {
            this.dialogDismiss();
            this.dialogDismiss = null;
        }
        if (this.editor) {
            this.editor = null;
        }
        if (this.commandBars.length > 0) {
            this.commandBars.forEach(function (_, i) { return (_this.commandBars[i] = undefined); });
            this.commandBars = [];
        }
    };
    RoosterCommandBarPlugin.prototype.onPluginEvent = function (event) {
        if (this.commandBars && RoosterCommandBarPlugin.EventTypesToRefreshFormatState[event.eventType]) {
            this.commandBars.forEach(function (commandBar) { return commandBar.refreshFormatState(); });
            return;
        }
        if (event.eventType === 0 /* KeyDown */) {
            this.handleShortcuts(event);
        }
    };
    RoosterCommandBarPlugin.prototype.handleShortcuts = function (event) {
        var pluginDomEvent = event;
        var keyboardEvent = pluginDomEvent.rawEvent;
        if (keyboardEvent.defaultPrevented) {
            return;
        }
        var command = RoosterCommandBarPlugin_Shortcuts_1.getCommandFromEvent(event);
        if (command === "None" /* None */) {
            return;
        }
        var _a = this.options, disableListWorkaround = _a.disableListWorkaround, _b = _a.onShortcutTriggered, onShortcutTriggered = _b === void 0 ? roosterjs_react_common_1.NullFunction : _b;
        var editor = this.editor;
        var commandExecuted = true;
        switch (command) {
            case "Bold" /* Bold */:
                roosterjs_editor_api_1.toggleBold(editor);
                break;
            case "Italic" /* Italic */:
                roosterjs_editor_api_1.toggleItalic(editor);
                break;
            case "Underline" /* Underline */:
                roosterjs_editor_api_1.toggleUnderline(editor);
                break;
            case "Undo" /* Undo */:
                editor.undo();
                break;
            case "Redo" /* Redo */:
                editor.redo();
                break;
            case "Bullet" /* Bullet */:
                (disableListWorkaround ? roosterjs_react_common_1.toggleNonCompatBullet : roosterjs_editor_api_1.toggleBullet)(editor);
                break;
            case "Numbering" /* Numbering */:
                (disableListWorkaround ? roosterjs_react_common_1.toggleNonCompatNumbering : roosterjs_editor_api_1.toggleNumbering)(editor);
                break;
            case "InsertLink" /* InsertLink */:
                this.promptForLink();
                break;
            case "ClearFormat" /* ClearFormat */:
                this.clearFormat();
                break;
            default:
                commandExecuted = false;
        }
        if (commandExecuted) {
            onShortcutTriggered(command);
            keyboardEvent.preventDefault();
            keyboardEvent.stopPropagation();
        }
    };
    RoosterCommandBarPlugin.prototype.getEditor = function () {
        return this.editor;
    };
    RoosterCommandBarPlugin.prototype.registerRoosterCommandBar = function (commandBar) {
        if (this.commandBars.indexOf(commandBar) < 0) {
            this.commandBars.push(commandBar);
        }
    };
    RoosterCommandBarPlugin.prototype.unregisterRoosterCommandBar = function (commandBar) {
        var index = this.commandBars.indexOf(commandBar);
        if (index >= 0) {
            this.commandBars.splice(index, 1);
        }
    };
    RoosterCommandBarPlugin.prototype.promptForLink = function () {
        var _a = this.options, _b = _a.strings, strings = _b === void 0 ? {} : _b, onDismiss = _a.calloutOnDismiss, calloutClassName = _a.calloutClassName, className = _a.linkDialogClassName;
        this.dialogDismiss = LinkDialog_1.createLinkDialog(document, { editor: this.editor, strings: strings, onDismiss: onDismiss, className: className }, calloutClassName);
    };
    RoosterCommandBarPlugin.prototype.clearFormat = function () {
        var _this = this;
        var editor = this.editor;
        this.editor.addUndoSnapshot(function () {
            if (_this.options.useLegacyClearFormat) {
                roosterjs_editor_api_1.clearFormat(editor);
                roosterjs_editor_api_1.toggleHeader(editor, 0);
            }
            else {
                roosterjs_editor_api_1.clearBlockFormat(editor);
            }
        });
    };
    RoosterCommandBarPlugin.EventTypesToRefreshFormatState = (_a = {},
        _a[2 /* KeyUp */] = true,
        _a[4 /* MouseDown */] = true,
        _a[5 /* MouseUp */] = true,
        _a[6 /* ContentChanged */] = true,
        _a);
    return RoosterCommandBarPlugin;
}());
exports.default = RoosterCommandBarPlugin;


/***/ }),

/***/ "./packages/roosterjs-react-command-bar/lib/utils/OutOfBoxCommandBarButtons.ColorInfo.tsx":
/*!************************************************************************************************!*\
  !*** ./packages/roosterjs-react-command-bar/lib/utils/OutOfBoxCommandBarButtons.ColorInfo.tsx ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HighlightColorInfoList = exports.FontColorInfoList = void 0;
exports.FontColorInfoList = [
    { title: "Light Blue", color: "#51a7f9" },
    { title: "Light Green", color: "#6fc040" },
    { title: "Light Yellow", color: "#f5d427" },
    { title: "Light Orange", color: "#f3901d" },
    { title: "Light Red", color: "#ed5c57" },
    { title: "Light Purple", color: "#b36ae2" },
    { title: "Blue", color: "#0c64c0" },
    { title: "Green", color: "#0c882a" },
    { title: "Yellow", color: "#dcbe22" },
    { title: "Orange", color: "#de6a19" },
    { title: "Red", color: "#c82613" },
    { title: "Purple", color: "#763e9b" },
    { title: "Dark Blue", color: "#174e86" },
    { title: "Dark Green", color: "#0f5c1a" },
    { title: "Dark Yellow", color: "#c3971d" },
    { title: "Dark Orange", color: "#be5b17" },
    { title: "Dark Red", color: "#861106" },
    { title: "Dark Purple", color: "#5e327c" },
    { title: "Darker Blue", color: "#002451" },
    { title: "Darker Green", color: "#06400c" },
    { title: "Darker Yellow", color: "#a37519" },
    { title: "Darker Orange", color: "#934511" },
    { title: "Darker Red", color: "#570606" },
    { title: "Darker Purple", color: "#3b204d" },
    { title: "White", color: "#ffffff", cellBorderColor: "#bebebe" },
    { title: "Light Gray", color: "#cccccc" },
    { title: "Gray", color: "#999999" },
    { title: "Dark Gray", color: "#666666" },
    { title: "Darker Gray", color: "#333333" },
    { title: "Black", color: "#000000" },
];
exports.HighlightColorInfoList = [
    { title: "Cyan", color: "#00ffff" },
    { title: "Green", color: "#00ff00" },
    { title: "Yellow", color: "#ffff00" },
    { title: "Orange", color: "#ff8000" },
    { title: "Red", color: "#ff0000" },
    { title: "Magenta", color: "#ff00ff" },
    { title: "Light Cyan", color: "#80ffff" },
    { title: "Light Green", color: "#80ff80" },
    { title: "Light Yellow", color: "#ffff80" },
    { title: "Light Orange", color: "#ffc080" },
    { title: "Light Red", color: "#ff8080" },
    { title: "Light Magenta", color: "#ff80ff" },
    { title: "White", color: "#ffffff", cellBorderColor: "#bebebe" },
    { title: "Light Gray", color: "#cccccc" },
    { title: "Gray", color: "#999999" },
    { title: "Dark Gray", color: "#666666" },
    { title: "Darker Gray", color: "#333333" },
    { title: "Black", color: "#000000" },
];
function _setKey(prefix, color) {
    var title = color.title;
    color.key = "" + prefix + title.replace(/\s/g, "");
}
exports.FontColorInfoList.forEach(_setKey.bind(this, "fontColor"));
exports.HighlightColorInfoList.forEach(_setKey.bind(this, "highlight"));


/***/ }),

/***/ "./packages/roosterjs-react-command-bar/lib/utils/OutOfBoxCommandBarButtons.tsx":
/*!**************************************************************************************!*\
  !*** ./packages/roosterjs-react-command-bar/lib/utils/OutOfBoxCommandBarButtons.tsx ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutOfBoxCommandBarButtonMap = exports.OutOfBoxCommandBarButtons = exports.RoosterCommmandBarButtonKeys = exports.RoosterCommandBarStringKeys = exports.RoosterCommandBarButtonRootClassName = exports.RoosterCommandBarIconClassName = void 0;
var Button_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Button */ "office-ui-fabric-react/lib/Button");
var ContextualMenu_1 = __webpack_require__(/*! office-ui-fabric-react/lib/ContextualMenu */ "office-ui-fabric-react/lib/ContextualMenu");
var FocusZone_1 = __webpack_require__(/*! office-ui-fabric-react/lib/FocusZone */ "office-ui-fabric-react/lib/FocusZone");
var React = __webpack_require__(/*! react */ "react");
var roosterjs_editor_api_1 = __webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
var OutOfBoxCommandBarButtons_ColorInfo_1 = __webpack_require__(/*! ./OutOfBoxCommandBarButtons.ColorInfo */ "./packages/roosterjs-react-command-bar/lib/utils/OutOfBoxCommandBarButtons.ColorInfo.tsx");
exports.RoosterCommandBarIconClassName = "rooster-command-bar-icon";
exports.RoosterCommandBarButtonRootClassName = "rooster-command-button-root";
exports.RoosterCommandBarStringKeys = {
    LinkPrompt: "linkPrompt"
};
exports.RoosterCommmandBarButtonKeys = {
    Header: "header",
    Bold: "bold",
    Italic: "italic",
    Underline: "underline",
    BulletedList: "bulleted-list",
    NumberedList: "numbered-list",
    Link: "link",
    Highlight: "highlight",
    ClearFormat: "clear-format",
    Emoji: "emoji",
    InsertImage: "insert-image",
    Indent: "indent",
    Outdent: "outdent",
    Strikethrough: "strikethrough",
    FontColor: "font-color",
    Unlink: "unlink",
    Code: "code"
};
var RenderOptionsNoCustomCacheKey = null; // buttons that are not menu based don't need custom cache keys
exports.OutOfBoxCommandBarButtons = [
    {
        key: exports.RoosterCommmandBarButtonKeys.Bold,
        name: "Bold",
        iconProps: _getIconProps("Bold"),
        canCheck: true,
        getChecked: function (formatState) { return formatState.isBold; },
        handleChange: function (editor) { return roosterjs_editor_api_1.toggleBold(editor); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.Italic,
        name: "Italic",
        iconProps: _getIconProps("Italic"),
        canCheck: true,
        getChecked: function (formatState) { return formatState.isItalic; },
        handleChange: function (editor) { return roosterjs_editor_api_1.toggleItalic(editor); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.Underline,
        name: "Underline",
        iconProps: _getIconProps("Underline"),
        canCheck: true,
        getChecked: function (formatState) { return formatState.isUnderline; },
        handleChange: function (editor) { return roosterjs_editor_api_1.toggleUnderline(editor); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.BulletedList,
        name: "Bulleted list",
        iconProps: _getIconProps("BulletedList"),
        onRenderOptions: {
            customCacheKey: RenderOptionsNoCustomCacheKey,
            highContrastAssetName: "BulletedList",
            assets: [{ name: "BulletedListText" }, { name: "BulletedListBullet" }]
        },
        canCheck: true,
        getChecked: function (formatState) { return formatState.isBullet; },
        handleChange: function (editor, props) { return (props.disableListWorkaround ? roosterjs_react_common_1.toggleNonCompatBullet : roosterjs_editor_api_1.toggleBullet)(editor); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.NumberedList,
        name: "Numbered list",
        iconProps: _getIconProps("NumberedList"),
        onRenderOptions: {
            customCacheKey: RenderOptionsNoCustomCacheKey,
            highContrastAssetName: "NumberedList",
            assets: [{ name: "NumberedListText" }, { name: "NumberedListNumber" }]
        },
        canCheck: true,
        getChecked: function (formatState) { return formatState.isNumbering; },
        handleChange: function (editor, props) { return (props.disableListWorkaround ? roosterjs_react_common_1.toggleNonCompatNumbering : roosterjs_editor_api_1.toggleNumbering)(editor); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.Highlight,
        name: "Highlight",
        iconProps: _getIconProps("Highlight"),
        onRenderOptions: {
            highContrastAssetName: "FabricTextHighlightComposite",
            assets: [{ name: "FontColorSwatch", className: "highlight-swatch" }, { name: "FabricTextHighlight" }]
        },
        subMenuProps: {
            className: "rooster-command-bar-color-container",
            shouldFocusOnMount: true,
            directionalHint: ContextualMenu_1.DirectionalHint.bottomLeftEdge,
            focusZoneProps: { direction: FocusZone_1.FocusZoneDirection.bidirectional },
            items: OutOfBoxCommandBarButtons_ColorInfo_1.HighlightColorInfoList.map(function (color) {
                return ({
                    className: "rooster-command-bar-color-item",
                    key: color.key,
                    title: color.title,
                    onRender: _colorCellOnRender,
                    data: color,
                    handleChange: _handleChangeForHighlight
                });
            })
        }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.FontColor,
        name: "Font color",
        iconProps: _getIconProps("FontColor"),
        onRenderOptions: { highContrastAssetName: "FontColor", assets: [{ name: "FontColorSwatch", className: "color-swatch" }, { name: "FontColorA" }] },
        subMenuProps: {
            className: "rooster-command-bar-color-container",
            shouldFocusOnMount: true,
            directionalHint: ContextualMenu_1.DirectionalHint.bottomLeftEdge,
            focusZoneProps: { direction: FocusZone_1.FocusZoneDirection.bidirectional },
            items: OutOfBoxCommandBarButtons_ColorInfo_1.FontColorInfoList.map(function (color) {
                return ({
                    className: "rooster-command-bar-color-item",
                    key: color.key,
                    title: color.title,
                    onRender: _colorCellOnRender,
                    data: color,
                    handleChange: _handleChangeForFontColor
                });
            })
        }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.Emoji,
        name: "Emoji",
        iconProps: { className: exports.RoosterCommandBarIconClassName + " rooster-emoji" },
        handleChange: function (editor, props) { return props.emojiPlugin.startEmoji(); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.Outdent,
        name: "Decrease indent",
        iconProps: _getIconProps("DecreaseIndentLegacy"),
        onRenderOptions: {
            customCacheKey: RenderOptionsNoCustomCacheKey,
            highContrastAssetName: "DecreaseIndentLegacy",
            assets: [{ name: "DecreaseIndentText" }, { name: "DecreaseIndentArrow" }]
        },
        handleChange: function (editor, props) { return (props.disableListWorkaround ? roosterjs_react_common_1.setNonCompatIndentation : roosterjs_editor_api_1.setIndentation)(editor, 1 /* Decrease */); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.Indent,
        name: "Increase indent",
        iconProps: _getIconProps("IncreaseIndentLegacy"),
        onRenderOptions: {
            customCacheKey: RenderOptionsNoCustomCacheKey,
            highContrastAssetName: "IncreaseIndentLegacy",
            assets: [{ name: "IncreaseIndentText" }, { name: "IncreaseIndentArrow" }]
        },
        handleChange: function (editor, props) { return (props.disableListWorkaround ? roosterjs_react_common_1.setNonCompatIndentation : roosterjs_editor_api_1.setIndentation)(editor, 0 /* Increase */); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.Strikethrough,
        name: "Strikethrough",
        iconProps: _getIconProps("Strikethrough"),
        getChecked: function (formatState) { return formatState.isStrikeThrough; },
        handleChange: function (editor) { return roosterjs_editor_api_1.toggleStrikethrough(editor); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.Header,
        name: "Header",
        iconProps: _getIconProps("FontSize"),
        onRenderOptions: { assets: [{ name: "FontSize" }] },
        subMenuProps: {
            shouldFocusOnMount: true,
            directionalHint: ContextualMenu_1.DirectionalHint.bottomLeftEdge,
            items: [
                {
                    key: "header1",
                    name: "Header 1",
                    className: "rooster-command-bar-header1",
                    headerLevel: 1,
                    canCheck: true,
                    getChecked: _getCheckedForHeader,
                    isContextMenuItem: true,
                    handleChange: _handleChangeForHeader,
                    iconProps: null
                },
                {
                    key: "header2",
                    name: "Header 2",
                    className: "rooster-command-bar-header2",
                    headerLevel: 2,
                    canCheck: true,
                    getChecked: _getCheckedForHeader,
                    isContextMenuItem: true,
                    handleChange: _handleChangeForHeader,
                    iconProps: null
                },
                {
                    key: "header3",
                    name: "Header 3",
                    className: "rooster-command-bar-header3",
                    headerLevel: 3,
                    canCheck: true,
                    getChecked: _getCheckedForHeader,
                    isContextMenuItem: true,
                    handleChange: _handleChangeForHeader,
                    iconProps: null
                }
            ]
        }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.Code,
        name: "Code",
        iconProps: _getIconProps("Embed"),
        handleChange: function (editor) { return roosterjs_editor_api_1.toggleCodeBlock(editor); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.ClearFormat,
        name: "Clear format",
        iconProps: _getIconProps("ClearFormatting"),
        onRenderOptions: {
            customCacheKey: RenderOptionsNoCustomCacheKey,
            highContrastAssetName: "ClearFormatting",
            assets: [{ name: "ClearFormattingA" }, { name: "ClearFormattingEraser" }]
        },
        handleChange: function (editor, props) { return props.roosterCommandBarPlugin.clearFormat(); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.InsertImage,
        name: "Insert image",
        iconProps: _getIconProps("Photo2"),
        onRenderOptions: { customCacheKey: RenderOptionsNoCustomCacheKey, assets: [{ name: "Photo2Fill" }, { name: "Photo2" }] } // reuse Photo2 as the high contrast icon
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.Link,
        name: "Link",
        iconProps: _getIconProps("Link"),
        handleChange: function (editor, props) { return props.roosterCommandBarPlugin.promptForLink(); }
    },
    {
        key: exports.RoosterCommmandBarButtonKeys.Unlink,
        name: "Unlink",
        iconProps: _getIconProps("RemoveLink"),
        onRenderOptions: { customCacheKey: RenderOptionsNoCustomCacheKey, highContrastAssetName: "RemoveLink", assets: [{ name: "RemoveLinkChain" }, { name: "RemoveLinkX" }] },
        getDisabled: function (formatState) { return !formatState.canUnlink; },
        handleChange: function (editor) { return roosterjs_editor_api_1.removeLink(editor); }
    }
];
exports.OutOfBoxCommandBarButtons.forEach(function (button) {
    var asset = { name: button.name };
    button.onRenderOptions = button.onRenderOptions || { customCacheKey: RenderOptionsNoCustomCacheKey, assets: [asset] };
    button.className = exports.RoosterCommandBarButtonRootClassName;
});
exports.OutOfBoxCommandBarButtonMap = exports.OutOfBoxCommandBarButtons.reduce(function (result, item) {
    result[item.key] = item;
    return result;
}, {});
function _getIconProps(iconName) {
    return { className: exports.RoosterCommandBarIconClassName, iconName: iconName };
}
function _getCheckedForHeader(formatState) {
    return formatState.headerLevel === this.headerLevel;
}
function _handleChangeForHeader(editor, props, state) {
    if (state.formatState.headerLevel === this.headerLevel) {
        roosterjs_editor_api_1.toggleHeader(editor, 0);
    }
    else {
        roosterjs_editor_api_1.toggleHeader(editor, this.headerLevel);
    }
}
function _colorCellOnRender(item) {
    var _a = item.data, color = _a.color, cellBorderColor = _a.cellBorderColor;
    return (React.createElement(Button_1.DefaultButton, { className: "rooster-command-bar-color-button", title: item.title, key: item.key, onClick: function (ev) { return item.onClick(ev, item); } },
        cellBorderColor && React.createElement("div", { className: "rooster-command-bar-color-cell-border", style: { borderColor: cellBorderColor } }),
        React.createElement("svg", { className: "rooster-command-bar-color-cell", viewBox: "0 0 30 30", fill: color, focusable: "false" },
            React.createElement("rect", { width: "100%", height: "100%" }))));
}
function _handleChangeForFontColor(editor) {
    var color = this.data.color;
    roosterjs_editor_api_1.setTextColor(editor, color);
}
function _handleChangeForHighlight(editor) {
    var color = this.data.color;
    var selection = editor.getSelection();
    var backwards = false;
    if (!selection.isCollapsed) {
        var range = editor.getDocument().createRange();
        range.setStart(selection.anchorNode, selection.anchorOffset);
        range.setEnd(selection.focusNode, selection.focusOffset);
        backwards = range.collapsed;
    }
    roosterjs_editor_api_1.setBackgroundColor(editor, color);
    if (backwards) {
        selection.collapseToStart();
    }
    else {
        selection.collapseToEnd();
    }
}


/***/ }),

/***/ "./packages/roosterjs-react-command-bar/lib/utils/getIconOnRenderDelegate.tsx":
/*!************************************************************************************!*\
  !*** ./packages/roosterjs-react-command-bar/lib/utils/getIconOnRenderDelegate.tsx ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIconButtonOnRenderDelegate = exports.getIconOnRenderDelegateWithCustomCacheKey = exports.getIconOnRenderDelegate = void 0;
var Button_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Button */ "office-ui-fabric-react/lib/Button");
var Icon_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Icon */ "office-ui-fabric-react/lib/Icon");
var Tooltip_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Tooltip */ "office-ui-fabric-react/lib/Tooltip");
var React = __webpack_require__(/*! react */ "react");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
var OnRenderDelegateCache = {};
function getIconOnRenderDelegate(highContrastAssetName) {
    if (highContrastAssetName === void 0) { highContrastAssetName = null; }
    var assets = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        assets[_i - 1] = arguments[_i];
    }
    return getIconButtonOnRenderDelegate({ highContrastAssetName: highContrastAssetName, assets: assets });
}
exports.getIconOnRenderDelegate = getIconOnRenderDelegate;
function getIconOnRenderDelegateWithCustomCacheKey(customCacheKey, highContrastAssetName) {
    if (highContrastAssetName === void 0) { highContrastAssetName = null; }
    var assets = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        assets[_i - 2] = arguments[_i];
    }
    return getIconButtonOnRenderDelegate({ customCacheKey: customCacheKey, highContrastAssetName: highContrastAssetName, assets: assets });
}
exports.getIconOnRenderDelegateWithCustomCacheKey = getIconOnRenderDelegateWithCustomCacheKey;
function getIconButtonOnRenderDelegate(options) {
    var _a = options || {}, customCacheKey = _a.customCacheKey, assets = _a.assets, highContrastAssetName = _a.highContrastAssetName, tooltipDirectionHint = _a.tooltipDirectionHint;
    var cacheKey = customCacheKey != null ? customCacheKey : assets ? assets.map(function (a) { return a.name; }).join(".") : "";
    if (!OnRenderDelegateCache[cacheKey]) {
        var iconClassName_1 = "stacked-icon";
        var onRenderIcon_1 = undefined;
        if (assets && assets.length > 1) {
            onRenderIcon_1 = function () { return (React.createElement("div", { className: "stacked-icon-container" },
                assets.map(function (asset, i) { return (React.createElement(Icon_1.Icon, { key: i, iconName: asset.name, className: roosterjs_react_common_1.css(iconClassName_1, asset.className || iconClassName_1 + "-" + asset.name) })); }),
                highContrastAssetName && React.createElement(Icon_1.Icon, { iconName: highContrastAssetName, className: roosterjs_react_common_1.css(iconClassName_1, "high-contrast-icon") }))); };
        }
        var cmdButton_1 = null;
        OnRenderDelegateCache[cacheKey] = function (item) { return (React.createElement(Tooltip_1.TooltipHost, { hostClassName: "command-button-tool-tip", content: item.name, key: item.key, directionalHint: tooltipDirectionHint },
            React.createElement(Button_1.CommandBarButton, __assign({ componentRef: function (ref) { return (cmdButton_1 = ref); } }, item, { ariaLabel: item.name, menuProps: item.subMenuProps && __assign(__assign({}, item.subMenuProps), { onDismiss: function (ev) {
                        item.subMenuProps.onDismiss(ev);
                        cmdButton_1.dismissMenu();
                    } }), className: roosterjs_react_common_1.css("rooster-command-bar-button", item.buttonClassName), onRenderIcon: onRenderIcon_1 })))); };
    }
    return OnRenderDelegateCache[cacheKey];
}
exports.getIconButtonOnRenderDelegate = getIconButtonOnRenderDelegate;


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/index.ts":
/*!******************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/index.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AriaAttributes = exports.Base64Svgs = exports.UndoWithImagePlugin = exports.IgnorePasteImagePlugin = exports.PasteImagePlugin = exports.DoubleClickImagePlugin = exports.ContentChangedPlugin = exports.ImageManager = exports.getDataAndAriaProps = exports.css = exports.toggleNonCompatNumbering = exports.toggleNonCompatBullet = exports.setNonCompatIndentation = exports.closest = exports.NullFunction = exports.getString = exports.registerDefaultString = void 0;
var strings_1 = __webpack_require__(/*! ./strings/strings */ "./packages/roosterjs-react-common/lib/strings/strings.ts");
Object.defineProperty(exports, "registerDefaultString", { enumerable: true, get: function () { return strings_1.registerDefaultString; } });
Object.defineProperty(exports, "getString", { enumerable: true, get: function () { return strings_1.getString; } });
var Core_1 = __webpack_require__(/*! ./utils/Core */ "./packages/roosterjs-react-common/lib/utils/Core.ts");
Object.defineProperty(exports, "NullFunction", { enumerable: true, get: function () { return Core_1.NullFunction; } });
var ElementUtil_1 = __webpack_require__(/*! ./utils/ElementUtil */ "./packages/roosterjs-react-common/lib/utils/ElementUtil.ts");
Object.defineProperty(exports, "closest", { enumerable: true, get: function () { return ElementUtil_1.closest; } });
var NonCompatFormatter_1 = __webpack_require__(/*! ./utils/NonCompatFormatter */ "./packages/roosterjs-react-common/lib/utils/NonCompatFormatter.ts");
Object.defineProperty(exports, "setNonCompatIndentation", { enumerable: true, get: function () { return NonCompatFormatter_1.setNonCompatIndentation; } });
Object.defineProperty(exports, "toggleNonCompatBullet", { enumerable: true, get: function () { return NonCompatFormatter_1.toggleNonCompatBullet; } });
Object.defineProperty(exports, "toggleNonCompatNumbering", { enumerable: true, get: function () { return NonCompatFormatter_1.toggleNonCompatNumbering; } });
var ReactUtil_1 = __webpack_require__(/*! ./utils/ReactUtil */ "./packages/roosterjs-react-common/lib/utils/ReactUtil.ts");
Object.defineProperty(exports, "css", { enumerable: true, get: function () { return ReactUtil_1.css; } });
Object.defineProperty(exports, "getDataAndAriaProps", { enumerable: true, get: function () { return ReactUtil_1.getDataAndAriaProps; } });
var ImageManager_1 = __webpack_require__(/*! ./utils/ImageManager */ "./packages/roosterjs-react-common/lib/utils/ImageManager.ts");
Object.defineProperty(exports, "ImageManager", { enumerable: true, get: function () { return ImageManager_1.default; } });
var ContentChangedPlugin_1 = __webpack_require__(/*! ./plugins/ContentChangedPlugin */ "./packages/roosterjs-react-common/lib/plugins/ContentChangedPlugin.ts");
Object.defineProperty(exports, "ContentChangedPlugin", { enumerable: true, get: function () { return ContentChangedPlugin_1.default; } });
var DoubleClickImagePlugin_1 = __webpack_require__(/*! ./plugins/DoubleClickImagePlugin */ "./packages/roosterjs-react-common/lib/plugins/DoubleClickImagePlugin.ts");
Object.defineProperty(exports, "DoubleClickImagePlugin", { enumerable: true, get: function () { return DoubleClickImagePlugin_1.default; } });
var PasteImagePlugin_1 = __webpack_require__(/*! ./plugins/PasteImagePlugin */ "./packages/roosterjs-react-common/lib/plugins/PasteImagePlugin.ts");
Object.defineProperty(exports, "PasteImagePlugin", { enumerable: true, get: function () { return PasteImagePlugin_1.default; } });
var IgnorePasteImagePlugin_1 = __webpack_require__(/*! ./plugins/IgnorePasteImagePlugin */ "./packages/roosterjs-react-common/lib/plugins/IgnorePasteImagePlugin.ts");
Object.defineProperty(exports, "IgnorePasteImagePlugin", { enumerable: true, get: function () { return IgnorePasteImagePlugin_1.default; } });
var UndoWithImagePlugin_1 = __webpack_require__(/*! ./plugins/UndoWithImagePlugin */ "./packages/roosterjs-react-common/lib/plugins/UndoWithImagePlugin.ts");
Object.defineProperty(exports, "UndoWithImagePlugin", { enumerable: true, get: function () { return UndoWithImagePlugin_1.default; } });
var Images_1 = __webpack_require__(/*! ./resources/Images */ "./packages/roosterjs-react-common/lib/resources/Images.ts");
Object.defineProperty(exports, "Base64Svgs", { enumerable: true, get: function () { return Images_1.Base64Svgs; } });
var Accessibility_1 = __webpack_require__(/*! ./utils/Accessibility */ "./packages/roosterjs-react-common/lib/utils/Accessibility.ts");
Object.defineProperty(exports, "AriaAttributes", { enumerable: true, get: function () { return Accessibility_1.AriaAttributes; } });


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/plugins/ContentChangedPlugin.ts":
/*!*****************************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/plugins/ContentChangedPlugin.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ContentChangedPlugin = /** @class */ (function () {
    function ContentChangedPlugin(onChange) {
        var _this = this;
        this.onChange = onChange;
        this.onChangeEvent = function () {
            _this.onChange(_this.editor.getContent());
        };
    }
    ContentChangedPlugin.prototype.getName = function () {
        return 'ContentChanged';
    };
    ContentChangedPlugin.prototype.initialize = function (editor) {
        this.editor = editor;
        this.changeDisposer = this.editor.addDomEventHandler("input", this.onChangeEvent);
        this.textInputDisposer = this.editor.addDomEventHandler("textinput", this.onChangeEvent); // IE 11
        this.pasteDisposer = this.editor.addDomEventHandler("paste", this.onChangeEvent);
    };
    ContentChangedPlugin.prototype.onPluginEvent = function (event) {
        if (event && event.eventType === 6 /* ContentChanged */) {
            this.onChangeEvent();
        }
    };
    ContentChangedPlugin.prototype.dispose = function () {
        if (this.changeDisposer) {
            this.changeDisposer();
            this.changeDisposer = null;
        }
        if (this.textInputDisposer) {
            this.textInputDisposer();
            this.textInputDisposer = null;
        }
        if (this.pasteDisposer) {
            this.pasteDisposer();
            this.pasteDisposer = null;
        }
        this.editor = null;
    };
    return ContentChangedPlugin;
}());
exports.default = ContentChangedPlugin;


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/plugins/DoubleClickImagePlugin.ts":
/*!*******************************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/plugins/DoubleClickImagePlugin.ts ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var DoubleClickImagePlugin = /** @class */ (function () {
    function DoubleClickImagePlugin(doubleClickImageSelector) {
        var _this = this;
        if (doubleClickImageSelector === void 0) { doubleClickImageSelector = 'img'; }
        this.doubleClickImageSelector = doubleClickImageSelector;
        this.onDoubleClick = function (ev) {
            var target = ev.target;
            if (roosterjs_editor_dom_1.getTagOfNode(target) !== 'IMG') {
                return;
            }
            var src = target.getAttribute('src');
            if (!src) {
                return;
            }
            var parent = target.parentNode;
            var elements = parent ? [].slice.call(parent.querySelectorAll(_this.doubleClickImageSelector)) : [];
            if (elements.indexOf(target) < 0) {
                return;
            }
            var isDataUrl = src.indexOf('data:') === 0;
            var openedWindow = window.open(isDataUrl ? null : src, '_blank');
            if (openedWindow) {
                // noopener
                openedWindow.opener = null;
                if (isDataUrl) {
                    // for data URL, we need to create an image otherwise we'll get
                    // Window is not allowed to navigate Top-frame navigations to data URLs
                    openedWindow.document.body.innerHTML = "<img src=\"" + src + "\">";
                }
            }
        };
    }
    DoubleClickImagePlugin.prototype.getName = function () {
        return 'DoubleClickImage';
    };
    DoubleClickImagePlugin.prototype.initialize = function (editor) {
        this.editor = editor;
        this.onDoubleClickDisposer = this.editor.addDomEventHandler('dblclick', this.onDoubleClick);
    };
    DoubleClickImagePlugin.prototype.dispose = function () {
        if (this.editor) {
            this.editor = null;
            this.onDoubleClickDisposer();
        }
    };
    DoubleClickImagePlugin.prototype.getEditor = function () {
        return this.editor;
    };
    return DoubleClickImagePlugin;
}());
exports.default = DoubleClickImagePlugin;


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/plugins/IgnorePasteImagePlugin.ts":
/*!*******************************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/plugins/IgnorePasteImagePlugin.ts ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var IgnorePasteImagePlugin = /** @class */ (function () {
    function IgnorePasteImagePlugin() {
    }
    Object.defineProperty(IgnorePasteImagePlugin, "Instance", {
        get: function () {
            return IgnorePasteImagePlugin.InternalInstance;
        },
        enumerable: false,
        configurable: true
    });
    IgnorePasteImagePlugin.prototype.getName = function () {
        return 'IgnorePasteImage';
    };
    IgnorePasteImagePlugin.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    IgnorePasteImagePlugin.prototype.dispose = function () {
        if (this.editor) {
            this.editor = null;
        }
    };
    IgnorePasteImagePlugin.prototype.onPluginEvent = function (event) {
        if (event.eventType !== 9 /* BeforePaste */) {
            return;
        }
        var beforePasteEvent = event;
        if (beforePasteEvent.pasteOption !== 2 /* PasteImage */) {
            return;
        }
        // handle only before paste and image paste
        var editor = this.getEditor();
        if (!editor) {
            return;
        }
        // prevent pasting of image by telling the handler to interpret the paste as text
        beforePasteEvent.pasteOption = 1 /* PasteText */;
    };
    IgnorePasteImagePlugin.prototype.getEditor = function () {
        return this.editor;
    };
    IgnorePasteImagePlugin.InternalInstance = new IgnorePasteImagePlugin();
    return IgnorePasteImagePlugin;
}());
exports.default = IgnorePasteImagePlugin;


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/plugins/PasteImagePlugin.ts":
/*!*************************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/plugins/PasteImagePlugin.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ImageManager_1 = __webpack_require__(/*! ../utils/ImageManager */ "./packages/roosterjs-react-common/lib/utils/ImageManager.ts");
var PlaceholderRegex = new RegExp("<img [^>]*" + ImageManager_1.PlaceholderDataAttribute + "=\"\\d+\"[^>]*>", "gm");
var PasteImagePlugin = /** @class */ (function () {
    function PasteImagePlugin(imageManager, preventImagePaste) {
        if (preventImagePaste === void 0) { preventImagePaste = false; }
        this.imageManager = imageManager;
        this.preventImagePaste = preventImagePaste;
    }
    PasteImagePlugin.prototype.getName = function () {
        return 'PasteImage';
    };
    PasteImagePlugin.prototype.initialize = function (editor) {
        this.editor = editor;
    };
    PasteImagePlugin.prototype.dispose = function () {
        if (this.editor) {
            this.editor = null;
        }
    };
    PasteImagePlugin.prototype.onPluginEvent = function (event) {
        if (event.eventType === 7 /* ExtractContent */) {
            var extractContentEvent = event;
            var content = extractContentEvent.content;
            var runRemove = ImageManager_1.hasPlaceholder(content);
            if (runRemove) {
                extractContentEvent.content = content.replace(PlaceholderRegex, "");
            }
            return;
        }
        if (event.eventType !== 9 /* BeforePaste */) {
            return;
        }
        var beforePasteEvent = event;
        if (beforePasteEvent.pasteOption !== 2 /* PasteImage */) {
            return;
        }
        // handle only before paste and image paste
        var editor = this.getEditor();
        if (!editor) {
            return;
        }
        // prevent pasting of image by telling the handler to interpret the paste as text
        if (this.preventImagePaste) {
            beforePasteEvent.pasteOption = 1 /* PasteText */;
            return;
        }
        var image = beforePasteEvent.clipboardData.image;
        var placeholder = this.imageManager.upload(editor, image, true);
        if (placeholder === null) {
            return;
        }
        // modify the pasting content and option so Paste plugin won't handle
        beforePasteEvent.fragment.appendChild(placeholder);
        beforePasteEvent.clipboardData.html = placeholder.outerHTML;
        beforePasteEvent.pasteOption = 0 /* PasteHtml */;
    };
    PasteImagePlugin.prototype.setPreventImagePaste = function (enabled) {
        if (enabled === void 0) { enabled = true; }
        this.preventImagePaste = enabled;
    };
    PasteImagePlugin.prototype.getEditor = function () {
        return this.editor;
    };
    return PasteImagePlugin;
}());
exports.default = PasteImagePlugin;


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/plugins/UndoWithImagePlugin.ts":
/*!****************************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/plugins/UndoWithImagePlugin.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var ImageManager_1 = __webpack_require__(/*! ../utils/ImageManager */ "./packages/roosterjs-react-common/lib/utils/ImageManager.ts");
// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped
// to keep size under limit. This is kept at 10MB.
var MAXSIZELIMIT = 10000000;
var UndoSnapshotsWithImage = /** @class */ (function () {
    function UndoSnapshotsWithImage(imageManager, maxSize) {
        this.imageManager = imageManager;
        this.maxSize = maxSize;
        this.snapshots = [];
        this.totalSize = 0;
        this.currentIndex = -1;
    }
    UndoSnapshotsWithImage.prototype.canMove = function (delta) {
        var newIndex = this.currentIndex + delta;
        return newIndex >= 0 && newIndex < this.snapshots.length;
    };
    UndoSnapshotsWithImage.prototype.move = function (delta) {
        if (!this.canMove(delta)) {
            return null;
        }
        var lastIndex = this.currentIndex;
        this.currentIndex += delta;
        var snapshot = this.snapshots[this.currentIndex];
        // There is a chance snapshots were saved with placeholders. To resolve that,
        // we optimistically ask Image Manager to replace the placeholders with images,
        // since the manager caches placeholder IDs to final image URLs (when they are resolved).
        // The manager returns the final HTML and also if all of the placeholders are resolved.
        if (snapshot.hasPlaceholder) {
            var originalValue = snapshot.value;
            var result = this.imageManager.updatePlaceholders(originalValue);
            snapshot.hasPlaceholder = !result.resolvedAll;
            snapshot.value = result.html;
            var sizeDelta = originalValue.length - result.html.length;
            // if we undo/redo and the content is the same after updating the placeholders, keep moving
            // (we get two snapshots when inserting an image, one for the placeholder, and another when the placeholder is resolved)
            var lastSnapshot = this.snapshots[lastIndex];
            if (lastSnapshot && lastSnapshot.value === snapshot.value && delta !== 0) {
                // since content is the same, remove the last "duplicated" snapshot
                this.totalSize -= snapshot.value.length;
                this.snapshots.splice(lastIndex);
                // then, move again by one unit at a time and until content is different after resolving placeholders
                return this.move(delta < 0 ? -1 : 1);
            }
            else {
                // it is possible total size is greater at this point (unlikely if default spinner is used)
                this.totalSize -= sizeDelta;
            }
        }
        return snapshot.value;
    };
    UndoSnapshotsWithImage.prototype.addSnapshot = function (value) {
        if (this.currentIndex > -1 && value === this.snapshots[this.currentIndex].value) {
            return;
        }
        this.clearRedo();
        this.snapshots.push({ value: value, hasPlaceholder: ImageManager_1.hasPlaceholder(value) });
        ++this.currentIndex;
        this.totalSize += value.length;
        var removeCount = 0;
        while (removeCount < this.snapshots.length && this.totalSize > this.maxSize) {
            this.totalSize -= this.snapshots[removeCount].value.length;
            removeCount++;
        }
        if (removeCount > 0) {
            this.snapshots.splice(0, removeCount);
            this.currentIndex -= removeCount;
        }
    };
    UndoSnapshotsWithImage.prototype.clearRedo = function () {
        if (!this.canMove(1)) {
            return;
        }
        var removedSize = 0;
        for (var i = this.currentIndex + 1; i < this.snapshots.length; ++i) {
            removedSize += this.snapshots[i].value.length;
        }
        this.snapshots.splice(this.currentIndex + 1);
        this.totalSize -= removedSize;
    };
    return UndoSnapshotsWithImage;
}());
var UndoWithImagePlugin = /** @class */ (function (_super) {
    __extends(UndoWithImagePlugin, _super);
    /**
     * Create an instance of Undo
     * @param preserveSnapshots True to preserve the snapshots after dispose, this allows
     * this object to be reused when editor is disposed and created again
     * @param bufferSize The buffer size for snapshots. Default value is 10MB, it is possible after
     * placeholder to image resolution that buffer size is greater.
     */
    function UndoWithImagePlugin(imageManager, preserveSnapshots, bufferSize) {
        if (bufferSize === void 0) { bufferSize = MAXSIZELIMIT; }
        var _this = _super.call(this, preserveSnapshots, bufferSize) || this;
        _this.imageManager = imageManager;
        _this.bufferSize = bufferSize;
        return _this;
    }
    UndoWithImagePlugin.prototype.getSnapshotsManager = function () {
        if (!this.undoSnapshots) {
            this.undoSnapshots = new UndoSnapshotsWithImage(this.imageManager, this.bufferSize);
        }
        return this.undoSnapshots;
    };
    UndoWithImagePlugin.prototype.reset = function (initialContent) {
        this.clear();
        this.getSnapshotsManager().addSnapshot(initialContent);
    };
    return UndoWithImagePlugin;
}(roosterjs_editor_core_1.Undo));
exports.default = UndoWithImagePlugin;


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/resources/Images.ts":
/*!*****************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/resources/Images.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Base64Svgs = void 0;
exports.Base64Svgs = {
    // Note: just a simple SVG spinner (based on Office Fabric Spinner), decode Base64 to see the code
    RoosterJsReactSpinner: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJyZ2IoMCwgMTIwLCAyMTIpIiBzdHJva2Utd2lkdGg9IjEuNSIgZD0iTSAxNC41IDggQSA2LjUgNi41IDAgMCAwIDggMS41IiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiIgLz48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9InJnYigxOTksIDIyNCwgMjQ0KSIgc3Ryb2tlLXdpZHRoPSIxLjUiIGQ9Ik0gNy45OTk5OTk5OTk5OTk5OTkgMS41IEEgNi41IDYuNSAwIDEgMCAxNC41IDgiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIiAvPjwvc3ZnPg=="
};


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/scss/core.scss.g.ts":
/*!*****************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/scss/core.scss.g.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.roosterjsReactSpin = exports.roosterjsReactSpinner = void 0;
/* tslint:disable */
var load_themed_styles_1 = __webpack_require__(/*! @microsoft/load-themed-styles */ "./node_modules/@microsoft/load-themed-styles/lib-es6/index.js");
load_themed_styles_1.loadStyles([{ "rawString": "@-webkit-keyframes roosterjsReactSpin_a7c369ec{0%{-webkit-transform:rotateZ(0deg);transform:rotateZ(0deg)}100%{-webkit-transform:rotateZ(360deg);transform:rotateZ(360deg)}}@keyframes roosterjsReactSpin_a7c369ec{0%{-webkit-transform:rotateZ(0deg);transform:rotateZ(0deg)}100%{-webkit-transform:rotateZ(360deg);transform:rotateZ(360deg)}}.roosterjsReactSpinner_a7c369ec{-webkit-animation-name:roosterjsReactSpin_a7c369ec;animation-name:roosterjsReactSpin_a7c369ec;-webkit-animation-duration:1.3s;animation-duration:1.3s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:cubic-bezier(0.53, 0.21, 0.29, 0.67);animation-timing-function:cubic-bezier(0.53, 0.21, 0.29, 0.67);padding:0 4px}" }]);
exports.roosterjsReactSpinner = "roosterjsReactSpinner_a7c369ec";
exports.roosterjsReactSpin = "roosterjsReactSpin_a7c369ec";


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/strings/strings.ts":
/*!****************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/strings/strings.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getString = exports.registerDefaultString = void 0;
var defaultStrings = {};
function registerDefaultString(category, strings) {
    defaultStrings[category] = strings;
}
exports.registerDefaultString = registerDefaultString;
function getString(category, name, strings) {
    var str = (strings || {})[name];
    if (str == null) {
        str = defaultStrings[category][name];
    }
    return str;
}
exports.getString = getString;


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/utils/Accessibility.ts":
/*!********************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/utils/Accessibility.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AriaAttributes = void 0;
exports.AriaAttributes = {
    ActiveDescendant: "aria-activedescendant",
    AutoComplete: "aria-autocomplete",
    Controls: "aria-controls",
    Expanded: "aria-expanded",
    HasPopup: "aria-haspopup",
    Owns: "aria-owns",
    Pressed: "aria-pressed"
};


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/utils/Core.ts":
/*!***********************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/utils/Core.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NullFunction = void 0;
var NullFunction = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return undefined;
};
exports.NullFunction = NullFunction;


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/utils/ElementUtil.ts":
/*!******************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/utils/ElementUtil.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.closest = void 0;
function closest(element, query) {
    if (element && element.closest) {
        return element.closest(query);
    }
    // for IE11 and below
    while (element && !(element.matches || element.msMatchesSelector).call(element, query)) {
        element = element.parentElement;
    }
    return element;
}
exports.closest = closest;


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/utils/ImageManager.ts":
/*!*******************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/utils/ImageManager.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasPlaceholder = exports.PlaceholderDataAttribute = void 0;
var Images_1 = __webpack_require__(/*! ../resources/Images */ "./packages/roosterjs-react-common/lib/resources/Images.ts");
var Styles = __webpack_require__(/*! ../scss/core.scss.g */ "./packages/roosterjs-react-common/lib/scss/core.scss.g.ts");
var ReactUtil_1 = __webpack_require__(/*! ../utils/ReactUtil */ "./packages/roosterjs-react-common/lib/utils/ReactUtil.ts");
var PlaceholderDataName = 'paste-image-placeholder-804b751e';
exports.PlaceholderDataAttribute = "data-" + PlaceholderDataName;
function hasPlaceholder(html) {
    return html.indexOf(exports.PlaceholderDataAttribute) > -1; // quick and dirty check
}
exports.hasPlaceholder = hasPlaceholder;
var ImageManager = /** @class */ (function () {
    function ImageManager(options) {
        var _this = this;
        this.idToUrlImageCache = {};
        this.defaultCreateImagePlaceholder = function (editor, image) {
            if (editor.isDisposed()) {
                return null;
            }
            var result = editor.getDocument().createElement('img');
            result.src = Images_1.Base64Svgs.RoosterJsReactSpinner;
            result.className = ReactUtil_1.css(Styles.roosterjsReactSpinner, _this.options.placeholderImageClassName);
            return result;
        };
        this.options = __assign({}, options);
        this.options.createImagePlaceholder = this.options.createImagePlaceholder || this.defaultCreateImagePlaceholder;
        this.placeholderImageClasses = this.options.placeholderImageClassName ? this.options.placeholderImageClassName.split(' ') : undefined;
    }
    ImageManager.prototype.upload = function (editor, image, forceFallbackAltValue) {
        var _this = this;
        if (!image || image.size === 0) {
            return null;
        }
        var placeholder = this.options.createImagePlaceholder(editor, image);
        if (placeholder === null) {
            return null;
        }
        var altText = "";
        if (forceFallbackAltValue) {
            altText = this.options.fallbackAltValue;
        }
        else {
            altText = image.name || this.options.fallbackAltValue;
        }
        // note: add identification (to handle undo/redo scenarios)
        var placeholdId = (ImageManager.Id++).toString(10);
        placeholder.setAttribute(exports.PlaceholderDataAttribute, placeholdId);
        this.options.uploadImage(image).then(function (url) {
            // accepted, so replace the placeholder with final image
            _this.idToUrlImageCache[placeholdId] = url;
            if (editor.isDisposed() || !editor.contains(placeholder)) {
                return;
            }
            _this.replacePlaceholder(placeholder, url, editor, altText || "Image");
            _this.triggerChangeEvent(editor);
        }, function () {
            // rejected, so remove the placeholder
            if (editor.isDisposed() || !editor.contains(placeholder)) {
                return;
            }
            _this.idToUrlImageCache[placeholdId] = null;
            _this.removePlaceholder(placeholder, editor);
            _this.triggerChangeEvent(editor);
        });
        return placeholder;
    };
    ImageManager.prototype.updatePlaceholders = function (html) {
        // example: <TAG data-paste-image-placeholder-804b751e="10" />
        var container = document.createElement('div');
        container.innerHTML = html;
        var placeholders = container.querySelectorAll("[" + exports.PlaceholderDataAttribute + "]");
        var resolvedAll = true;
        for (var i = 0; i < placeholders.length; ++i) {
            var placeholder = placeholders[i];
            var id = placeholder.getAttribute(exports.PlaceholderDataAttribute);
            var url = this.idToUrlImageCache[id];
            if (url === undefined) {
                resolvedAll = false;
                continue;
            }
            if (url === null) {
                this.removePlaceholder(placeholder);
            }
            else {
                this.replacePlaceholder(placeholder, url);
            }
        }
        return { html: container.innerHTML, resolvedAll: resolvedAll };
    };
    ImageManager.prototype.triggerChangeEvent = function (editor) {
        editor.triggerContentChangedEvent('ImageManager');
    };
    ImageManager.prototype.removePlaceholder = function (placeholder, editor) {
        if (editor) {
            editor.deleteNode(placeholder);
            editor.addUndoSnapshot();
        }
        else {
            var parent_1 = placeholder.parentNode;
            if (parent_1) {
                parent_1.removeChild(placeholder);
            }
        }
    };
    ImageManager.prototype.replacePlaceholder = function (placeholder, url, editor, altText) {
        var _a;
        // just update attributes if placeholder is already an image tag
        var img;
        if (placeholder.tagName === 'IMG') {
            img = placeholder;
            img.src = url;
            (_a = img.classList).remove.apply(_a, __spreadArrays([Styles.roosterjsReactSpinner], this.placeholderImageClasses));
            placeholder.removeAttribute(exports.PlaceholderDataAttribute);
            if (img.classList.length === 0) {
                placeholder.removeAttribute('class');
            }
        }
        else {
            var doc = editor ? editor.getDocument() : document; // editor can be null when called from updatePlaceholders
            // create final IMG node
            img = doc.createElement('img');
            img.src = url;
            if (editor) {
                editor.replaceNode(placeholder, img);
                editor.addUndoSnapshot();
            }
            else {
                doc.replaceChild(img, placeholder);
            }
        }
        img.setAttribute("alt", altText);
    };
    ImageManager.Id = 0;
    return ImageManager;
}());
exports.default = ImageManager;


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/utils/NonCompatFormatter.ts":
/*!*************************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/utils/NonCompatFormatter.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.setNonCompatIndentation = exports.toggleNonCompatBullet = exports.toggleNonCompatNumbering = void 0;
var roosterjs_editor_api_1 = __webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js");
function execCommand(editor, command, addUndoSnapshotWhenCollapsed) {
    editor.focus();
    var formatter = function () { return editor.getDocument().execCommand(command, false, null); };
    var range = editor.getSelectionRange();
    if (range && range.collapsed && !addUndoSnapshotWhenCollapsed) {
        formatter();
    }
    else {
        editor.addUndoSnapshot(formatter);
    }
}
/**
 * Toggle numbering at selection
 * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one
 * If selection contains bullet list, toggle numbering will convert the bullet list into number list
 * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
 * realization of browser execCommand API
 * @param editor The editor instance
 */
function toggleNonCompatNumbering(editor) {
    execCommand(editor, "insertOrderedList" /* InsertOrderedList */, true);
}
exports.toggleNonCompatNumbering = toggleNonCompatNumbering;
/**
 * Toggle bullet at selection
 * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one
 * If selection contains number list, toggle bullet will convert the number list into bullet list
 * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
 * browser execCommand API
 * @param editor The editor instance
 */
function toggleNonCompatBullet(editor) {
    execCommand(editor, "insertUnorderedList" /* InsertUnorderedList */, true);
}
exports.toggleNonCompatBullet = toggleNonCompatBullet;
/**
 * Set indentation at selection
 * If selection contains bullet/numbering list, increase/decrease indentation will
 * increase/decrease the list level by one.
 * @param editor The editor instance
 * @param indentation The indentation option:
 * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation
 */
function setNonCompatIndentation(editor, indentation) {
    editor.focus();
    var command = indentation == 0 /* Increase */ ? 'indent' : 'outdent';
    editor.addUndoSnapshot(function () {
        var format = roosterjs_editor_api_1.getFormatState(editor);
        editor.getDocument().execCommand(command, false, null);
        if (!format.isBullet && !format.isNumbering) {
            editor.queryElements('blockquote', 1 /* OnSelection */, function (node) {
                node.style.marginTop = '0';
                node.style.marginBottom = '0';
            });
        }
    });
}
exports.setNonCompatIndentation = setNonCompatIndentation;


/***/ }),

/***/ "./packages/roosterjs-react-common/lib/utils/ReactUtil.ts":
/*!****************************************************************!*\
  !*** ./packages/roosterjs-react-common/lib/utils/ReactUtil.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getDataAndAriaProps = exports.css = void 0;
var CssHandlers = {
    object: function (obj, result) {
        for (var key in obj) {
            if (obj[key]) {
                result.push(key);
            }
        }
    },
    string: function (str, result) { return result.push(str); }
};
function css() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var result = [];
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var arg = args_1[_a];
        var handler = CssHandlers[typeof arg];
        if (arg && handler) {
            handler(arg, result);
        }
    }
    return result.join(' ');
}
exports.css = css;
function reduceObject(object, callback) {
    if (!object) {
        return object;
    }
    return Object.keys(object).reduce(function (result, key) {
        if (callback(key)) {
            result[key] = object[key];
        }
        return result;
    }, {});
}
function getDataAndAriaProps(props) {
    return reduceObject(props || {}, function (propName) { return propName.indexOf('data-') === 0 || propName.indexOf('aria-') === 0; });
}
exports.getDataAndAriaProps = getDataAndAriaProps;


/***/ }),

/***/ "./packages/roosterjs-react-editor/lib/components/FocusOutShell.tsx":
/*!**************************************************************************!*\
  !*** ./packages/roosterjs-react-editor/lib/components/FocusOutShell.tsx ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// Note: keep the dependencies for this generic component at a minimal (e.g. don't import OfficeFabric)
var React = __webpack_require__(/*! react */ "react");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
var FocusOutShell = /** @class */ (function (_super) {
    __extends(FocusOutShell, _super);
    function FocusOutShell(props) {
        var _this = _super.call(this, props) || this;
        _this._calloutClassName = FocusOutShell.CalloutClassName + "-" + FocusOutShell.NextId++;
        _this._calloutOnDismiss = function (ev) {
            // command bar can trigger dismiss event w/o an event object for submenu (when
            // button is clicked again to hide submenu)
            if (!ev) {
                return;
            }
            // For Callout component, target is the event object from the document.body focus event
            var nextTarget = ev.target;
            if (_this._shouldCallBlur(nextTarget)) {
                // delay so callout dismiss can complete
                requestAnimationFrame(function () {
                    var _a = _this.props.onBlur, onBlur = _a === void 0 ? roosterjs_react_common_1.NullFunction : _a;
                    onBlur(ev);
                    _this.setState({ isFocused: false });
                });
            }
        };
        _this._onBlur = function (ev) {
            // relatedTarget is the event object from the blur event, so it is the next focused element
            var nextTarget = ev.relatedTarget;
            if (_this._shouldCallBlur(nextTarget)) {
                var _a = _this.props.onBlur, onBlur = _a === void 0 ? roosterjs_react_common_1.NullFunction : _a;
                onBlur(ev);
                _this.setState({ isFocused: false });
            }
        };
        _this._shouldCallBlurDefault = function (nextTarget) {
            // don't call blur if the next target is an element on this container
            if (nextTarget && _this._containerDiv.contains(nextTarget)) {
                return false;
            }
            // similarly, don't call blur if the next target is the callout or its children
            if (nextTarget == null && roosterjs_editor_dom_1.Browser.isIE) {
                nextTarget = document.activeElement;
            }
            if (nextTarget && roosterjs_react_common_1.closest(nextTarget, "." + _this._calloutClassName)) {
                return false;
            }
            return true;
        };
        _this._onFocus = function (ev) {
            if (!_this.state.isFocused) {
                var _a = _this.props.onFocus, onFocus = _a === void 0 ? roosterjs_react_common_1.NullFunction : _a;
                onFocus(ev);
            }
        };
        // React onFocus isn't reliable, hook into native version instead
        _this._onFocusNative = function (ev) {
            _this.setState({ isFocused: true });
        };
        _this._onMouseDown = function (ev) {
            var _a = _this.props.allowMouseDown, allowMouseDown = _a === void 0 ? roosterjs_react_common_1.NullFunction : _a;
            var target = ev.target;
            if (allowMouseDown(target)) {
                return;
            }
            ev.preventDefault(); // prevents blur event from triggering
        };
        _this._containerDivOnRef = function (ref) {
            _this._containerDiv = ref;
            var eventName = "focusin";
            if (_this._containerDiv) {
                _this._containerDiv.removeEventListener(eventName, _this._onFocusNative);
            }
            if (ref) {
                ref.addEventListener(eventName, _this._onFocusNative);
            }
        };
        _this.state = { isFocused: false };
        return _this;
    }
    FocusOutShell.prototype.render = function () {
        var _a = this.props, className = _a.className, children = _a.children;
        return (React.createElement("div", { className: roosterjs_react_common_1.css(FocusOutShell.BaseClassName, className, { "is-focused": this.state.isFocused }), ref: this._containerDivOnRef, onBlur: this._onBlur, onFocus: this._onFocus, onMouseDown: this._onMouseDown }, children(this._calloutClassName, this._calloutOnDismiss)));
    };
    FocusOutShell.prototype._shouldCallBlur = function (nextTarget) {
        var _a = this.props.shouldCallBlur, shouldCallBlur = _a === void 0 ? this._shouldCallBlurDefault : _a;
        return shouldCallBlur(nextTarget, this._shouldCallBlurDefault);
    };
    FocusOutShell.BaseClassName = "focus-out-shell";
    FocusOutShell.CalloutClassName = FocusOutShell.BaseClassName + "-callout";
    FocusOutShell.NextId = 0;
    return FocusOutShell;
}(React.PureComponent));
exports.default = FocusOutShell;


/***/ }),

/***/ "./packages/roosterjs-react-editor/lib/components/LeanRooster.scss.g.ts":
/*!******************************************************************************!*\
  !*** ./packages/roosterjs-react-editor/lib/components/LeanRooster.scss.g.ts ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
var load_themed_styles_1 = __webpack_require__(/*! @microsoft/load-themed-styles */ "./node_modules/@microsoft/load-themed-styles/lib-es6/index.js");
load_themed_styles_1.loadStyles([{ "rawString": ".lean-rooster{padding:4px}.lean-rooster img{max-width:100%;-ms-flex-item-align:center;align-self:center}.lean-rooster.show-placeholder::before{color:rgba(0,0,0,.55);content:attr(data-placeholder);cursor:text;font-style:italic;pointer-events:none}" }]);


/***/ }),

/***/ "./packages/roosterjs-react-editor/lib/components/LeanRooster.tsx":
/*!************************************************************************!*\
  !*** ./packages/roosterjs-react-editor/lib/components/LeanRooster.tsx ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! ./LeanRooster.scss.g */ "./packages/roosterjs-react-editor/lib/components/LeanRooster.scss.g.ts");
var React = __webpack_require__(/*! react */ "react");
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var roosterjs_editor_dom_1 = __webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js");
var roosterjs_editor_plugins_1 = __webpack_require__(/*! roosterjs-editor-plugins */ "./node_modules/roosterjs-editor-plugins/lib/index.js");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
var ContentEditableDivStyle = { userSelect: "text", msUserSelect: "text", WebkitUserSelect: "text" };
var ReadOnlyClassName = "readonly";
var LeanRooster = /** @class */ (function (_super) {
    __extends(LeanRooster, _super);
    function LeanRooster(props) {
        var _this = _super.call(this, props) || this;
        _this._mode = 0 /* View */;
        // Note: set React DIV up with an intial inner HTML, but don't change it after creating rooster editor, otherwise
        // React will recreate the elements defined by the inner HTML
        _this._initialContent = undefined;
        _this._editorOptions = null;
        _this._hasPlaceholder = false;
        _this._placeholderVisible = false;
        _this._refreshPlaceholder = function () {
            var isEmpty = _this.props.placeholder && _this.isEmpty();
            var wasPlaceholderVisible = _this._placeholderVisible;
            var hasFocus = _this._editor && _this._editor.hasFocus();
            _this._hasPlaceholder = isEmpty;
            _this._placeholderVisible = isEmpty && !hasFocus;
            // refresh if the placeholder's visibility was changed
            if (wasPlaceholderVisible !== _this._placeholderVisible) {
                _this.forceUpdate();
            }
        };
        _this._onHyperlinkClick = function (anchor, mouseEvent) {
            var _a = _this.props.onHyperlinkClick, onHyperlinkClick = _a === void 0 ? function (_) { return false; } : _a;
            return onHyperlinkClick(anchor, mouseEvent);
        };
        _this._hyperlinkToolTipCallback = function (href, anchor) {
            var _a = _this.props.hyperlinkToolTipCallback, hyperlinkToolTipCallback = _a === void 0 ? function (href, _) { return href; } : _a;
            return hyperlinkToolTipCallback(href, anchor);
        };
        _this._updateViewState = function (viewState, content, isInitializing) {
            if (viewState.content !== content) {
                viewState.content = content;
                if (!isInitializing) {
                    var originalContent = _this._initialContent ? _this._initialContent.__html : null;
                    viewState.isDirty = content !== originalContent;
                }
            }
        };
        _this._onMouseDown = function (ev) {
            var target = ev.target;
            var anchor = _this._getAnchorForClickOpenHyperlink(ev, target);
            if (anchor) {
                // we're going to handle click for the href, so don't switch to view mode
                ev.preventDefault();
                ev.stopPropagation();
                return;
            }
            _this._placeholderVisible = false;
            var forceUpdate = true;
            _this._trySwithToEditMode(forceUpdate);
        };
        _this._onMouseUp = function (ev) {
            var target = ev.target;
            var anchor = _this._getAnchorForClickOpenHyperlink(ev, target);
            if (anchor) {
                var onHyperlinkClick = _this.props.onHyperlinkClick;
                // if editor has already activated, let the Hyperlink plugin call onHyperlinkClick
                if (_this.hasActivated && onHyperlinkClick) {
                    return;
                }
                // if no custom click handler or it returned false, open the link
                if (!onHyperlinkClick || onHyperlinkClick(anchor, ev.nativeEvent) === false) {
                    try {
                        window.open(anchor.getAttribute("href"), "_blank");
                    }
                    catch (_a) { }
                }
                return;
            }
            if (_this._editor && !_this._editor.hasFocus()) {
                _this._editor.focus();
            }
        };
        _this._onBlur = function (ev) {
            var _a = _this.props.onBlur, onBlur = _a === void 0 ? roosterjs_react_common_1.NullFunction : _a;
            _this._hasPlaceholder = false; // reset flag each time we blur
            var content = _this._updateContentToViewState();
            if (content !== null) {
                _this._refreshPlaceholder();
            }
            onBlur(ev);
        };
        _this._onDragEnter = function (ev) {
            var _a = _this.props.onDragEnter, onDragEnter = _a === void 0 ? roosterjs_react_common_1.NullFunction : _a;
            onDragEnter(ev);
        };
        _this._onDragLeave = function (ev) {
            var _a = _this.props.onDragLeave, onDragLeave = _a === void 0 ? roosterjs_react_common_1.NullFunction : _a;
            onDragLeave(ev);
        };
        _this._onDragOver = function (ev) {
            var _a = _this.props.onDragOver, onDragOver = _a === void 0 ? roosterjs_react_common_1.NullFunction : _a;
            onDragOver(ev);
        };
        _this._onFocus = function (ev) {
            var _a = _this.props.onFocus, onFocus = _a === void 0 ? roosterjs_react_common_1.NullFunction : _a;
            onFocus(ev);
        };
        // When used with FocusOutShell and CommandBar, React doesn't fire focus event when toggle
        // buttons with callout, so use the native event which is still triggered.
        _this._onFocusNative = function (ev) {
            var forceUpdate = false;
            if (_this._placeholderVisible) {
                _this._placeholderVisible = false;
                forceUpdate = true;
            }
            if (_this._trySwithToEditMode(forceUpdate)) {
                _this._editor.focus();
            }
        };
        _this._onDrop = function (ev) {
            var _a = _this.props.onDrop, onDrop = _a === void 0 ? roosterjs_react_common_1.NullFunction : _a;
            // handles the drop content scenario when editor is not yet activated and there's a placeholder
            if (_this._contentDiv) {
                _this.focus();
            }
            onDrop(ev);
        };
        _this._contentDivOnRef = function (ref) {
            var _a = _this.props, _b = _a.contentDivRef, contentDivRef = _b === void 0 ? roosterjs_react_common_1.NullFunction : _b, plugins = _a.plugins;
            var eventName = "focus";
            if (_this._contentDiv) {
                _this._contentDiv.removeEventListener(eventName, _this._onFocusNative);
            }
            if (ref) {
                ref.addEventListener(eventName, _this._onFocusNative);
            }
            _this._contentDiv = ref;
            plugins.forEach(function (p) { return p.initializeContentEditable && p.initializeContentEditable(ref); });
            contentDivRef(ref);
        };
        _this._setInitialReactContent(true);
        _this._editorOptions = _this._createEditorOptions();
        return _this;
    }
    LeanRooster.prototype.render = function () {
        var _a = this.props, isRtl = _a.isRtl, readonly = _a.readonly;
        return (
        // tslint:disable-next-line: react-no-dangerous-html
        React.createElement("div", __assign({}, roosterjs_react_common_1.getDataAndAriaProps(this.props), { className: this._getClassName(this.props), "data-placeholder": this.props.placeholder, contentEditable: !readonly, dir: this._getDirValue(isRtl), onBlur: this._onBlur, onFocus: this._onFocus, onMouseDown: this._onMouseDown, onMouseUp: this._onMouseUp, onDragEnter: this._onDragEnter, onDragLeave: this._onDragLeave, onDragOver: this._onDragOver, onDrop: this._onDrop, ref: this._contentDivOnRef, style: ContentEditableDivStyle, suppressContentEditableWarning: true, tabIndex: 0, dangerouslySetInnerHTML: this._initialContent, "aria-multiline": "true", role: "textbox" })));
    };
    LeanRooster.prototype.componentDidMount = function () {
        var _a = this.props, readonly = _a.readonly, activateRoosterOnMount = _a.activateRoosterOnMount, activateInViewMode = _a.activateInViewMode;
        if (!readonly && activateRoosterOnMount) {
            if (activateInViewMode) {
                this._editor = new roosterjs_editor_core_1.Editor(this._contentDiv, this._editorOptions);
                this._updateContentToViewState(true /* isInitializing */);
            }
            else {
                this._trySwithToEditMode();
            }
        }
        else if (!this._hasPlaceholder) {
            this._refreshPlaceholder();
        }
    };
    LeanRooster.prototype.componentWillUnmount = function () {
        this._updateContentToViewState();
        if (this._editor) {
            this._editor.dispose();
            this._editor = null;
        }
    };
    LeanRooster.prototype.componentWillReceiveProps = function (nextProps, nextState) {
        var div = this._contentDiv;
        if (!div) {
            return;
        }
        var className = nextProps.className, readonly = nextProps.readonly, isRtl = nextProps.isRtl, placeholder = nextProps.placeholder;
        if (className !== this.props.className) {
            div.setAttribute("class", this._getClassName(nextProps));
        }
        if (readonly !== this.props.readonly) {
            if (readonly) {
                div.classList.add(ReadOnlyClassName);
            }
            else {
                div.classList.remove(ReadOnlyClassName);
            }
            div.setAttribute("contentEditable", (!readonly).toString());
        }
        if (isRtl !== this.props.isRtl) {
            div.setAttribute("dir", this._getDirValue(isRtl));
        }
        if (placeholder !== this.props.placeholder) {
            div.setAttribute("data-placeholder", placeholder == null ? "" : placeholder);
        }
    };
    LeanRooster.prototype.shouldComponentUpdate = function () {
        return false;
    };
    Object.defineProperty(LeanRooster.prototype, "mode", {
        get: function () {
            return this._mode;
        },
        set: function (value) {
            if (value === 1 /* Edit */) {
                this._trySwithToEditMode();
            }
            else {
                this._trySwitchToViewMode();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LeanRooster.prototype, "hasActivated", {
        get: function () {
            return !!this._editor;
        },
        enumerable: false,
        configurable: true
    });
    LeanRooster.prototype.hasPlaceholder = function () {
        return this._hasPlaceholder;
    };
    LeanRooster.prototype.focus = function () {
        if (this._editor) {
            this._editor.focus();
        }
        else if (this._contentDiv) {
            this._contentDiv.focus();
        }
    };
    LeanRooster.prototype.reloadContent = function (triggerContentChangedEvent, resetUndo) {
        if (triggerContentChangedEvent === void 0) { triggerContentChangedEvent = true; }
        if (resetUndo === void 0) { resetUndo = true; }
        var viewState = this.props.viewState;
        if (this._editor) {
            this._editor.setContent(viewState.content, triggerContentChangedEvent);
            if (resetUndo && this._editorOptions.undo) {
                this._editorOptions.undo.clear();
                this._editor.addUndoSnapshot();
            }
            this._refreshPlaceholder();
        }
        else {
            this._setInitialReactContent();
            this.forceUpdate(this._refreshPlaceholder);
        }
    };
    LeanRooster.prototype.triggerContentChangedEvent = function (source) {
        this._editor && this._editor.triggerContentChangedEvent(source);
    };
    LeanRooster.prototype.selectAll = function () {
        var contentDiv = this._contentDiv;
        if (!contentDiv) {
            return;
        }
        if (this._editor && !this._editor.isDisposed()) {
            var range = this._editor.getDocument().createRange();
            range.selectNodeContents(contentDiv);
            this._editor.select(range);
        }
        else {
            var range = contentDiv.ownerDocument.createRange();
            range.selectNodeContents(contentDiv);
            var selection = window.getSelection();
            // Workaround IE exception 800a025e
            try {
                selection.removeAllRanges();
            }
            catch (e) { }
            selection.addRange(range);
        }
    };
    LeanRooster.prototype.isEmpty = function () {
        var _a = this.props, _b = _a.trimWithEmptyCheck, trimWithEmptyCheck = _b === void 0 ? false : _b, thresholdForIsEmptyCheck = _a.thresholdForIsEmptyCheck, viewState = _a.viewState, _c = _a.isEmptyFunction, isEmptyFunction = _c === void 0 ? roosterjs_editor_dom_1.isNodeEmpty : _c;
        if (!this._contentDiv) {
            return !viewState.content || viewState.content.length === 0;
        }
        if (thresholdForIsEmptyCheck && this._contentDiv.innerHTML.length >= thresholdForIsEmptyCheck) {
            return false;
        }
        return isEmptyFunction(this._contentDiv, trimWithEmptyCheck);
    };
    LeanRooster.prototype.getContent = function () {
        return this._editor ? this._editor.getContent() : this._contentDiv.innerHTML;
    };
    LeanRooster.prototype._getClassName = function (props) {
        var className = props.className, readonly = props.readonly;
        var modeClassName = this.mode === 0 /* View */ ? "view-mode" : "edit-mode";
        return roosterjs_react_common_1.css("lean-rooster", className, modeClassName, {
            readonly: readonly,
            "show-placeholder": this._placeholderVisible
        });
    };
    LeanRooster.prototype._getDirValue = function (isRtl) {
        return isRtl ? "rtl" : "ltr";
    };
    LeanRooster.prototype._setInitialReactContent = function (fromConstructor) {
        if (fromConstructor === void 0) { fromConstructor = false; }
        var viewState = this.props.viewState;
        var hasContent = viewState.content != null && viewState.content.length > 0;
        if (fromConstructor) {
            this._hasPlaceholder = this.props.placeholder && !hasContent;
            this._placeholderVisible = this._hasPlaceholder;
        }
        this._initialContent = hasContent ? { __html: viewState.content } : undefined;
    };
    LeanRooster.prototype._updateContentToViewState = function (isInitializing) {
        if (this._editor && !this._editor.isDisposed()) {
            var _a = this.props, _b = _a.updateViewState, updateViewState = _b === void 0 ? this._updateViewState : _b, viewState = _a.viewState;
            var content = this._editor.getContent();
            updateViewState(viewState, content, isInitializing);
            return content;
        }
        return null;
    };
    LeanRooster.prototype._createEditorOptions = function () {
        var _a = this.props, _b = _a.plugins, additionalPlugins = _b === void 0 ? [] : _b, _c = _a.undo, undo = _c === void 0 ? new roosterjs_editor_core_1.Undo() : _c, _d = _a.defaultFormat, defaultFormat = _d === void 0 ? {} : _d, contentEditFeatures = _a.contentEditFeatures, enableRestoreSelectionOnFocus = _a.enableRestoreSelectionOnFocus, coreApiOverride = _a.coreApiOverride, sanitizeAttributeCallbacks = _a.sanitizeAttributeCallbacks;
        var plugins = __spreadArrays([
            new roosterjs_editor_plugins_1.ContentEdit(__assign(__assign(__assign({}, roosterjs_editor_plugins_1.getDefaultContentEditFeatures()), { defaultShortcut: false, smartOrderedList: true }), contentEditFeatures)),
            new roosterjs_editor_plugins_1.HyperLink(this._hyperlinkToolTipCallback, undefined, this._onHyperlinkClick),
            new roosterjs_editor_plugins_1.Paste(null, __assign({ istemptitle: function (v) { return v; } }, sanitizeAttributeCallbacks))
        ], additionalPlugins);
        var disableRestoreSelectionOnFocus = !enableRestoreSelectionOnFocus;
        // Important: don't set the initial content, the content editable already starts with initial HTML content
        return { plugins: plugins, defaultFormat: defaultFormat, undo: undo, disableRestoreSelectionOnFocus: disableRestoreSelectionOnFocus, omitContentEditableAttributeChanges: true /* avoid unnecessary reflow */, coreApiOverride: coreApiOverride };
    };
    LeanRooster.prototype._trySwithToEditMode = function (alwaysForceUpdateForEditMode) {
        if (alwaysForceUpdateForEditMode === void 0) { alwaysForceUpdateForEditMode = false; }
        var _a = this.props, readonly = _a.readonly, _b = _a.onBeforeModeChange, onBeforeModeChange = _b === void 0 ? roosterjs_react_common_1.NullFunction : _b, _c = _a.onAfterModeChange, onAfterModeChange = _c === void 0 ? roosterjs_react_common_1.NullFunction : _c;
        if (readonly) {
            return false;
        }
        if (this.mode === 1 /* Edit */) {
            if (alwaysForceUpdateForEditMode) {
                this.forceUpdate();
            }
            return false;
        }
        if (onBeforeModeChange(1 /* Edit */)) {
            return;
        }
        var isInitializing = !this._editor;
        if (isInitializing) {
            this._editor = new roosterjs_editor_core_1.Editor(this._contentDiv, this._editorOptions);
        }
        this._mode = 1 /* Edit */;
        this._updateContentToViewState(isInitializing);
        this.forceUpdate();
        onAfterModeChange(1 /* Edit */);
        return true;
    };
    LeanRooster.prototype._trySwitchToViewMode = function () {
        var _a = this.props, _b = _a.onBeforeModeChange, onBeforeModeChange = _b === void 0 ? roosterjs_react_common_1.NullFunction : _b, _c = _a.onAfterModeChange, onAfterModeChange = _c === void 0 ? roosterjs_react_common_1.NullFunction : _c;
        if (this.mode === 0 /* View */) {
            return false;
        }
        if (onBeforeModeChange(0 /* View */)) {
            return false;
        }
        this._updateContentToViewState();
        this._mode = 0 /* View */;
        this.forceUpdate();
        onAfterModeChange(0 /* View */);
        return true;
    };
    LeanRooster.prototype._getAnchorForClickOpenHyperlink = function (ev, element) {
        var _a = this.props, clickOpenHyperlinkViewMode = _a.clickOpenHyperlinkViewMode, readonly = _a.readonly;
        var isPrimaryButton = ev.button === 0;
        if (!isPrimaryButton || !clickOpenHyperlinkViewMode || readonly || this.mode !== 0 /* View */) {
            return null;
        }
        // Hyperlink plugin will handle CTRL+Click when editor is created and FireFox will handle for contenteditable
        var ctrlOpen = roosterjs_editor_dom_1.Browser.isMac ? ev.metaKey : ev.ctrlKey;
        if ((this._editor && ctrlOpen) || (roosterjs_editor_dom_1.Browser.isFirefox && ctrlOpen)) {
            return null;
        }
        var anchor = roosterjs_editor_dom_1.findClosestElementAncestor(element, this._contentDiv, "a[href]");
        if (anchor) {
            return anchor;
        }
        return null;
    };
    return LeanRooster;
}(React.Component));
exports.default = LeanRooster;


/***/ }),

/***/ "./packages/roosterjs-react-editor/lib/index.ts":
/*!******************************************************!*\
  !*** ./packages/roosterjs-react-editor/lib/index.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LeanRooster = exports.FocusOutShell = exports.createFormatState = exports.createEditorViewState = void 0;
var createEditorViewState_1 = __webpack_require__(/*! ./utils/createEditorViewState */ "./packages/roosterjs-react-editor/lib/utils/createEditorViewState.ts");
Object.defineProperty(exports, "createEditorViewState", { enumerable: true, get: function () { return createEditorViewState_1.default; } });
var createFormatState_1 = __webpack_require__(/*! ./utils/createFormatState */ "./packages/roosterjs-react-editor/lib/utils/createFormatState.ts");
Object.defineProperty(exports, "createFormatState", { enumerable: true, get: function () { return createFormatState_1.default; } });
var FocusOutShell_1 = __webpack_require__(/*! ./components/FocusOutShell */ "./packages/roosterjs-react-editor/lib/components/FocusOutShell.tsx");
Object.defineProperty(exports, "FocusOutShell", { enumerable: true, get: function () { return FocusOutShell_1.default; } });
var LeanRooster_1 = __webpack_require__(/*! ./components/LeanRooster */ "./packages/roosterjs-react-editor/lib/components/LeanRooster.tsx");
Object.defineProperty(exports, "LeanRooster", { enumerable: true, get: function () { return LeanRooster_1.default; } });


/***/ }),

/***/ "./packages/roosterjs-react-editor/lib/utils/createEditorViewState.ts":
/*!****************************************************************************!*\
  !*** ./packages/roosterjs-react-editor/lib/utils/createEditorViewState.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var roosterjs_html_sanitizer_1 = __webpack_require__(/*! roosterjs-html-sanitizer */ "./node_modules/roosterjs-html-sanitizer/lib/index.js");
function createEditorViewState(initialContent, options) {
    return {
        content: roosterjs_html_sanitizer_1.HtmlSanitizer.sanitizeHtml(initialContent, options) || '',
        isDirty: false
    };
}
exports.default = createEditorViewState;


/***/ }),

/***/ "./packages/roosterjs-react-editor/lib/utils/createFormatState.ts":
/*!************************************************************************!*\
  !*** ./packages/roosterjs-react-editor/lib/utils/createFormatState.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function createFormatState() {
    return {
        fontName: '',
        fontSize: '',
        isBold: false,
        isItalic: false,
        isUnderline: false,
        backgroundColor: '',
        textColor: '',
        isBullet: false,
        isNumbering: false,
        isStrikeThrough: false,
        isSubscript: false,
        isSuperscript: false,
        isBlockQuote: false,
        canUnlink: false,
        canAddImageAltText: false,
        canUndo: false,
        canRedo: false,
    };
}
exports.default = createFormatState;


/***/ }),

/***/ "./packages/roosterjs-react-emoji/lib/components/EmojiIcon.tsx":
/*!*********************************************************************!*\
  !*** ./packages/roosterjs-react-emoji/lib/components/EmojiIcon.tsx ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var Utilities_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Utilities */ "office-ui-fabric-react/lib/Utilities");
var React = __webpack_require__(/*! react */ "react");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
var Styles = __webpack_require__(/*! ./emoji.scss.g */ "./packages/roosterjs-react-emoji/lib/components/emoji.scss.g.ts");
var EmojiIcon = /** @class */ (function (_super) {
    __extends(EmojiIcon, _super);
    function EmojiIcon() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EmojiIcon.prototype.render = function () {
        var _a;
        var _b = this.props, emoji = _b.emoji, onClick = _b.onClick, isSelected = _b.isSelected, onMouseOver = _b.onMouseOver, onFocus = _b.onFocus, strings = _b.strings, id = _b.id, className = _b.className, selectedClassName = _b.selectedClassName;
        var content = strings[emoji.description];
        return (React.createElement("button", __assign({ id: id, role: "option", className: Utilities_1.css(Styles.emoji, className, (_a = { "rooster-emoji-selected": isSelected }, _a[selectedClassName] = isSelected, _a)), onClick: onClick, onMouseOver: onMouseOver, onFocus: onFocus, "data-is-focusable": true, "aria-label": content, "aria-selected": isSelected }, roosterjs_react_common_1.getDataAndAriaProps(this.props)), emoji.codePoint || ""));
    };
    return EmojiIcon;
}(React.Component));
exports.default = EmojiIcon;


/***/ }),

/***/ "./packages/roosterjs-react-emoji/lib/components/EmojiNavBar.scss.g.ts":
/*!*****************************************************************************!*\
  !*** ./packages/roosterjs-react-emoji/lib/components/EmojiNavBar.scss.g.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.navBarTooltip = exports.selected = exports.navBarButton = exports.navBar = void 0;
/* tslint:disable */
var load_themed_styles_1 = __webpack_require__(/*! @microsoft/load-themed-styles */ "./node_modules/@microsoft/load-themed-styles/lib-es6/index.js");
load_themed_styles_1.loadStyles([{ "rawString": ".navBar_9329d3c7{height:40px;position:absolute;left:0;z-index:10;padding:2px 1px 0;background:#fff}.navBarButton_9329d3c7{background:#fff;height:40px;width:40px;border:0;border-bottom:solid 1px #dadada;display:inline-block;padding:0;margin:0}.navBarButton_9329d3c7::-moz-focus-inner{border:0}.navBarButton_9329d3c7:hover{background:#eaeaea;cursor:default}@media screen and (-ms-high-contrast: active){.navBarButton_9329d3c7:hover{background-color:Highlight;color:HighlightText;-ms-high-contrast-adjust:none}}@media screen and (-ms-high-contrast: active){.navBarButton_9329d3c7:hover .selected_9329d3c7{border:1px solid Highlight;background:none}}.selected_9329d3c7{border-bottom:2px solid #0078d4}@media screen and (-ms-high-contrast: active){.selected_9329d3c7{border-bottom-color:Highlight}}.navBarTooltip_9329d3c7{display:inline-block}" }]);
exports.navBar = "navBar_9329d3c7";
exports.navBarButton = "navBarButton_9329d3c7";
exports.selected = "selected_9329d3c7";
exports.navBarTooltip = "navBarTooltip_9329d3c7";


/***/ }),

/***/ "./packages/roosterjs-react-emoji/lib/components/EmojiNavBar.tsx":
/*!***********************************************************************!*\
  !*** ./packages/roosterjs-react-emoji/lib/components/EmojiNavBar.tsx ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var FocusZone_1 = __webpack_require__(/*! office-ui-fabric-react/lib/FocusZone */ "office-ui-fabric-react/lib/FocusZone");
var Icon_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Icon */ "office-ui-fabric-react/lib/Icon");
var Tooltip_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Tooltip */ "office-ui-fabric-react/lib/Tooltip");
var React = __webpack_require__(/*! react */ "react");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
var emojiList_1 = __webpack_require__(/*! ../utils/emojiList */ "./packages/roosterjs-react-emoji/lib/utils/emojiList.ts");
var EmojiNavBarStyles = __webpack_require__(/*! ./EmojiNavBar.scss.g */ "./packages/roosterjs-react-emoji/lib/components/EmojiNavBar.scss.g.ts");
var EmojiNavBar = /** @class */ (function (_super) {
    __extends(EmojiNavBar, _super);
    function EmojiNavBar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EmojiNavBar.prototype.render = function () {
        var _this = this;
        var _a = this.props, currentSelected = _a.currentSelected, getTabId = _a.getTabId, _b = _a.strings, strings = _b === void 0 ? {} : _b, className = _a.className, buttonClassName = _a.buttonClassName, selectedButtonClassName = _a.selectedButtonClassName, iconClassName = _a.iconClassName;
        var keys = Object.keys(emojiList_1.default);
        return (
        // for each emoji family key, create a button to use as nav bar
        React.createElement("div", { className: roosterjs_react_common_1.css(EmojiNavBarStyles.navBar, className), role: "tablist" },
            React.createElement(FocusZone_1.FocusZone, { direction: FocusZone_1.FocusZoneDirection.horizontal }, keys.map(function (key, index) {
                var _a;
                var selected = key === currentSelected;
                var friendlyName = strings[key];
                return (React.createElement(Tooltip_1.TooltipHost, { hostClassName: EmojiNavBarStyles.navBarTooltip, content: friendlyName, key: key },
                    React.createElement("button", { className: roosterjs_react_common_1.css(EmojiNavBarStyles.navBarButton, buttonClassName, "emoji-nav-bar-button", (_a = {},
                            _a[EmojiNavBarStyles.selected] = selected,
                            _a[selectedButtonClassName] = selected,
                            _a)), key: key, onClick: _this.onFamilyClick.bind(_this, key), id: getTabId(key), role: "tab", "aria-selected": selected, "aria-label": friendlyName, "data-is-focusable": "true", "aria-posinset": index + 1, "aria-setsize": keys.length },
                        React.createElement(Icon_1.Icon, { iconName: emojiList_1.EmojiFabricIconCharacterMap[key], className: iconClassName }))));
            }))));
    };
    EmojiNavBar.prototype.onFamilyClick = function (key) {
        if (this.props.onClick) {
            this.props.onClick(key);
        }
    };
    return EmojiNavBar;
}(React.Component));
exports.default = EmojiNavBar;


/***/ }),

/***/ "./packages/roosterjs-react-emoji/lib/components/EmojiPane.tsx":
/*!*********************************************************************!*\
  !*** ./packages/roosterjs-react-emoji/lib/components/EmojiPane.tsx ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var Callout_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Callout */ "office-ui-fabric-react/lib/Callout");
var FocusZone_1 = __webpack_require__(/*! office-ui-fabric-react/lib/FocusZone */ "office-ui-fabric-react/lib/FocusZone");
var TextField_1 = __webpack_require__(/*! office-ui-fabric-react/lib/TextField */ "office-ui-fabric-react/lib/TextField");
var Utilities_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Utilities */ "office-ui-fabric-react/lib/Utilities");
var React = __webpack_require__(/*! react */ "react");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
var emojiList_1 = __webpack_require__(/*! ../utils/emojiList */ "./packages/roosterjs-react-emoji/lib/utils/emojiList.ts");
var searchEmojis_1 = __webpack_require__(/*! ../utils/searchEmojis */ "./packages/roosterjs-react-emoji/lib/utils/searchEmojis.ts");
var Styles = __webpack_require__(/*! ./emoji.scss.g */ "./packages/roosterjs-react-emoji/lib/components/emoji.scss.g.ts");
var EmojiIcon_1 = __webpack_require__(/*! ./EmojiIcon */ "./packages/roosterjs-react-emoji/lib/components/EmojiIcon.tsx");
var EmojiNavBar_1 = __webpack_require__(/*! ./EmojiNavBar */ "./packages/roosterjs-react-emoji/lib/components/EmojiNavBar.tsx");
var EmojiStatusBar_1 = __webpack_require__(/*! ./EmojiStatusBar */ "./packages/roosterjs-react-emoji/lib/components/EmojiStatusBar.tsx");
// "When a div contains an element that is bigger (either taller or wider) than the parent and has the property
// overflow-x or overflow-y set to any value, then it can receive the focus."
// https://bugzilla.mozilla.org/show_bug.cgi?id=1069739
var TabIndexForFirefoxBug = -1;
var PaneBaseClassName = "rooster-emoji-pane";
var EmojisPerRow = 7;
var EmojiVisibleRowCount = 5;
var EmojiVisibleWithoutNavBarRowCount = 6;
var EmojiHeightPx = 40;
var VerticalDirectionKeys = [Utilities_1.KeyCodes.up, Utilities_1.KeyCodes.down];
var DirectionKeys = [Utilities_1.KeyCodes.left, Utilities_1.KeyCodes.right, Utilities_1.KeyCodes.up, Utilities_1.KeyCodes.down, Utilities_1.KeyCodes.home, Utilities_1.KeyCodes.end];
var TooltipCalloutProps = {
    isBeakVisible: true,
    beakWidth: 16,
    gapSpace: 0,
    setInitialFocus: true,
    doNotLayer: false,
    directionalHint: Callout_1.DirectionalHint.bottomCenter
};
var EmojiPane = /** @class */ (function (_super) {
    __extends(EmojiPane, _super);
    function EmojiPane(props) {
        var _this = _super.call(this, props) || this;
        _this._baseId = EmojiPane.IdCounter++;
        _this._listId = "EmojiPane" + _this._baseId;
        _this._onSearchFocus = function (e) {
            _this._input = e.target;
        };
        _this._onSearchKeyPress = function (e) {
            if (!e || e.which !== Utilities_1.KeyCodes.enter) {
                return;
            }
            var _a = _this.state, index = _a.index, currentEmojiList = _a.currentEmojiList;
            if (index >= 0 && currentEmojiList && currentEmojiList.length > 0) {
                _this._onSelect(e, currentEmojiList[index]);
            }
        };
        _this._onSearchKeyDown = function (e) {
            if (!e || DirectionKeys.indexOf(e.which) < 0) {
                return;
            }
            e.preventDefault();
            e.stopPropagation();
            var _emojiBody = _this._emojiBody;
            if (e.which === Utilities_1.KeyCodes.home) {
                _this.setState({ index: 0 });
                _emojiBody.scrollTop = 0;
                return;
            }
            if (e.which === Utilities_1.KeyCodes.end) {
                _this.setState({ index: _this.state.currentEmojiList.length - 1 });
                _emojiBody.scrollTop = _emojiBody.scrollHeight; // scrollHeight will be larger than max
                return;
            }
            var direction = VerticalDirectionKeys.indexOf(e.which) < 0 ? 0 /* Horizontal */ : 1 /* Vertical */;
            var newIndex = _this.navigate(e.which === Utilities_1.KeyCodes.left || e.which === Utilities_1.KeyCodes.up ? -1 : 1, direction);
            if (newIndex > -1) {
                var visibleRowCount = _this.state.mode === 2 /* Full */ ? EmojiVisibleRowCount : EmojiVisibleWithoutNavBarRowCount;
                var currentRow = Math.floor(newIndex / EmojisPerRow);
                var visibleTop = _emojiBody.scrollTop;
                var visibleBottom = visibleTop + visibleRowCount * EmojiHeightPx;
                var currentRowTop = currentRow * EmojiHeightPx;
                var currentRowBottom = currentRowTop + EmojiHeightPx;
                if (visibleTop <= currentRowTop && visibleBottom >= currentRowBottom) {
                    return; // row is visible, so exit
                }
                _emojiBody.scrollTop = currentRow * EmojiHeightPx;
            }
        };
        _this._onEmojiBodyRef = function (ref) {
            _this._emojiBody = ref;
        };
        _this._pivotClick = function (selected) {
            var currentFamily = selected;
            _this.setState({ currentEmojiList: emojiList_1.default[currentFamily], currentFamily: currentFamily });
        };
        _this._getTabId = function (itemKey) {
            return "family_" + itemKey + "_" + _this._baseId;
        };
        _this._searchRefCallback = function (ref) {
            _this._searchBox = ref;
            if (_this._searchBox) {
                _this._searchBox.focus();
                _this._searchBox.setSelectionStart(_this._searchBox.value.length);
            }
        };
        _this._focusZoneRefCallback = function (ref) {
            if (_this.props.searchDisabled && ref) {
                ref.focus();
            }
            if (_this._input) {
                // make sure to announce the active descending after the focus zone containing the emojis is ready
                _this._input.removeAttribute(roosterjs_react_common_1.AriaAttributes.ActiveDescendant);
                var emojiId_1 = _this._getEmojiIconId(_this.getSelectedEmoji());
                // we need to delay so NVDA will announce the first selection
                emojiId_1 && setTimeout(function () { return _this._input.setAttribute(roosterjs_react_common_1.AriaAttributes.ActiveDescendant, emojiId_1); }, 0);
            }
        };
        _this._onSearchChange = function (e, newValue) {
            var normalizedSearchValue = _this._normalizeSearchText(newValue, false);
            var newMode = normalizedSearchValue.length === 0 ? 2 /* Full */ : 1 /* Partial */;
            _this.setState({
                index: newMode === 2 /* Full */ ? -1 : 0,
                currentEmojiList: _this._getSearchResult(normalizedSearchValue, _this.state.mode),
                searchInBox: newValue,
                mode: newMode
            });
        };
        _this._onSelect = function (e, emoji) {
            e.stopPropagation();
            e.preventDefault();
            _this.props.onSelect && _this.props.onSelect(emoji, _this.state.search);
        };
        _this.state = {
            index: 0,
            mode: 0 /* Quick */,
            currentEmojiList: emojiList_1.CommonEmojis,
            currentFamily: "People" /* People */,
            search: ":",
            searchInBox: ""
        };
        return _this;
    }
    EmojiPane.prototype.render = function () {
        return this.state.mode === 0 /* Quick */ ? this._renderQuickPicker() : this._renderFullPicker();
    };
    EmojiPane.prototype.componentDidUpdate = function (_, prevState) {
        // call onLayoutChange when the call out parent of the EmojiPane needs to reorient itself on the page
        var _a = this.props, onLayoutChanged = _a.onLayoutChanged, onModeChanged = _a.onModeChanged;
        var _b = this.state, currentEmojiList = _b.currentEmojiList, mode = _b.mode, currentFamily = _b.currentFamily;
        if (mode !== prevState.mode) {
            onModeChanged(mode, prevState.mode);
            onLayoutChanged();
            return;
        }
        var currentEmojisLength = currentEmojiList ? currentEmojiList.length : emojiList_1.default[currentFamily].length;
        var prevEmojisLength = prevState.currentEmojiList ? prevState.currentEmojiList.length : emojiList_1.default[prevState.currentFamily].length;
        if (mode !== 0 /* Quick */ && currentEmojisLength !== prevEmojisLength) {
            onLayoutChanged();
            return;
        }
    };
    EmojiPane.prototype.navigate = function (change, direction) {
        if (direction === void 0) { direction = 0 /* Horizontal */; }
        var _a = this.state, index = _a.index, currentEmojiList = _a.currentEmojiList;
        if (direction === 1 /* Vertical */ && index !== -1) {
            change *= EmojisPerRow;
        }
        var newIndex = index + change;
        var length = currentEmojiList.length;
        if (newIndex >= 0 && newIndex < length) {
            this.setState({ index: newIndex });
            return newIndex;
        }
        return -1;
    };
    EmojiPane.prototype.getEmojiElementIdByIndex = function (index) {
        var currentEmojiList = this.state.currentEmojiList;
        var emoji = currentEmojiList[index];
        if (emoji) {
            return this._getEmojiIconId(emoji);
        }
        return null;
    };
    EmojiPane.prototype.getSelectedEmoji = function () {
        var _a = this.state, currentEmojiList = _a.currentEmojiList, index = _a.index;
        return currentEmojiList[index];
    };
    EmojiPane.prototype.showFullPicker = function (fullSearchText) {
        var normalizedSearchValue = this._normalizeSearchText(fullSearchText, true);
        var newMode = normalizedSearchValue.length === 0 ? 2 /* Full */ : 1 /* Partial */;
        this.setState({
            index: newMode === 2 /* Full */ ? -1 : 0,
            mode: newMode,
            currentEmojiList: this._getSearchResult(normalizedSearchValue, newMode),
            search: fullSearchText,
            searchInBox: normalizedSearchValue
        });
    };
    EmojiPane.prototype.setSearch = function (value) {
        var normalizedSearchValue = this._normalizeSearchText(value, false);
        this.setState({
            index: 0,
            currentEmojiList: this._getSearchResult(normalizedSearchValue, this.state.mode),
            search: value
        });
    };
    Object.defineProperty(EmojiPane.prototype, "listId", {
        get: function () {
            return this._listId;
        },
        enumerable: false,
        configurable: true
    });
    EmojiPane.prototype._normalizeSearchText = function (text, colonIncluded) {
        if (text == null) {
            return "";
        }
        if (colonIncluded) {
            text = text.substr(1);
        }
        return text.trim();
    };
    EmojiPane.prototype._getSearchResult = function (searchValue, mode) {
        var isQuickMode = mode === 0 /* Quick */;
        if (!searchValue) {
            return isQuickMode ? this.state.currentEmojiList : emojiList_1.default[this.state.currentFamily];
        }
        var emojiList = searchEmojis_1.searchEmojis(searchValue, this.props.strings);
        return isQuickMode ? emojiList.slice(0, 5).concat([emojiList_1.MoreEmoji]) : emojiList;
    };
    EmojiPane.prototype._renderQuickPicker = function () {
        var _a = this.props, quickPickerClassName = _a.quickPickerClassName, tooltipClassName = _a.tooltipClassName, strings = _a.strings;
        var selectedEmoji = this.getSelectedEmoji();
        var target = selectedEmoji ? "#" + this._getEmojiIconId(selectedEmoji) : undefined;
        var content = selectedEmoji ? strings[selectedEmoji.description] : undefined;
        // note: we're using a callout since TooltipHost does not support manual trigger, and we need to show the tooltip since quick picker is shown
        // as an autocomplete menu (false focus based on transferring navigation keyboard event)
        return (React.createElement("div", { id: this._listId, role: "listbox", className: roosterjs_react_common_1.css(Styles.quickPicker, PaneBaseClassName, "quick-picker", quickPickerClassName) },
            this._renderCurrentEmojiIcons(),
            React.createElement(Callout_1.Callout, __assign({}, TooltipCalloutProps, { role: "tooltip", target: target, hidden: !content, className: roosterjs_react_common_1.css(Styles.tooltip, tooltipClassName) }), content)));
    };
    EmojiPane.prototype._renderFullPicker = function () {
        var _a;
        var _b = this.props, fullPickerClassName = _b.fullPickerClassName, searchDisabled = _b.searchDisabled, searchPlaceholder = _b.searchPlaceholder, searchInputAriaLabel = _b.searchInputAriaLabel;
        var emojiId = this._getEmojiIconId(this.getSelectedEmoji());
        var autoCompleteAttributes = (_a = {},
            _a[roosterjs_react_common_1.AriaAttributes.AutoComplete] = "list",
            _a[roosterjs_react_common_1.AriaAttributes.Expanded] = "true",
            _a[roosterjs_react_common_1.AriaAttributes.HasPopup] = "listbox",
            _a[roosterjs_react_common_1.AriaAttributes.Owns] = this._listId,
            _a);
        if (emojiId) {
            autoCompleteAttributes[roosterjs_react_common_1.AriaAttributes.ActiveDescendant] = emojiId;
        }
        return (React.createElement("div", { className: roosterjs_react_common_1.css(PaneBaseClassName, fullPickerClassName) },
            !searchDisabled && (React.createElement(TextField_1.TextField, __assign({ role: "combobox", componentRef: this._searchRefCallback, value: this.state.searchInBox, onChange: this._onSearchChange, inputClassName: Styles.emojiTextInput, onKeyPress: this._onSearchKeyPress, onKeyDown: this._onSearchKeyDown, onFocus: this._onSearchFocus, placeholder: searchPlaceholder, ariaLabel: searchInputAriaLabel }, autoCompleteAttributes))),
            this.state.mode === 2 /* Full */ ? this._renderFullList() : this._renderPartialList()));
    };
    EmojiPane.prototype._renderCurrentEmojiIcons = function () {
        var _this = this;
        var _a = this.props, strings = _a.strings, emojiIconProps = _a.emojiIconProps;
        var currentEmojiList = this.state.currentEmojiList;
        return currentEmojiList.map(function (emoji, index) { return (React.createElement(EmojiIcon_1.default, __assign({ strings: strings }, emojiIconProps, { id: _this._getEmojiIconId(emoji), key: emoji.key, onMouseOver: function () { return _this.setState({ index: index }); }, onFocus: function () { return _this.setState({ index: index }); }, emoji: emoji, isSelected: index === _this.state.index, onClick: function (e) { return _this._onSelect(e, emoji); }, "aria-posinset": index + 1, "aria-setsize": currentEmojiList.length }))); });
    };
    EmojiPane.prototype._getEmojiIconId = function (emoji) {
        return emoji ? this._listId + "-" + emoji.key : undefined;
    };
    EmojiPane.prototype._renderPartialList = function () {
        var _a = this.props, partialListClassName = _a.partialListClassName, strings = _a.strings, hideStatusBar = _a.hideStatusBar, statusBarProps = _a.statusBarProps;
        var currentEmojiList = this.state.currentEmojiList;
        var hasResult = currentEmojiList && currentEmojiList.length > 0;
        return (React.createElement("div", null,
            React.createElement("div", { className: roosterjs_react_common_1.css(Styles.partialList, partialListClassName), "data-is-scrollable": true, tabIndex: TabIndexForFirefoxBug, ref: this._onEmojiBodyRef },
                React.createElement(FocusZone_1.FocusZone, { id: this._listId, role: "listbox", className: Styles.partialListContent, ref: this._focusZoneRefCallback }, this._renderCurrentEmojiIcons())),
            !hideStatusBar && React.createElement(EmojiStatusBar_1.default, __assign({ strings: strings }, statusBarProps, { hasResult: hasResult, emoji: this.getSelectedEmoji() }))));
    };
    EmojiPane.prototype._renderFullList = function () {
        var _a = this.props, fullListClassName = _a.fullListClassName, fullListContentClassName = _a.fullListContentClassName, strings = _a.strings, hideStatusBar = _a.hideStatusBar, navBarProps = _a.navBarProps, statusBarProps = _a.statusBarProps;
        var currentEmojiList = this.state.currentEmojiList;
        var hasResult = currentEmojiList && currentEmojiList.length > 0;
        return (React.createElement("div", { className: roosterjs_react_common_1.css(Styles.fullList, fullListClassName) },
            React.createElement("div", { className: Styles.fullListBody, "data-is-scrollable": true, tabIndex: TabIndexForFirefoxBug, ref: this._onEmojiBodyRef },
                React.createElement(EmojiNavBar_1.default, __assign({ strings: strings }, navBarProps, { onClick: this._pivotClick, currentSelected: this.state.currentFamily, getTabId: this._getTabId })),
                React.createElement("div", { className: Styles.fullListContentContainer, role: "tabpanel", "aria-labelledby": this._getTabId(this.state.currentFamily) },
                    React.createElement("div", null,
                        React.createElement(FocusZone_1.FocusZone, { id: this._listId, role: "listbox", className: roosterjs_react_common_1.css(Styles.fullListContent, fullListContentClassName), ref: this._focusZoneRefCallback }, this._renderCurrentEmojiIcons())))),
            !hideStatusBar && React.createElement(EmojiStatusBar_1.default, __assign({ strings: strings }, statusBarProps, { hasResult: hasResult, emoji: this.getSelectedEmoji() }))));
    };
    EmojiPane.IdCounter = 0;
    EmojiPane.defaultProps = { onLayoutChanged: roosterjs_react_common_1.NullFunction, onModeChanged: roosterjs_react_common_1.NullFunction };
    return EmojiPane;
}(React.PureComponent));
exports.default = EmojiPane;


/***/ }),

/***/ "./packages/roosterjs-react-emoji/lib/components/EmojiStatusBar.scss.g.ts":
/*!********************************************************************************!*\
  !*** ./packages/roosterjs-react-emoji/lib/components/EmojiStatusBar.scss.g.ts ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.statusBarDetails = exports.statusBarNoResultDetailsContainer = exports.statusBarDetailsContainer = exports.statusBarIcon = exports.statusBar = void 0;
/* tslint:disable */
var load_themed_styles_1 = __webpack_require__(/*! @microsoft/load-themed-styles */ "./node_modules/@microsoft/load-themed-styles/lib-es6/index.js");
load_themed_styles_1.loadStyles([{ "rawString": ".statusBar_b572bbc6{background-color:#f4f4f4;border-top:solid 1px #dadada;height:50px;overflow:hidden;position:relative}.statusBarIcon_b572bbc6{padding:4px;font-size:25px;display:inline-block;font-style:normal;font-weight:normal;line-height:40px}.statusBarDetailsContainer_b572bbc6,.statusBarNoResultDetailsContainer_b572bbc6{padding:0 4px;line-height:50px;position:absolute;display:inline-block;left:40px;right:0;top:0}.statusBarDetails_b572bbc6{font-weight:bold;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.statusBarNoResultDetailsContainer_b572bbc6{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;left:0;padding:0 8px}" }]);
exports.statusBar = "statusBar_b572bbc6";
exports.statusBarIcon = "statusBarIcon_b572bbc6";
exports.statusBarDetailsContainer = "statusBarDetailsContainer_b572bbc6";
exports.statusBarNoResultDetailsContainer = "statusBarNoResultDetailsContainer_b572bbc6";
exports.statusBarDetails = "statusBarDetails_b572bbc6";


/***/ }),

/***/ "./packages/roosterjs-react-emoji/lib/components/EmojiStatusBar.tsx":
/*!**************************************************************************!*\
  !*** ./packages/roosterjs-react-emoji/lib/components/EmojiStatusBar.tsx ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Tooltip_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Tooltip */ "office-ui-fabric-react/lib/Tooltip");
var React = __webpack_require__(/*! react */ "react");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
var StatusBarStyles = __webpack_require__(/*! ./EmojiStatusBar.scss.g */ "./packages/roosterjs-react-emoji/lib/components/EmojiStatusBar.scss.g.ts");
var EmojiStatusBar = /** @class */ (function (_super) {
    __extends(EmojiStatusBar, _super);
    function EmojiStatusBar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EmojiStatusBar.prototype.render = function () {
        var _a = this.props, emoji = _a.emoji, strings = _a.strings, className = _a.className, hasResult = _a.hasResult;
        if (!hasResult) {
            var noResultDescription = strings["emjDNoSuggetions"];
            return (React.createElement("div", { className: roosterjs_react_common_1.css(StatusBarStyles.statusBar, className) },
                React.createElement("div", { style: { display: "none" }, "aria-live": "polite" }, noResultDescription),
                React.createElement("div", { className: StatusBarStyles.statusBarNoResultDetailsContainer },
                    React.createElement(Tooltip_1.TooltipHost, { content: noResultDescription, overflowMode: Tooltip_1.TooltipOverflowMode.Parent },
                        React.createElement("span", { role: "alert" }, noResultDescription)))));
        }
        var icon = emoji ? emoji.codePoint : "";
        var description = emoji ? strings[emoji.description] : "";
        return (React.createElement("div", { className: roosterjs_react_common_1.css(StatusBarStyles.statusBar, className) },
            React.createElement("i", { className: StatusBarStyles.statusBarIcon, role: "presentation", "aria-hidden": "true" }, icon),
            React.createElement("div", { className: StatusBarStyles.statusBarDetailsContainer },
                React.createElement("div", { className: StatusBarStyles.statusBarDetails },
                    React.createElement(Tooltip_1.TooltipHost, { content: description, overflowMode: Tooltip_1.TooltipOverflowMode.Parent }, description)))));
    };
    return EmojiStatusBar;
}(React.Component));
exports.default = EmojiStatusBar;


/***/ }),

/***/ "./packages/roosterjs-react-emoji/lib/components/emoji.scss.g.ts":
/*!***********************************************************************!*\
  !*** ./packages/roosterjs-react-emoji/lib/components/emoji.scss.g.ts ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.tooltip = exports.fullListContent = exports.partialListContent = exports.fullListContentContainer = exports.fullListBody = exports.partialList = exports.quickPicker = exports.fullList = exports.emojiTextInput = exports.emoji = void 0;
/* tslint:disable */
var load_themed_styles_1 = __webpack_require__(/*! @microsoft/load-themed-styles */ "./node_modules/@microsoft/load-themed-styles/lib-es6/index.js");
load_themed_styles_1.loadStyles([{ "rawString": ".rooster-emoji-pane{padding:1px}.rooster-emoji-pane button{outline:0;position:relative}.rooster-emoji-pane .rooster-emoji-selected{background-color:#eaeaea}@media screen and (-ms-high-contrast: active){.rooster-emoji-pane .rooster-emoji-selected{background-color:Highlight;color:HighlightText;-ms-high-contrast-adjust:none}}.is-focusVisible .rooster-emoji-pane.quick-picker .rooster-emoji-selected::after,.is-focusVisible .rooster-emoji-pane button:focus::after{content:\"\";position:absolute;left:0px;top:0px;bottom:0px;right:0px;z-index:1;border-width:1px;border-style:solid;border-color:#fff;-o-border-image:initial;border-image:initial;outline:#666 solid 1px}.emoji_27c960a4{background:#fff;font-size:18px;width:40px;height:40px;border:0}.emoji_27c960a4::-moz-focus-inner{border:0}.emojiTextInput_27c960a4{padding:6px}.fullList_27c960a4{position:relative}.quickPicker_27c960a4{overflow-y:hidden}.partialList_27c960a4,.fullListBody_27c960a4{max-height:245px;overflow:hidden;overflow-y:scroll}.fullListBody_27c960a4{height:245px}.fullListContentContainer_27c960a4{margin:43px 0 1px 0}.partialListContent_27c960a4,.fullListContent_27c960a4{width:282px;padding:0 1px}.tooltip_27c960a4{padding:8px}" }]);
exports.emoji = "emoji_27c960a4";
exports.emojiTextInput = "emojiTextInput_27c960a4";
exports.fullList = "fullList_27c960a4";
exports.quickPicker = "quickPicker_27c960a4";
exports.partialList = "partialList_27c960a4";
exports.fullListBody = "fullListBody_27c960a4";
exports.fullListContentContainer = "fullListContentContainer_27c960a4";
exports.partialListContent = "partialListContent_27c960a4";
exports.fullListContent = "fullListContent_27c960a4";
exports.tooltip = "tooltip_27c960a4";


/***/ }),

/***/ "./packages/roosterjs-react-emoji/lib/index.ts":
/*!*****************************************************!*\
  !*** ./packages/roosterjs-react-emoji/lib/index.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EmojiPlugin = void 0;
var EmojiPlugin_1 = __webpack_require__(/*! ./plugins/EmojiPlugin */ "./packages/roosterjs-react-emoji/lib/plugins/EmojiPlugin.tsx");
Object.defineProperty(exports, "EmojiPlugin", { enumerable: true, get: function () { return EmojiPlugin_1.default; } });


/***/ }),

/***/ "./packages/roosterjs-react-emoji/lib/plugins/EmojiPlugin.tsx":
/*!********************************************************************!*\
  !*** ./packages/roosterjs-react-emoji/lib/plugins/EmojiPlugin.tsx ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var Callout_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Callout */ "office-ui-fabric-react/lib/Callout");
var Utilities_1 = __webpack_require__(/*! office-ui-fabric-react/lib/Utilities */ "office-ui-fabric-react/lib/Utilities");
var React = __webpack_require__(/*! react */ "react");
var ReactDOM = __webpack_require__(/*! react-dom */ "react-dom");
var roosterjs_editor_api_1 = __webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js");
var roosterjs_editor_core_1 = __webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js");
var roosterjs_react_common_1 = __webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts");
var EmojiPane_1 = __webpack_require__(/*! ../components/EmojiPane */ "./packages/roosterjs-react-emoji/lib/components/EmojiPane.tsx");
var emojiList_1 = __webpack_require__(/*! ../utils/emojiList */ "./packages/roosterjs-react-emoji/lib/utils/emojiList.ts");
var searchEmojis_1 = __webpack_require__(/*! ../utils/searchEmojis */ "./packages/roosterjs-react-emoji/lib/utils/searchEmojis.ts");
var EMOJI_SEARCH_DELAY = 300;
var INTERNAL_EMOJI_FONT_NAME = "EmojiFont";
var EMOJI_FONT_LIST = "'Apple Color Emoji','Segoe UI Emoji', NotoColorEmoji,'Segoe UI Symbol','Android Emoji',EmojiSymbols";
// Regex looks for an emoji right before the : to allow contextual search immediately following an emoji
// MATCHES: 0: :r
//          1: 
//          2: :r
var EMOJI_BEFORE_COLON_REGEX = /([\u0023-\u0039][\u20e3]|[\ud800-\udbff][\udc00-\udfff]|[\u00a9-\u00ae]|[\u2122-\u3299])*([:;][^:]*)/;
var KEYCODE_COLON = 186;
var KEYCODE_COLON_FIREFOX = 59;
var EmojiPlugin = /** @class */ (function () {
    function EmojiPlugin(options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.options = options;
        this._onModeChanged = function (newMode) {
            if (newMode !== 0 /* Quick */) {
                _this._removeAutoCompleteAriaAttributes(); // remove since we switched to a dialog
            }
        };
        this._paneRef = function (ref) {
            _this._pane = ref;
        };
        this._calloutRef = function (ref) {
            _this._callout = ref;
        };
        this._calloutOnDismissInternal = function (ev) {
            _this._setIsSuggesting(false);
            if (_this.options.calloutOnDismiss) {
                _this.options.calloutOnDismiss(ev);
            }
        };
        this._onSelectFromPane = function (emoji, wordBeforeCursor) {
            if (emoji === emojiList_1.MoreEmoji) {
                _this._pane.showFullPicker(wordBeforeCursor);
                return;
            }
            _this._insertEmoji(emoji, wordBeforeCursor);
        };
        this._async = new Utilities_1.Async();
        this._refreshCalloutDebounced = this._async.debounce(function () { return _this._refreshCallout(); }, 100);
        this._strings = options.strings;
    }
    EmojiPlugin.prototype.getName = function () {
        return 'Emoji';
    };
    EmojiPlugin.prototype.initialize = function (editor) {
        this._editor = editor;
        var document = editor.getDocument();
        this._contentDiv = document.createElement("div");
        document.body.appendChild(this._contentDiv);
    };
    EmojiPlugin.prototype.initializeContentEditable = function (contentEditable) {
        this._contentEditable = contentEditable;
    };
    EmojiPlugin.prototype.setStrings = function (strings) {
        this._strings = strings;
    };
    EmojiPlugin.prototype.dispose = function () {
        this._setIsSuggesting(false);
        if (this._contentDiv) {
            ReactDOM.unmountComponentAtNode(this._contentDiv);
            this._contentDiv.parentElement.removeChild(this._contentDiv);
            this._contentDiv = null;
        }
        this._editor = null;
        this._contentEditable = null;
        if (this._async) {
            this._async.dispose();
            this._async = null;
        }
    };
    EmojiPlugin.prototype.willHandleEventExclusively = function (event) {
        return this._isSuggesting && (event.eventType === 0 /* KeyDown */ || event.eventType === 2 /* KeyUp */ || event.eventType === 5 /* MouseUp */);
    };
    EmojiPlugin.prototype.onPluginEvent = function (event) {
        var domEvent = event;
        var keyboardEvent = domEvent.rawEvent;
        if (event.eventType === 0 /* KeyDown */) {
            this._eventHandledOnKeyDown = false;
            if (this._isSuggesting) {
                this._onKeyDownSuggestingDomEvent(domEvent);
            }
            else if (keyboardEvent.which === Utilities_1.KeyCodes.backspace && this._canUndoEmoji) {
                // If KeyDown is backspace and canUndoEmoji, call editor undo
                this._editor.undo();
                this._handleEventOnKeyDown(domEvent);
                this._canUndoEmoji = false;
            }
        }
        else if (event.eventType === 2 /* KeyUp */ && !this._isModifierKey(keyboardEvent.key)) {
            if (this._isSuggesting) {
                this._onKeyUpSuggestingDomEvent(domEvent);
            }
            else {
                this._onKeyUpDomEvent(domEvent);
            }
        }
        else if (event.eventType === 5 /* MouseUp */) {
            // If MouseUp, the emoji cannot be undone
            this._canUndoEmoji = false;
            this._setIsSuggesting(false);
        }
    };
    EmojiPlugin.prototype.startEmoji = function (startingString) {
        if (startingString === void 0) { startingString = ":"; }
        var editor = this._editor;
        if (!editor) {
            return;
        }
        this._setIsSuggesting(true);
        editor.insertContent(startingString);
        this._triggerChangeEvent();
    };
    EmojiPlugin.prototype._setIsSuggesting = function (isSuggesting, restoreSavedRange) {
        var _this = this;
        if (restoreSavedRange === void 0) { restoreSavedRange = true; }
        if (this._isSuggesting === isSuggesting) {
            return;
        }
        this._isSuggesting = isSuggesting;
        if (this._isSuggesting) {
            ReactDOM.render(this._getCallout(), this._contentDiv);
            // we need to delay so NVDA will announce the first selection
            setTimeout(function () {
                var _contentEditable = _this._contentEditable;
                if (_contentEditable) {
                    _contentEditable.setAttribute(roosterjs_react_common_1.AriaAttributes.AutoComplete, "list");
                    _contentEditable.setAttribute(roosterjs_react_common_1.AriaAttributes.Owns, _this._pane.listId);
                    _contentEditable.setAttribute(roosterjs_react_common_1.AriaAttributes.ActiveDescendant, _this._pane.getEmojiElementIdByIndex(0));
                }
            }, 0);
            this._editor.saveSelectionRange();
        }
        else {
            ReactDOM.unmountComponentAtNode(this._contentDiv);
            this._removeAutoCompleteAriaAttributes();
            restoreSavedRange && this._editor.restoreSavedRange();
        }
    };
    EmojiPlugin.prototype._removeAutoCompleteAriaAttributes = function () {
        var _contentEditable = this._contentEditable;
        if (_contentEditable) {
            _contentEditable.removeAttribute(roosterjs_react_common_1.AriaAttributes.AutoComplete);
            _contentEditable.removeAttribute(roosterjs_react_common_1.AriaAttributes.Owns);
            _contentEditable.removeAttribute(roosterjs_react_common_1.AriaAttributes.ActiveDescendant);
        }
    };
    /**
     * On KeyDown suggesting DOM event
     * Try to insert emoji is possible
     * Intercept arrow keys to move selection if popup is shown
     */
    EmojiPlugin.prototype._onKeyDownSuggestingDomEvent = function (event) {
        // If key is enter, try insert emoji at selection
        // If key is space and selection is shortcut, try insert emoji
        var keyboardEvent = event.rawEvent;
        var selectedEmoji = this._pane.getSelectedEmoji();
        var wordBeforeCursor = this._getWordBeforeCursor(event);
        var emoji;
        switch (keyboardEvent.which) {
            case Utilities_1.KeyCodes.space:
                // We only want to insert on space if the word before the cursor is a shortcut
                emoji = wordBeforeCursor ? searchEmojis_1.matchShortcut(wordBeforeCursor) : null;
                if (!emoji) {
                    this._setIsSuggesting(false, false);
                }
                break;
            case Utilities_1.KeyCodes.enter:
                // check if selection is on the "..." and show full picker if so, otherwise try to apply emoji
                if (this._tryShowFullPicker(event, selectedEmoji, wordBeforeCursor)) {
                    break;
                }
                // We only want to insert on space if the word before the cursor is a shortcut
                // If the timer is not null, that means we have a search queued.
                // Check to see is the word before the cursor matches a shortcut first
                // Otherwise if the search completed and it is a shortcut, insert the first item
                emoji = this._timer ? searchEmojis_1.matchShortcut(wordBeforeCursor) : selectedEmoji;
                break;
            case Utilities_1.KeyCodes.left:
            case Utilities_1.KeyCodes.right:
                var nextIndex = this._pane.navigate(keyboardEvent.which === Utilities_1.KeyCodes.left ? -1 : 1);
                if (nextIndex >= 0) {
                    this._contentEditable.setAttribute(roosterjs_react_common_1.AriaAttributes.ActiveDescendant, this._pane.getEmojiElementIdByIndex(nextIndex));
                }
                this._handleEventOnKeyDown(event);
                break;
            case Utilities_1.KeyCodes.escape:
                this._setIsSuggesting(false);
                this._handleEventOnKeyDown(event);
        }
        if (emoji && (this._canUndoEmoji = this._insertEmoji(emoji, wordBeforeCursor))) {
            this._handleEventOnKeyDown(event);
        }
    };
    EmojiPlugin.prototype._tryShowFullPicker = function (event, selectedEmoji, wordBeforeCursor) {
        if (selectedEmoji !== emojiList_1.MoreEmoji) {
            return false;
        }
        this._handleEventOnKeyDown(event);
        this._pane.showFullPicker(wordBeforeCursor);
        return true;
    };
    /**
     * On KeyUp suggesting DOM event
     * If key is character, update search term
     * Otherwise set isSuggesting to false
     */
    EmojiPlugin.prototype._onKeyUpSuggestingDomEvent = function (event) {
        var _this = this;
        if (this._eventHandledOnKeyDown) {
            return;
        }
        var keyboardEvent = event.rawEvent;
        // If this is a character key or backspace
        // Clear the timer as we will either queue a new timer or stop suggesting
        if ((keyboardEvent.key.length === 1 && keyboardEvent.which !== Utilities_1.KeyCodes.space) || keyboardEvent.which === Utilities_1.KeyCodes.backspace) {
            window.clearTimeout(this._timer);
            this._timer = null;
        }
        var wordBeforeCursor = this._getWordBeforeCursor(event);
        if (wordBeforeCursor) {
            this._timer = window.setTimeout(function () {
                if (_this._pane) {
                    _this._pane.setSearch(wordBeforeCursor);
                    _this._timer = null;
                }
            }, EMOJI_SEARCH_DELAY);
        }
        else {
            this._setIsSuggesting(false);
        }
    };
    EmojiPlugin.prototype._onKeyUpDomEvent = function (event) {
        if (this._eventHandledOnKeyDown) {
            return;
        }
        var keyboardEvent = event.rawEvent;
        var wordBeforeCursor = this._getWordBeforeCursor(event);
        if ((keyboardEvent.which === KEYCODE_COLON || keyboardEvent.which === KEYCODE_COLON_FIREFOX) && wordBeforeCursor === ":") {
            var _a = this.options.onKeyboardTriggered, onKeyboardTriggered = _a === void 0 ? roosterjs_react_common_1.NullFunction : _a;
            this._setIsSuggesting(true);
            onKeyboardTriggered();
        }
        else if (wordBeforeCursor) {
            var cursorData = roosterjs_editor_core_1.cacheGetContentSearcher(event, this._editor);
            var charBeforeCursor = cursorData ? cursorData.getSubStringBefore(1) : null;
            // It is possible that the word before the cursor is ahead of the pluginEvent we are handling
            // ex. WordBeforeCursor is ":D"" but the event we are currently handling is for the : key
            // Check that the char before the cursor is actually the key event we are currently handling
            // Otherwise we set canUndoEmoji to early and user is unable to backspace undo on the inserted emoji
            if (keyboardEvent.key === charBeforeCursor) {
                var emoji = searchEmojis_1.matchShortcut(wordBeforeCursor);
                if (emoji && this._insertEmoji(emoji, wordBeforeCursor)) {
                    roosterjs_editor_core_1.clearContentSearcherCache(event);
                    this._canUndoEmoji = true;
                }
            }
        }
    };
    EmojiPlugin.prototype._insertEmoji = function (emoji, wordBeforeCursor) {
        var _this = this;
        var inserted = false;
        this._editor.addUndoSnapshot();
        var node = this._editor.getDocument().createElement("span");
        node.innerText = emoji.codePoint;
        if (wordBeforeCursor && roosterjs_editor_api_1.replaceWithNode(this._editor, wordBeforeCursor, node, false /*exactMatch*/)) {
            inserted = true;
            this._canUndoEmoji = true;
            // Update the editor cursor to be after the inserted node
            window.requestAnimationFrame(function () {
                if (_this._editor && _this._editor.contains(node)) {
                    _this._editor.select(node, -3 /* After */);
                    _this._editor.addUndoSnapshot();
                }
            });
        }
        else {
            inserted = this._editor.insertNode(node);
        }
        inserted && this._triggerChangeEvent();
        this._tryPatchEmojiFont();
        this._setIsSuggesting(false);
        return inserted;
    };
    EmojiPlugin.prototype._triggerChangeEvent = function () {
        this._editor.triggerContentChangedEvent("Emoji");
    };
    EmojiPlugin.prototype._isModifierKey = function (key) {
        return key === "Shift" || key === "Control" || key === "Alt" || key === "Command";
    };
    EmojiPlugin.prototype._handleEventOnKeyDown = function (event) {
        this._eventHandledOnKeyDown = true;
        event.rawEvent.preventDefault();
        event.rawEvent.stopImmediatePropagation();
    };
    EmojiPlugin.prototype._getCallout = function () {
        var _a = this.options, calloutClassName = _a.calloutClassName, _b = _a.emojiPaneProps, emojiPaneProps = _b === void 0 ? {} : _b;
        var cursorRect = this._editor.getCursorRect();
        var point = {
            x: cursorRect.left,
            y: (cursorRect.top + cursorRect.bottom) / 2
        };
        var gap = (cursorRect.bottom - cursorRect.top) / 2 + 5;
        return (React.createElement(Callout_1.Callout, { className: calloutClassName, target: point, directionalHint: Callout_1.DirectionalHint.bottomAutoEdge, isBeakVisible: false, gapSpace: gap, onDismiss: this._calloutOnDismissInternal, ref: this._calloutRef },
            React.createElement(EmojiPane_1.default, __assign({}, emojiPaneProps, { ref: this._paneRef, onSelect: this._onSelectFromPane, strings: this._strings || {}, onLayoutChanged: this._refreshCalloutDebounced, onModeChanged: this._onModeChanged, navBarProps: emojiPaneProps.navBarProps, statusBarProps: emojiPaneProps.statusBarProps, searchDisabled: !this._strings || emojiPaneProps.searchDisabled, hideStatusBar: !this._strings }))));
    };
    EmojiPlugin.prototype._refreshCallout = function () {
        this._callout.forceUpdate();
    };
    EmojiPlugin.prototype._tryPatchEmojiFont = function () {
        // This is not perfect way of doing this, but cannot find a better way.
        // Essentially what is happening is, emoji requires some special font to render properly. Without those font, it may render black and white
        // The fix we have right now is to find the topest block element and patch it with emoji font
        var range = this._editor.getSelectionRange();
        var inlineElement = range ? this._editor.getInlineElementAtNode(range.startContainer) : null;
        var blockElement = inlineElement ? inlineElement.getParentBlock() : null;
        if (blockElement) {
            var blockNode = blockElement.getStartNode();
            var fontFamily = blockNode.style.fontFamily;
            if (fontFamily && fontFamily.toLowerCase().indexOf("emoji") < 0) {
                blockNode.style.fontFamily = fontFamily + "," + INTERNAL_EMOJI_FONT_NAME + "," + EMOJI_FONT_LIST;
                return true;
            }
        }
        return false;
    };
    EmojiPlugin.prototype._getWordBeforeCursor = function (event) {
        var cursorData = roosterjs_editor_core_1.cacheGetContentSearcher(event, this._editor);
        var wordBeforeCursor = cursorData ? cursorData.getWordBefore() : null;
        var matches = EMOJI_BEFORE_COLON_REGEX.exec(wordBeforeCursor);
        return matches && matches.length > 2 && matches[0] === wordBeforeCursor ? matches[2] : null;
    };
    return EmojiPlugin;
}());
exports.default = EmojiPlugin;


/***/ }),

/***/ "./packages/roosterjs-react-emoji/lib/utils/emojiList.ts":
/*!***************************************************************!*\
  !*** ./packages/roosterjs-react-emoji/lib/utils/emojiList.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.forEachEmoji = exports.forEachEmojiFamily = exports.EmojiFabricIconCharacterMap = exports.CommonEmojis = exports.MoreEmoji = void 0;
var Common1 = _createEmoji("1f60a", ":) :-)");
var common2 = _createEmoji("1f609", ";) ;-)");
var common3 = _createEmoji("02764", "<3");
var common4 = _createEmoji("1f61e", ":( :-(");
var common5 = _createEmoji("1f603", ":D :-D");
exports.MoreEmoji = {
    key: "more",
    description: "emjDMore",
    codePoint: ""
};
exports.CommonEmojis = [Common1, common2, common3, common4, common5, exports.MoreEmoji];
// NOTE: name for an emoji should be in lower case
var EmojiList = (_a = {},
    _a["People" /* People */] = [
        _createEmoji("1f601"),
        _createEmoji("1f602"),
        common5,
        _createEmoji("1f604"),
        _createEmoji("1f605"),
        _createEmoji("1f606"),
        _createEmoji("1f607"),
        common2,
        Common1,
        _createEmoji("1f642"),
        _createEmoji("1f60b"),
        _createEmoji("1f60c"),
        _createEmoji("1f60d"),
        _createEmoji("1f618"),
        _createEmoji("1f61a"),
        _createEmoji("1f61c"),
        _createEmoji("1f61d", ":p :P :-p :-P"),
        _createEmoji("1f60e", "B) B-)"),
        _createEmoji("1f60f"),
        _createEmoji("1f636"),
        _createEmoji("1f610", ":| :-|"),
        _createEmoji("1f612"),
        _createEmoji("1f633"),
        common4,
        _createEmoji("1f620"),
        _createEmoji("1f621"),
        _createEmoji("1f614"),
        _createEmoji("1f623"),
        _createEmoji("1f616"),
        _createEmoji("1f62b"),
        _createEmoji("1f629"),
        _createEmoji("1f624"),
        _createEmoji("1f631"),
        _createEmoji("1f628"),
        _createEmoji("1f630"),
        _createEmoji("1f625"),
        _createEmoji("1f622"),
        _createEmoji("1f62a"),
        _createEmoji("1f613"),
        _createEmoji("1f62d"),
        _createEmoji("1f635"),
        _createEmoji("1f632", ":o :O :-o :-O"),
        _createEmoji("1f637"),
        _createEmoji("1f4a4"),
        _createEmojiWithNoKeyword("1f608"),
        _createEmoji("1f47f"),
        _createEmojiWithNoKeyword("1f479"),
        _createEmojiWithNoKeyword("1f47a"),
        _createEmoji("1f480"),
        _createEmoji("1f47b"),
        _createEmoji("1f47d"),
        _createEmoji("1f63a"),
        _createEmoji("1f638"),
        _createEmoji("1f639"),
        _createEmoji("1f63b"),
        _createEmoji("1f63c"),
        _createEmoji("1f63d"),
        _createEmojiWithNoKeyword("1f640"),
        _createEmoji("1f63f"),
        _createEmoji("1f63e"),
        _createEmoji("1f64c"),
        _createEmoji("1f44f"),
        _createEmoji("1f44b"),
        _createEmoji("1f44d"),
        _createEmoji("1f44e"),
        _createEmoji("1f44a"),
        _createEmoji("0270a"),
        _createEmoji("0270b"),
        _createEmoji("0270c"),
        _createEmoji("1f44c"),
        _createEmojiWithNoKeyword("1f450"),
        _createEmojiWithNoKeyword("1f596"),
        _createEmoji("1f4aa"),
        _createEmoji("1f64f"),
        _createEmoji("1f446"),
        _createEmoji("1f447"),
        _createEmoji("1f448"),
        _createEmoji("1f449"),
        _createEmoji("1f485"),
        _createEmoji("1f444"),
        _createEmoji("1f445"),
        _createEmoji("1f442"),
        _createEmoji("1f443"),
        _createEmoji("1f440"),
        _createEmojiWithNoKeyword("1f464"),
        _createEmoji("1f476"),
        _createEmoji("1f466"),
        _createEmoji("1f467"),
        _createEmoji("1f468"),
        _createEmoji("1f469"),
        _createEmoji("1f471"),
        _createEmoji("1f474"),
        _createEmoji("1f475"),
        _createEmojiWithNoKeyword("1f472"),
        _createEmojiWithNoKeyword("1f473"),
        _createEmoji("1f46e"),
        _createEmoji("1f477"),
        _createEmoji("1f482"),
        _createEmoji("1f385"),
        _createEmoji("1f47c"),
        _createEmoji("1f478"),
        _createEmoji("1f470"),
        _createEmoji("1f6b6"),
        _createEmoji("1f3c3"),
        _createEmoji("1f483"),
        _createEmoji("1f46f"),
        _createEmoji("1f46b"),
        _createEmojiWithNoKeyword("1f647"),
        _createEmoji("1f481"),
        _createEmoji("1f645"),
        _createEmoji("1f646"),
        _createEmoji("1f64b"),
        _createEmoji("1f64e"),
        _createEmoji("1f64d"),
        _createEmoji("1f487"),
        _createEmoji("1f486"),
        _createEmoji("1f491"),
        _createEmoji("1f48f"),
        _createEmoji("1f46a"),
        _createEmoji("1f45a"),
        _createEmoji("1f455"),
        _createEmoji("1f456"),
        _createEmoji("1f454"),
        _createEmoji("1f457"),
        _createEmoji("1f459"),
        _createEmoji("1f458"),
        _createEmoji("1f484"),
        _createEmoji("1f48b"),
        _createEmoji("1f463"),
        _createEmojiWithNoKeyword("1f460"),
        _createEmoji("1f461"),
        _createEmoji("1f462"),
        _createEmoji("1f45e"),
        _createEmoji("1f45f"),
        _createEmoji("1f452"),
        _createEmoji("1f3a9"),
        _createEmoji("1f393"),
        _createEmoji("1f451"),
        _createEmoji("1f392"),
        _createEmoji("1f45d"),
        _createEmoji("1f45b"),
        _createEmoji("1f45c"),
        _createEmoji("1f4bc"),
        _createEmoji("1f453"),
        _createEmoji("1f48d"),
        _createEmoji("1f302")
    ],
    _a["Nature" /* Nature */] = [
        _createEmoji("1f436"),
        _createEmoji("1f431"),
        _createEmoji("1f42d"),
        _createEmoji("1f439"),
        _createEmoji("1f430"),
        _createEmoji("1f43b"),
        _createEmoji("1f43c"),
        _createEmojiWithNoKeyword("1f428"),
        _createEmoji("1f42f"),
        _createEmoji("1f42e"),
        _createEmoji("1f437"),
        _createEmoji("1f43d"),
        _createEmoji("1f438"),
        _createEmoji("1f419"),
        _createEmoji("1f435"),
        _createEmoji("1f648"),
        _createEmoji("1f649"),
        _createEmoji("1f64a"),
        _createEmoji("1f412"),
        _createEmoji("1f427"),
        _createEmoji("1f426"),
        _createEmojiWithNoKeyword("1f424"),
        _createEmoji("1f423"),
        _createEmoji("1f425"),
        _createEmoji("1f43a"),
        _createEmoji("1f417"),
        _createEmoji("1f434"),
        _createEmoji("1f41d"),
        _createEmoji("1f41b"),
        _createEmoji("1f40c"),
        _createEmoji("1f41e"),
        _createEmoji("1f41c"),
        _createEmoji("1f40d"),
        _createEmoji("1f422"),
        _createEmoji("1f420"),
        _createEmoji("1f41f"),
        _createEmoji("1f421"),
        _createEmoji("1f42c"),
        _createEmoji("1f433"),
        _createEmoji("1f414"),
        _createEmoji("1f42b"),
        _createEmoji("1f418"),
        _createEmoji("1f411"),
        _createEmoji("1f40e"),
        _createEmoji("1f429"),
        _createEmoji("1f43e"),
        _createEmoji("1f432"),
        _createEmoji("1f335"),
        _createEmoji("1f384"),
        _createEmoji("1f334"),
        _createEmoji("1f331"),
        _createEmoji("1f33f"),
        _createEmoji("1f340"),
        _createEmojiWithNoKeyword("1f38d"),
        _createEmojiWithNoKeyword("1f38b"),
        _createEmoji("1f343"),
        _createEmoji("1f342"),
        _createEmoji("1f341"),
        _createEmoji("1f33e"),
        _createEmoji("1f33a"),
        _createEmoji("1f33b"),
        _createEmoji("1f339"),
        _createEmoji("1f33c"),
        _createEmoji("1f337"),
        _createEmoji("1f338"),
        _createEmoji("1f344"),
        _createEmoji("1f490"),
        _createEmoji("1f330"),
        _createEmoji("1f383"),
        _createEmoji("1f41a"),
        _createEmojiWithNoKeyword("1f30f"),
        _createEmoji("1f315"),
        _createEmoji("1f311"),
        _createEmoji("1f313"),
        _createEmoji("1f314"),
        _createEmoji("1f31b"),
        _createEmoji("1f319"),
        _createEmoji("02b50"),
        _createEmoji("1f31f"),
        _createEmojiWithNoKeyword("1f4ab"),
        _createEmoji("02728"),
        _createEmojiWithNoKeyword("02600"),
        _createEmojiWithNoKeyword("026c5"),
        _createEmoji("02601"),
        _createEmoji("026a1"),
        _createEmoji("1f525"),
        _createEmoji("1f4a5"),
        _createEmoji("02744"),
        _createEmoji("026c4"),
        _createEmoji("1f4a8"),
        _createEmoji("02614"),
        _createEmojiWithNoKeyword("1f4a7"),
        _createEmojiWithNoKeyword("1f4a6"),
        _createEmoji("1f30a")
    ],
    _a["Activities" /* Activities */] = [
        _createEmoji("026bd"),
        _createEmoji("1f3c0"),
        _createEmoji("1f3c8"),
        _createEmoji("026be"),
        _createEmoji("1f3be"),
        _createEmoji("1f3b1"),
        _createEmoji("026f3"),
        _createEmoji("1f3bf"),
        _createEmoji("1f3c2"),
        _createEmoji("1f3a3"),
        _createEmoji("1f3ca"),
        _createEmoji("1f3c4"),
        _createEmoji("1f3c6"),
        _createEmoji("1f3bd"),
        _createEmoji("1f3ab"),
        _createEmoji("1f3ad"),
        _createEmoji("1f3a8"),
        _createEmoji("1f3aa"),
        _createEmoji("1f3a4"),
        _createEmoji("1f3a7"),
        _createEmoji("1f3bc"),
        _createEmoji("1f3b9"),
        _createEmoji("1f3b7"),
        _createEmoji("1f3ba"),
        _createEmoji("1f3b8"),
        _createEmoji("1f3bb"),
        _createEmoji("1f3ac"),
        _createEmoji("1f3ae"),
        _createEmoji("1f47e"),
        _createEmoji("1f3af"),
        _createEmoji("1f3b2"),
        _createEmoji("1f3b0"),
        _createEmoji("1f3b3")
    ],
    _a["Food" /* Food */] = [
        _createEmoji("1f34f"),
        _createEmoji("1f34e"),
        _createEmoji("1f34a"),
        _createEmoji("1f34c"),
        _createEmoji("1f349"),
        _createEmoji("1f347"),
        _createEmoji("1f353"),
        _createEmoji("1f348"),
        _createEmoji("1f352"),
        _createEmoji("1f351"),
        _createEmoji("1f34d"),
        _createEmoji("1f345"),
        _createEmoji("1f346"),
        _createEmoji("1f33d"),
        _createEmoji("1f360"),
        _createEmoji("1f35e"),
        _createEmoji("1f357"),
        _createEmoji("1f356"),
        _createEmoji("1f364"),
        _createEmoji("1f373"),
        _createEmoji("1f354"),
        _createEmoji("1f35f"),
        _createEmoji("1f355"),
        _createEmoji("1f35d"),
        _createEmoji("1f35c"),
        _createEmoji("1f372"),
        _createEmoji("1f365"),
        _createEmoji("1f363"),
        _createEmoji("1f371"),
        _createEmoji("1f35b"),
        _createEmoji("1f359"),
        _createEmoji("1f35a"),
        _createEmoji("1f358"),
        _createEmoji("1f362"),
        _createEmoji("1f361"),
        _createEmojiWithNoKeyword("1f367"),
        _createEmoji("1f368"),
        _createEmoji("1f366"),
        _createEmoji("1f370"),
        _createEmoji("1f36f"),
        _createEmoji("1f382"),
        _createEmoji("1f36e"),
        _createEmoji("1f36c"),
        _createEmoji("1f36d"),
        _createEmoji("1f36b"),
        _createEmoji("1f369"),
        _createEmoji("1f36a"),
        _createEmoji("1f37a"),
        _createEmoji("1f37b"),
        _createEmoji("1f377"),
        _createEmoji("1f378"),
        _createEmoji("1f379"),
        _createEmoji("1f376"),
        _createEmoji("1f375"),
        _createEmoji("02615"),
        _createEmoji("1f374")
    ],
    _a["Travel" /* Travel */] = [
        _createEmoji("1f697"),
        _createEmoji("1f695"),
        _createEmoji("1f687"),
        _createEmojiWithNoKeyword("1f699"),
        _createEmoji("1f68c"),
        _createEmoji("1f693"),
        _createEmoji("1f69a"),
        _createEmojiWithNoKeyword("1f691"),
        _createEmoji("1f692"),
        _createEmoji("1f6b2"),
        _createEmoji("1f6a8"),
        _createEmoji("1f683"),
        _createEmoji("1f684"),
        _createEmojiWithNoKeyword("1f685"),
        _createEmoji("1f689"),
        _createEmoji("02708"),
        _createEmoji("026f5"),
        _createEmojiWithNoKeyword("1f6a4"),
        _createEmoji("1f680"),
        _createEmoji("1f4ba"),
        _createEmoji("02693"),
        _createEmoji("1f6a7"),
        _createEmoji("026fd"),
        _createEmoji("1f68f"),
        _createEmoji("1f6a5"),
        _createEmoji("1f3c1"),
        _createEmoji("1f6a2"),
        _createEmoji("1f3a1"),
        _createEmoji("1f3a2"),
        _createEmoji("1f3a0"),
        _createEmoji("1f301"),
        _createEmojiWithNoKeyword("1f5fc"),
        _createEmoji("1f3ed"),
        _createEmoji("026f2"),
        _createEmojiWithNoKeyword("1f391"),
        _createEmojiWithNoKeyword("1f5fb"),
        _createEmojiWithNoKeyword("1f30b"),
        _createEmojiWithNoKeyword("1f5fe"),
        _createEmoji("1f305"),
        _createEmoji("1f304"),
        _createEmoji("1f307"),
        _createEmoji("1f306"),
        _createEmoji("1f303"),
        _createEmoji("1f309"),
        _createEmoji("1f30c"),
        _createEmoji("1f387"),
        _createEmoji("1f386"),
        _createEmoji("1f308"),
        _createEmoji("1f3f0"),
        _createEmojiWithNoKeyword("1f3ef"),
        _createEmoji("1f5fd"),
        _createEmoji("1f3e0"),
        _createEmoji("1f3e1"),
        _createEmoji("1f3e2"),
        _createEmoji("1f3ec"),
        _createEmoji("026fa"),
        _createEmojiWithNoKeyword("1f3e3"),
        _createEmojiWithNoKeyword("1f3e5"),
        _createEmoji("1f3e6"),
        _createEmoji("1f3e8"),
        _createEmoji("1f3ea"),
        _createEmoji("1f3eb"),
        _createEmojiWithNoKeyword("1f3e9"),
        _createEmoji("1f492"),
        _createEmoji("026ea"),
        _createEmoji("1f320")
    ],
    _a["Symbols" /* Symbols */] = [
        common3,
        _createEmoji("1f49b"),
        _createEmoji("1f49a"),
        _createEmoji("1f499"),
        _createEmoji("1f494"),
        _createEmoji("1f49c"),
        _createEmoji("1f495"),
        _createEmoji("1f493"),
        _createEmoji("1f49e"),
        _createEmoji("1f497"),
        _createEmoji("1f498"),
        _createEmoji("1f496"),
        _createEmoji("1f49d"),
        _createEmoji("1f49f"),
        _createEmojiWithNoKeyword("1f52f"),
        _createEmojiWithNoKeyword("026ce"),
        _createEmoji("02648"),
        _createEmoji("02649"),
        _createEmoji("0264a"),
        _createEmoji("0264b"),
        _createEmoji("0264c"),
        _createEmoji("0264d"),
        _createEmoji("0264e"),
        _createEmoji("0264f"),
        _createEmoji("02650"),
        _createEmoji("02651"),
        _createEmoji("02652"),
        _createEmoji("02653"),
        _createEmojiWithNoKeyword("1f194"),
        _createEmojiWithNoKeyword("1f4f4"),
        _createEmojiWithNoKeyword("1f4f3"),
        _createEmojiWithNoKeyword("1f19a"),
        _createEmojiWithNoKeyword("1f4ae"),
        _createEmojiWithNoKeyword("1f18e"),
        _createEmojiWithNoKeyword("1f191"),
        _createEmojiWithNoKeyword("1f198"),
        _createEmojiWithNoKeyword("026d4"),
        _createEmoji("1f4db"),
        _createEmoji("1f6ab"),
        _createEmojiWithNoKeyword("0274c"),
        _createEmojiWithNoKeyword("02b55"),
        _createEmojiWithNoKeyword("1f4a2"),
        _createEmoji("02668"),
        _createEmojiWithNoKeyword("1f51e"),
        _createEmojiWithNoKeyword("02757"),
        _createEmojiWithNoKeyword("02755"),
        _createEmojiWithNoKeyword("02753"),
        _createEmojiWithNoKeyword("02754"),
        _createEmojiWithNoKeyword("02049"),
        _createEmojiWithNoKeyword("1f4af"),
        _createEmoji("1f531"),
        _createEmojiWithNoKeyword("0303d"),
        _createEmoji("026a0"),
        _createEmojiWithNoKeyword("1f530"),
        _createEmojiWithNoKeyword("1f22f"),
        _createEmojiWithNoKeyword("1f4b9"),
        _createEmoji("02733"),
        _createEmojiWithNoKeyword("0274e"),
        _createEmojiWithNoKeyword("02705"),
        _createEmojiWithNoKeyword("1f4a0"),
        _createEmoji("1f300"),
        _createEmoji("1f3e7"),
        _createEmoji("0267f"),
        _createEmoji("1f6ad"),
        _createEmojiWithNoKeyword("1f6be"),
        _createEmoji("02734"),
        _createEmoji("1f17f"),
        _createEmoji("1f6b9"),
        _createEmoji("1f6ba"),
        _createEmojiWithNoKeyword("1f6bc"),
        _createEmoji("1f6bb"),
        _createEmoji("1f3a6"),
        _createEmoji("1f4f6"),
        _createEmojiWithNoKeyword("1f201"),
        _createEmojiWithNoKeyword("1f196"),
        _createEmojiWithNoKeyword("0267b"),
        _createEmojiWithNoKeyword("1f197"),
        _createEmojiWithNoKeyword("1f192"),
        _createEmoji("02747"),
        _createEmojiWithNoKeyword("1f195"),
        _createEmojiWithNoKeyword("1f193"),
        _createEmojiWithNoKeyword("1f51f"),
        _createEmojiWithNoKeyword("1f522"),
        _createEmojiWithNoKeyword("023ea"),
        _createEmojiWithNoKeyword("023e9"),
        _createEmojiWithNoKeyword("1f53c"),
        _createEmojiWithNoKeyword("1f53d"),
        _createEmojiWithNoKeyword("023eb"),
        _createEmojiWithNoKeyword("023ec"),
        _createEmojiWithNoKeyword("1f199"),
        _createEmojiWithNoKeyword("02139"),
        _createEmojiWithNoKeyword("1f524"),
        _createEmojiWithNoKeyword("1f521"),
        _createEmojiWithNoKeyword("1f520"),
        _createEmojiWithNoKeyword("1f523"),
        _createEmoji("1f3b5"),
        _createEmoji("1f3b6"),
        _createEmojiWithNoKeyword("03030"),
        _createEmojiWithNoKeyword("027bf"),
        _createEmojiWithNoKeyword("02714"),
        _createEmoji("1f503"),
        _createEmojiWithNoKeyword("02795"),
        _createEmojiWithNoKeyword("02796"),
        _createEmojiWithNoKeyword("02797"),
        _createEmojiWithNoKeyword("02716"),
        _createEmojiWithNoKeyword("027b0"),
        _createEmojiWithNoKeyword("1f4b2"),
        _createEmojiWithNoKeyword("1f4b1"),
        _createEmojiWithNoKeyword("1f51a"),
        _createEmojiWithNoKeyword("1f519"),
        _createEmojiWithNoKeyword("1f51b"),
        _createEmojiWithNoKeyword("1f51d"),
        _createEmojiWithNoKeyword("1f51c"),
        _createEmojiWithNoKeyword("02611"),
        _createEmojiWithNoKeyword("1f518"),
        _createEmojiWithNoKeyword("026ab"),
        _createEmojiWithNoKeyword("1f534"),
        _createEmojiWithNoKeyword("1f535"),
        _createEmojiWithNoKeyword("1f539"),
        _createEmojiWithNoKeyword("1f538"),
        _createEmojiWithNoKeyword("1f536"),
        _createEmojiWithNoKeyword("1f537"),
        _createEmojiWithNoKeyword("1f53a"),
        _createEmojiWithNoKeyword("1f53b"),
        _createEmojiWithNoKeyword("02b1b"),
        _createEmojiWithNoKeyword("02b1c"),
        _createEmojiWithNoKeyword("1f532"),
        _createEmojiWithNoKeyword("1f533"),
        _createEmojiWithNoKeyword("1f50a"),
        _createEmoji("1f4e3"),
        _createEmojiWithNoKeyword("1f4e2"),
        _createEmoji("1f514"),
        _createEmojiWithNoKeyword("1f004"),
        _createEmoji("1f0cf"),
        _createEmojiWithNoKeyword("1f3b4"),
        _createEmojiWithNoKeyword("1f4ac"),
        _createEmoji("1f550"),
        _createEmoji("1f551"),
        _createEmoji("1f552"),
        _createEmoji("1f553"),
        _createEmoji("1f554"),
        _createEmoji("1f555"),
        _createEmoji("1f556"),
        _createEmoji("1f557"),
        _createEmoji("1f558"),
        _createEmoji("1f559"),
        _createEmoji("1f55a"),
        _createEmoji("1f55b"),
        _createEmojiWithNoKeyword("1f236"),
        _createEmojiWithNoKeyword("1f250"),
        _createEmojiWithNoKeyword("1f239"),
        _createEmojiWithNoKeyword("1f21a"),
        _createEmojiWithNoKeyword("1f232"),
        _createEmojiWithNoKeyword("1f251"),
        _createEmojiWithNoKeyword("1f234"),
        _createEmojiWithNoKeyword("1f233"),
        _createEmojiWithNoKeyword("1f23a"),
        _createEmojiWithNoKeyword("1f235")
    ],
    _a["Objects" /* Objects */] = [
        _createEmojiWithNoKeyword("0231a"),
        _createEmoji("1f4f1"),
        _createEmojiWithNoKeyword("1f4f2"),
        _createEmoji("1f4bb"),
        _createEmojiWithNoKeyword("1f4bd"),
        _createEmoji("1f4be"),
        _createEmoji("1f4bf"),
        _createEmoji("1f4c0"),
        _createEmoji("1f4fc"),
        _createEmoji("1f4f7"),
        _createEmoji("1f4f9"),
        _createEmoji("1f3a5"),
        _createEmoji("1f4de"),
        _createEmojiWithNoKeyword("0260e"),
        _createEmoji("1f4df"),
        _createEmoji("1f4e0"),
        _createEmoji("1f4fa"),
        _createEmoji("1f4fb"),
        _createEmojiWithNoKeyword("023f0"),
        _createEmojiWithNoKeyword("0231b"),
        _createEmojiWithNoKeyword("023f3"),
        _createEmoji("1f4e1"),
        _createEmoji("1f50b"),
        _createEmoji("1f50c"),
        _createEmoji("1f4a1"),
        _createEmoji("1f526"),
        _createEmojiWithNoKeyword("1f4b8"),
        _createEmoji("1f4b5"),
        _createEmoji("1f4b4"),
        _createEmoji("1f4b0"),
        _createEmoji("1f4b3"),
        _createEmoji("1f48e"),
        _createEmoji("1f527"),
        _createEmoji("1f528"),
        _createEmoji("1f529"),
        _createEmojiWithNoKeyword("1f52b"),
        _createEmoji("1f4a3"),
        _createEmoji("1f52a"),
        _createEmoji("1f6ac"),
        _createEmoji("1f52e"),
        _createEmoji("1f488"),
        _createEmoji("1f48a"),
        _createEmoji("1f489"),
        _createEmoji("1f516"),
        _createEmoji("1f6bd"),
        _createEmoji("1f6c0"),
        _createEmoji("1f511"),
        _createEmoji("1f6aa"),
        _createEmojiWithNoKeyword("1f5ff"),
        _createEmoji("1f388"),
        _createEmojiWithNoKeyword("1f38f"),
        _createEmoji("1f380"),
        _createEmoji("1f381"),
        _createEmoji("1f38a"),
        _createEmoji("1f389"),
        _createEmojiWithNoKeyword("1f38e"),
        _createEmoji("1f390"),
        _createEmojiWithNoKeyword("1f38c"),
        _createEmojiWithNoKeyword("1f3ee"),
        _createEmoji("02709"),
        _createEmoji("1f4e9"),
        _createEmoji("1f4e8"),
        _createEmoji("1f48c"),
        _createEmoji("1f4e7"),
        _createEmoji("1f4ee"),
        _createEmoji("1f4ea"),
        _createEmoji("1f4eb"),
        _createEmoji("1f4e6"),
        _createEmojiWithNoKeyword("1f4e5"),
        _createEmojiWithNoKeyword("1f4e4"),
        _createEmojiWithNoKeyword("1f4dc"),
        _createEmojiWithNoKeyword("1f4c3"),
        _createEmojiWithNoKeyword("1f4d1"),
        _createEmoji("1f4ca"),
        _createEmoji("1f4c8"),
        _createEmoji("1f4c9"),
        _createEmojiWithNoKeyword("1f4c4"),
        _createEmoji("1f4c5"),
        _createEmojiWithNoKeyword("1f4c6"),
        _createEmojiWithNoKeyword("1f4c7"),
        _createEmoji("1f4cb"),
        _createEmoji("1f4c1"),
        _createEmojiWithNoKeyword("1f4c2"),
        _createEmoji("1f4f0"),
        _createEmoji("1f4d3"),
        _createEmojiWithNoKeyword("1f4d5"),
        _createEmojiWithNoKeyword("1f4d7"),
        _createEmojiWithNoKeyword("1f4d8"),
        _createEmojiWithNoKeyword("1f4d9"),
        _createEmojiWithNoKeyword("1f4d4"),
        _createEmoji("1f4d2"),
        _createEmoji("1f4da"),
        _createEmojiWithNoKeyword("1f4d6"),
        _createEmojiWithNoKeyword("1f517"),
        _createEmoji("1f4ce"),
        _createEmoji("02702"),
        _createEmojiWithNoKeyword("1f4d0"),
        _createEmoji("1f4cf"),
        _createEmoji("1f4cc"),
        _createEmoji("1f4cd"),
        _createEmojiWithNoKeyword("1f6a9"),
        _createEmoji("1f510"),
        _createEmoji("1f512"),
        _createEmoji("1f513"),
        _createEmoji("1f50f"),
        _createEmojiWithNoKeyword("02712"),
        _createEmoji("1f4dd"),
        _createEmoji("0270f"),
        _createEmoji("1f50d"),
        _createEmojiWithNoKeyword("1f50e")
    ],
    _a);
exports.default = EmojiList;
exports.EmojiFabricIconCharacterMap = (_b = {},
    _b["Activities" /* Activities */] = "Soccer",
    _b["Food" /* Food */] = "EatDrink",
    _b["Nature" /* Nature */] = "FangBody",
    _b["Objects" /* Objects */] = "Lightbulb",
    _b["People" /* People */] = "Emoji2",
    _b["Symbols" /* Symbols */] = "Heart",
    _b["Travel" /* Travel */] = "Car",
    _b);
function forEachEmojiFamily(callback) {
    var families = Object.keys(EmojiList);
    for (var _i = 0, families_1 = families; _i < families_1.length; _i++) {
        var family = families_1[_i];
        if (!callback(EmojiList[family], family)) {
            break;
        }
    }
}
exports.forEachEmojiFamily = forEachEmojiFamily;
function forEachEmoji(callback) {
    forEachEmojiFamily(function (emojis) {
        for (var _i = 0, emojis_1 = emojis; _i < emojis_1.length; _i++) {
            var emoji = emojis_1[_i];
            if (!callback(emoji)) {
                return false;
            }
        }
        return true;
    });
}
exports.forEachEmoji = forEachEmoji;
// get emoji code point from an emoji key
function _getEmojiCodePoint(key) {
    var unicode = parseInt(key, 16);
    if (isNaN(unicode)) {
        return null;
    }
    // All emojis have codepoints between the following ranges:
    // 0x1F7000 - 0x1F700 -> has surrogate pairs
    // 0x00023 - 0x04000 -> does not have surrogate pairs
    var surrogatePairs;
    if (unicode >= 0x1f000 && unicode <= 0x1f700) {
        var hi = Math.floor((unicode - 0x10000) / 0x400) + 0xd800;
        var lo = ((unicode - 0x10000) % 0x400) + 0xdc00;
        surrogatePairs = [hi, lo];
    }
    else if (unicode >= 0x00023 && unicode <= 0x04000) {
        surrogatePairs = [unicode];
    }
    return String.fromCharCode.apply(String, surrogatePairs);
}
function _createEmoji(key, shortcut) {
    return { key: key, description: "emjD" + key, keywords: "emjK" + key, shortcut: shortcut, codePoint: _getEmojiCodePoint(key) };
}
function _createEmojiWithNoKeyword(key) {
    return { key: key, description: "emjD" + key, codePoint: _getEmojiCodePoint(key) };
}


/***/ }),

/***/ "./packages/roosterjs-react-emoji/lib/utils/searchEmojis.ts":
/*!******************************************************************!*\
  !*** ./packages/roosterjs-react-emoji/lib/utils/searchEmojis.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.matchShortcut = exports.searchEmojis = void 0;
var emojiList_1 = __webpack_require__(/*! ./emojiList */ "./packages/roosterjs-react-emoji/lib/utils/emojiList.ts");
function searchEmojis(search, strings) {
    var shortcutMatch = matchShortcut(search);
    search = search.toLowerCase();
    var fullMatch = shortcutMatch ? [shortcutMatch] : [];
    var partialMatch = [];
    var partialSearch = " " + (search[0] == ":" ? search.substr(1) : search);
    emojiList_1.forEachEmoji(function (emoji) {
        var keywords = strings[emoji.keywords] || "";
        var searchableKeywords = emoji.keywords ? " " + keywords.toLowerCase() + " " : "";
        var index = searchableKeywords.indexOf(partialSearch);
        if (index >= 0) {
            (searchableKeywords[index + partialSearch.length] == " " ? fullMatch : partialMatch).push(emoji);
        }
        return true;
    });
    return fullMatch.concat(partialMatch);
}
exports.searchEmojis = searchEmojis;
function matchShortcut(search) {
    var result;
    search = " " + search + " ";
    emojiList_1.forEachEmoji(function (emoji) {
        if (emoji.shortcut && (" " + emoji.shortcut + " ").indexOf(search) >= 0) {
            result = emoji;
            return false;
        }
        return true;
    });
    return result;
}
exports.matchShortcut = matchShortcut;


/***/ }),

/***/ "./packages/roosterjs-react/lib/index.ts":
/*!***********************************************!*\
  !*** ./packages/roosterjs-react/lib/index.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! roosterjs-html-sanitizer */ "./node_modules/roosterjs-html-sanitizer/lib/index.js"), exports);
__exportStar(__webpack_require__(/*! roosterjs-editor-types */ "./node_modules/roosterjs-editor-types/lib/index.js"), exports);
__exportStar(__webpack_require__(/*! roosterjs-editor-dom */ "./node_modules/roosterjs-editor-dom/lib/index.js"), exports);
__exportStar(__webpack_require__(/*! roosterjs-editor-core */ "./node_modules/roosterjs-editor-core/lib/index.js"), exports);
__exportStar(__webpack_require__(/*! roosterjs-editor-api */ "./node_modules/roosterjs-editor-api/lib/index.js"), exports);
__exportStar(__webpack_require__(/*! roosterjs-editor-plugins */ "./node_modules/roosterjs-editor-plugins/lib/index.js"), exports);
//export * from 'roosterjs-plugin-image-resize';
__exportStar(__webpack_require__(/*! roosterjs-react-common */ "./packages/roosterjs-react-common/lib/index.ts"), exports);
__exportStar(__webpack_require__(/*! roosterjs-react-command-bar */ "./packages/roosterjs-react-command-bar/lib/index.ts"), exports);
__exportStar(__webpack_require__(/*! roosterjs-react-editor */ "./packages/roosterjs-react-editor/lib/index.ts"), exports);
__exportStar(__webpack_require__(/*! roosterjs-react-emoji */ "./packages/roosterjs-react-emoji/lib/index.ts"), exports);


/***/ }),

/***/ "office-ui-fabric-react/lib/Button":
/*!**************************************!*\
  !*** external "OfficeFabric/Button" ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Button__;

/***/ }),

/***/ "office-ui-fabric-react/lib/Callout":
/*!***************************************!*\
  !*** external "OfficeFabric/Callout" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Callout__;

/***/ }),

/***/ "office-ui-fabric-react/lib/CommandBar":
/*!******************************************!*\
  !*** external "OfficeFabric/CommandBar" ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_CommandBar__;

/***/ }),

/***/ "office-ui-fabric-react/lib/ContextualMenu":
/*!**********************************************!*\
  !*** external "OfficeFabric/ContextualMenu" ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_ContextualMenu__;

/***/ }),

/***/ "office-ui-fabric-react/lib/Dialog":
/*!**************************************!*\
  !*** external "OfficeFabric/Dialog" ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Dialog__;

/***/ }),

/***/ "office-ui-fabric-react/lib/FocusZone":
/*!*****************************************!*\
  !*** external "OfficeFabric/FocusZone" ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_FocusZone__;

/***/ }),

/***/ "office-ui-fabric-react/lib/Icon":
/*!************************************!*\
  !*** external "OfficeFabric/Icon" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Icon__;

/***/ }),

/***/ "office-ui-fabric-react/lib/TextField":
/*!*****************************************!*\
  !*** external "OfficeFabric/TextField" ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_TextField__;

/***/ }),

/***/ "office-ui-fabric-react/lib/Tooltip":
/*!***************************************!*\
  !*** external "OfficeFabric/Tooltip" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Tooltip__;

/***/ }),

/***/ "office-ui-fabric-react/lib/Utilities":
/*!*****************************************!*\
  !*** external "OfficeFabric/Utilities" ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_office_ui_fabric_react_lib_Utilities__;

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_react_dom__;

/***/ })

/******/ })});;
//# sourceMappingURL=rooster-react-amd.js.map